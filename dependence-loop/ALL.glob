DIGEST NO
Fproof
R15:28 Coq.Lists.List <> <> lib
R46:51 Coq.funind.FunInd <> <> lib
R69:85 Coq.Lists.ListSet <> <> lib
R103:119 Coq.ZArith.BinInt <> <> lib
R137:156 Coq.ZArith.BinIntDef <> <> lib
R174:192 Coq.Numbers.BinNums <> <> lib
R210:223 Coq.Lists.List <> <> lib
R241:256 Coq.ZArith.Zbool <> <> lib
R274:287 Coq.ZArith.Int <> <> lib
R305:327 Coq.Sorting.Permutation <> <> lib
R345:378 Coq.Logic.FunctionalExtensionality <> <> lib
R396:424 Coq.Logic.ExtensionalityFacts <> <> lib
R442:446 Coq.omega.Omega <> <> lib
R464:479 Coq.Bool.Sumbool <> <> lib
R497:513 Coq.ZArith.Zhints <> <> lib
R531:550 Coq.Classes.EquivDec <> <> lib
R568:592 Coq.Structures.Equalities <> <> lib
R610:632 Coq.FSets.FMapInterface <> <> lib
R650:656 Coq.FSets.FMapAVL <> <> lib
R674:682 Coq.FSets.FMapFacts <> <> lib
R700:715 Coq.Logic.FinFun <> <> lib
R733:735 Coq.Init.Nat <> <> lib
R753:761 Coq.Vectors.VectorDef <> <> lib
R779:790 Coq.MSets.MSetWeakList <> <> lib
R808:820 Coq.FSets.FSetInterface <> <> lib
R838:845 Coq.FSets.FSetList <> <> lib
R863:882 Coq.Program.Equality <> <> lib
R900:923 CoLoR.Util.FSet.FSetUtil <> <> lib
R1158:1175 Coq.FSets.FMapList <> <> lib
R1179:1206 Coq.Structures.OrderedTypeEx <> <> lib
R1229:1241 Coq.FSets.FMapList Make <> modtype
R1243:1249 Coq.Structures.OrderedTypeEx Z_as_OT <> modtype
mod 1224:1224 <> M
R1277:1282 Coq.FSets.FMapFacts WFacts <> modtype
R1284:1284 proof M <> modtype
mod 1267:1272 <> MFacts
R1308:1326 Coq.FSets.FMapFacts <> <> lib
syndef 1413:1417 <> memix
R1422:1424 Coq.Init.Datatypes <> nat ind
syndef 1460:1467 <> memvalue
R1472:1472 Coq.Numbers.BinNums <> Z ind
ind 1486:1490 <> write
constr 1504:1508 <> Write
R1516:1519 Coq.Init.Logic <> :type_scope:x_'->'_x not
R1528:1531 Coq.Init.Logic <> :type_scope:x_'->'_x not
R1532:1536 proof <> write ind
R1520:1527 proof <> memvalue syndef
R1511:1515 proof <> memix syndef
def 1552:1557 <> memory
R1568:1571 Coq.Init.Logic <> :type_scope:x_'->'_x not
R1572:1579 proof <> memvalue syndef
R1563:1567 proof <> memix syndef
R1611:1616 proof <> memory def
not 1592:1592 <> ::x_'::='_x
def 1683:1692 <> initMemory
R1696:1701 proof <> memory def
R1716:1717 Coq.Numbers.BinNums <> Z0 constr
prf 1729:1748 <> initMemoryAlwaysZero
R1765:1769 proof <> memix syndef
R1773:1773 Coq.Init.Logic <> :type_scope:x_'='_x not
R1788:1791 Coq.Init.Logic <> :type_scope:x_'='_x not
R1774:1783 proof <> initMemory def
R1785:1787 proof <> wix var
R1792:1793 Coq.Numbers.BinNums <> Z0 constr
def 1829:1841 <> writeToMemory
R1849:1853 proof <> memix syndef
R1863:1870 proof <> memvalue syndef
R1880:1885 proof <> memory def
R1890:1895 proof <> memory def
R1918:1921 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R1916:1917 proof <> ix var
R1922:1924 proof <> wix var
R1942:1945 proof <> mold var
R1947:1948 proof <> ix var
R1932:1935 proof <> wval var
def 1963:1976 <> writeToMemory'
R1982:1986 proof <> write ind
R1996:2001 proof <> memory def
R2006:2011 proof <> memory def
R2024:2024 proof <> w var
R2035:2039 proof <> Write constr
R2051:2063 proof <> writeToMemory def
R2072:2075 proof <> mold var
prf 2093:2114 <> readFromWriteIdentical
R2131:2135 proof <> memix syndef
R2145:2152 proof <> memvalue syndef
R2161:2166 proof <> memory def
R2206:2208 Coq.Init.Logic <> :type_scope:x_'='_x not
R2175:2187 proof <> writeToMemory def
R2198:2200 proof <> mem var
R2193:2196 proof <> wval var
R2189:2191 proof <> wix var
R2203:2205 proof <> wix var
R2209:2212 proof <> wval var
R2254:2266 proof <> writeToMemory def
R2279:2290 Coq.Arith.PeanoNat Nat eqb_refl thm
R2279:2290 Coq.Arith.PeanoNat Nat eqb_refl thm
R2279:2290 Coq.Arith.PeanoNat Nat eqb_refl thm
prf 2383:2404 <> readFromWriteDifferent
R2421:2425 proof <> memix syndef
R2434:2438 proof <> memix syndef
R2449:2456 proof <> memvalue syndef
R2465:2470 proof <> memory def
R2488:2491 Coq.Init.Logic <> :type_scope:x_'->'_x not
R2524:2526 Coq.Init.Logic <> :type_scope:x_'='_x not
R2493:2505 proof <> writeToMemory def
R2516:2518 proof <> mem var
R2511:2514 proof <> wval var
R2507:2509 proof <> wix var
R2521:2523 proof <> rix var
R2527:2529 proof <> mem var
R2531:2533 proof <> rix var
R2481:2484 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R2478:2480 proof <> rix var
R2485:2487 proof <> wix var
R2601:2613 proof <> writeToMemory def
R2625:2625 Coq.Init.Logic <> :type_scope:x_'='_x not
R2636:2639 Coq.Init.Logic <> :type_scope:x_'='_x not
R2629:2632 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R2640:2644 Coq.Init.Datatypes <> false constr
R2625:2625 Coq.Init.Logic <> :type_scope:x_'='_x not
R2636:2639 Coq.Init.Logic <> :type_scope:x_'='_x not
R2629:2632 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R2640:2644 Coq.Init.Datatypes <> false constr
R2656:2666 Coq.Arith.PeanoNat Nat eqb_neq thm
R2656:2666 Coq.Arith.PeanoNat Nat eqb_neq thm
def 2789:2808 <> modelWriteSideEffect
R2817:2822 proof <> memory def
R2829:2833 proof <> write ind
R2838:2843 proof <> memory def
R2856:2856 proof <> w var
R2867:2871 proof <> Write constr
R2886:2898 proof <> writeToMemory def
R2909:2912 proof <> mold var
ind 2934:2936 <> com
constr 2949:2952 <> CSeq
constr 2977:2982 <> CBegin
R2958:2961 Coq.Init.Logic <> :type_scope:x_'->'_x not
R2967:2970 Coq.Init.Logic <> :type_scope:x_'->'_x not
R2971:2973 proof <> com ind
R2962:2966 proof <> write ind
R2955:2957 proof <> com ind
R2985:2987 proof <> com ind
def 3000:3005 <> comlen
R3011:3013 proof <> com ind
R3018:3020 Coq.Init.Datatypes <> nat ind
R3033:3033 proof <> c var
R3044:3049 proof <> CBegin constr
R3060:3063 proof <> CSeq constr
R3074:3076 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R3077:3082 proof <> comlen def
prf 3103:3135 <> n_minus_1_plus_1_eq_n_when_n_gt_0
R3149:3151 Coq.Init.Datatypes <> nat ind
R3160:3163 Coq.Init.Logic <> :type_scope:x_'->'_x not
R3173:3175 Coq.Init.Logic <> :type_scope:x_'='_x not
R3169:3171 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R3165:3167 Coq.Init.Peano <> :nat_scope:x_'-'_x not
R3164:3164 proof <> n var
R3176:3176 proof <> n var
R3156:3158 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R3155:3155 proof <> n var
def 3217:3226 <> c_example'
R3230:3232 proof <> com ind
R3238:3241 proof <> CSeq constr
R3274:3278 proof <> Write constr
R3244:3247 proof <> CSeq constr
R3257:3261 proof <> Write constr
R3249:3254 proof <> CBegin constr
syndef 3302:3310 <> timepoint
R3316:3318 Coq.Init.Datatypes <> nat ind
def 3332:3339 <> writeset
R3355:3358 Coq.Init.Logic <> :type_scope:x_'->'_x not
R3359:3362 Coq.Init.Datatypes <> list ind
R3364:3372 proof <> timepoint syndef
R3350:3354 proof <> memix syndef
def 3387:3399 <> emptyWriteSet
R3403:3410 proof <> writeset def
R3425:3432 Coq.Lists.List <> nil syndef
def 3446:3458 <> addToWriteSet
R3465:3472 proof <> writeset def
R3480:3484 proof <> memix syndef
R3492:3500 proof <> timepoint syndef
R3505:3512 proof <> writeset def
R3536:3539 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R3533:3535 proof <> ix' var
R3540:3541 proof <> ix var
R3601:3602 proof <> ws var
R3604:3606 proof <> ix' var
R3561:3569 Coq.Lists.List <> cons syndef
R3575:3576 proof <> ws var
R3578:3580 proof <> ix' var
R3571:3572 proof <> tp var
def 3620:3636 <> singletonWriteSet
R3643:3647 proof <> memix syndef
R3655:3663 proof <> timepoint syndef
R3668:3675 proof <> writeset def
R3682:3694 proof <> addToWriteSet def
R3713:3714 proof <> tp var
R3710:3711 proof <> ix var
R3696:3708 proof <> emptyWriteSet def
prf 3788:3814 <> destructInSingletonWriteSet
R3837:3841 proof <> memix syndef
R3855:3863 proof <> timepoint syndef
R3918:3921 Coq.Init.Logic <> :type_scope:x_'->'_x not
R3932:3935 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R3927:3929 Coq.Init.Logic <> :type_scope:x_'='_x not
R3922:3926 proof <> curtp var
R3930:3931 proof <> tp var
R3938:3940 Coq.Init.Logic <> :type_scope:x_'='_x not
R3936:3937 proof <> ix var
R3941:3945 proof <> curix var
R3871:3877 Coq.Lists.List <> In def
R3887:3903 proof <> singletonWriteSet def
R3908:3909 proof <> tp var
R3905:3906 proof <> ix var
R3912:3916 proof <> curix var
R3879:3883 proof <> curtp var
R3967:3983 proof <> singletonWriteSet def
R4000:4012 proof <> addToWriteSet def
R4040:4043 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R4035:4037 Coq.Init.Logic <> :type_scope:x_'='_x not
R4049:4052 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R4040:4043 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R4035:4037 Coq.Init.Logic <> :type_scope:x_'='_x not
R4049:4052 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R4115:4124 Coq.Arith.PeanoNat Nat eqb_eq thm
R4115:4124 Coq.Arith.PeanoNat Nat eqb_eq thm
R4115:4124 Coq.Arith.PeanoNat Nat eqb_eq thm
R4192:4201 Coq.Arith.PeanoNat Nat eqb_eq thm
R4192:4201 Coq.Arith.PeanoNat Nat eqb_eq thm
R4192:4201 Coq.Arith.PeanoNat Nat eqb_eq thm
R4265:4275 Coq.Arith.PeanoNat Nat eqb_neq thm
R4265:4275 Coq.Arith.PeanoNat Nat eqb_neq thm
R4265:4275 Coq.Arith.PeanoNat Nat eqb_neq thm
def 4335:4348 <> mergeWriteSets
R4359:4366 proof <> writeset def
R4371:4378 proof <> writeset def
R4400:4403 Coq.Init.Datatypes <> :list_scope:x_'++'_x not
R4395:4396 proof <> ws var
R4398:4399 proof <> ix var
R4404:4406 proof <> ws' var
R4408:4409 proof <> ix var
def 4441:4455 <> writeToWriteset
R4461:4465 proof <> write ind
R4473:4481 proof <> timepoint syndef
R4486:4493 proof <> writeset def
R4506:4506 proof <> w var
R4517:4521 proof <> Write constr
R4535:4551 proof <> singletonWriteSet def
R4556:4557 proof <> tp var
prf 4573:4598 <> destructInWriteToWriteSet'
R4614:4616 Coq.Init.Datatypes <> nat ind
R4628:4636 proof <> timepoint syndef
R4650:4654 proof <> memix syndef
R4663:4670 proof <> memvalue syndef
R4732:4735 Coq.Init.Logic <> :type_scope:x_'->'_x not
R4745:4748 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R4741:4743 Coq.Init.Logic <> :type_scope:x_'='_x not
R4736:4740 proof <> curtp var
R4744:4744 proof <> n var
R4754:4756 Coq.Init.Logic <> :type_scope:x_'='_x not
R4749:4753 proof <> curix var
R4757:4758 proof <> ix var
R4678:4684 Coq.Lists.List <> In def
R4693:4707 proof <> writeToWriteset def
R4726:4730 proof <> curix var
R4724:4724 proof <> n var
R4710:4714 proof <> Write constr
R4719:4721 proof <> val var
R4716:4717 proof <> ix var
R4686:4690 proof <> curtp var
R4787:4801 proof <> writeToWriteset def
R4817:4843 proof <> destructInSingletonWriteSet thm
R4817:4843 proof <> destructInSingletonWriteSet thm
def 4878:4887 <> dependence
R4901:4903 Coq.Init.Datatypes <> :type_scope:x_'*'_x not
R4898:4900 Coq.Init.Datatypes <> nat ind
R4904:4906 Coq.Init.Datatypes <> nat ind
def 4920:4932 <> dependenceset
R4943:4946 Coq.Init.Datatypes <> list ind
R4948:4957 proof <> dependence def
def 4971:4988 <> emptyDependenceSet
R4992:5004 proof <> dependenceset def
R5009:5016 Coq.Lists.List <> nil syndef
def 5032:5052 <> dependenceLexPositive
R5058:5067 proof <> dependence def
R5087:5089 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R5082:5084 Coq.Init.Datatypes <> fst def
R5086:5086 proof <> d var
R5090:5092 Coq.Init.Datatypes <> snd def
R5094:5094 proof <> d var
def 5109:5124 <> commandIxInRange
R5131:5133 proof <> com ind
R5140:5142 Coq.Init.Datatypes <> nat ind
R5170:5173 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R5158:5161 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R5157:5157 proof <> i var
R5162:5167 proof <> comlen def
R5169:5169 proof <> c var
R5175:5178 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R5174:5174 proof <> i var
prf 5189:5218 <> commandIxInRangeDestructOnCSeq
R5232:5234 proof <> com ind
R5241:5245 proof <> write ind
R5252:5254 Coq.Init.Datatypes <> nat ind
R5287:5291 Coq.Init.Logic <> :type_scope:x_'->'_x not
R5309:5313 Coq.Init.Logic <> :type_scope:x_'->'_x not
R5314:5329 proof <> commandIxInRange def
R5333:5333 proof <> i var
R5331:5331 proof <> c var
R5293:5296 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R5292:5292 proof <> i var
R5305:5307 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R5297:5302 proof <> comlen def
R5304:5304 proof <> c var
R5258:5273 proof <> commandIxInRange def
R5286:5286 proof <> i var
R5276:5279 proof <> CSeq constr
R5283:5283 proof <> w var
R5281:5281 proof <> c var
R5362:5377 proof <> commandIxInRange def
R5394:5409 proof <> commandIxInRange def
prf 5445:5469 <> commandIxInRangeInclusive
R5483:5485 proof <> com ind
R5492:5496 proof <> write ind
R5503:5505 Coq.Init.Datatypes <> nat ind
R5529:5532 Coq.Init.Logic <> :type_scope:x_'->'_x not
R5533:5548 proof <> commandIxInRange def
R5561:5561 proof <> i var
R5551:5554 proof <> CSeq constr
R5558:5558 proof <> w var
R5556:5556 proof <> c var
R5509:5524 proof <> commandIxInRange def
R5528:5528 proof <> i var
R5526:5526 proof <> c var
R5573:5588 proof <> commandIxInRange def
R5598:5603 proof <> comlen def
R5611:5616 proof <> comlen def
R5611:5616 proof <> comlen def
def 5657:5673 <> dependenceInRange
R5679:5688 proof <> dependence def
R5695:5697 proof <> com ind
R5738:5741 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R5712:5727 proof <> commandIxInRange def
R5732:5734 Coq.Init.Datatypes <> fst def
R5736:5736 proof <> d var
R5729:5729 proof <> c var
R5742:5757 proof <> commandIxInRange def
R5762:5764 Coq.Init.Datatypes <> snd def
R5766:5766 proof <> d var
R5759:5759 proof <> c var
prf 5777:5802 <> dependenceInRangeSymmetric
R5826:5834 proof <> timepoint syndef
R5841:5843 proof <> com ind
R5885:5889 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R5851:5867 proof <> dependenceInRange def
R5884:5884 proof <> c var
R5869:5869 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5876:5877 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5882:5882 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5870:5875 proof <> tbegin var
R5878:5881 proof <> tend var
R5890:5906 proof <> dependenceInRange def
R5923:5923 proof <> c var
R5908:5908 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5913:5914 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5921:5921 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5909:5912 proof <> tend var
R5915:5920 proof <> tbegin var
R5974:5982 proof <> timepoint syndef
R6033:6049 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6050:6066 proof <> dependenceInRange def
R6068:6068 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6073:6074 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6081:6081 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6069:6072 proof <> tend var
R6075:6080 proof <> tbegin var
R5999:6015 proof <> dependenceInRange def
R6017:6017 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6024:6025 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6030:6030 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6018:6023 proof <> tbegin var
R6026:6029 proof <> tend var
R5974:5982 proof <> timepoint syndef
R6033:6049 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6050:6066 proof <> dependenceInRange def
R6068:6068 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6073:6074 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6081:6081 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6069:6072 proof <> tend var
R6075:6080 proof <> tbegin var
R5999:6015 proof <> dependenceInRange def
R6017:6017 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6024:6025 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6030:6030 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6018:6023 proof <> tbegin var
R6026:6029 proof <> tend var
R6096:6112 proof <> dependenceInRange def
R6125:6140 proof <> commandIxInRange def
def 6219:6225 <> writeIx
R6231:6235 proof <> write ind
R6240:6244 proof <> memix syndef
R6257:6257 proof <> w var
R6268:6272 proof <> Write constr
def 6346:6356 <> getWriteAt'
R6362:6364 proof <> com ind
R6371:6373 Coq.Init.Datatypes <> nat ind
R6378:6383 Coq.Init.Datatypes <> option ind
R6385:6389 proof <> write ind
R6402:6402 proof <> c var
R6413:6418 proof <> CBegin constr
R6423:6426 Coq.Init.Datatypes <> None constr
R6432:6435 proof <> CSeq constr
R6449:6453 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R6462:6462 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R6448:6448 proof <> i var
R6454:6459 proof <> comlen def
R6461:6461 proof <> c var
R6481:6491 proof <> getWriteAt' def
R6496:6496 proof <> i var
R6469:6472 Coq.Init.Datatypes <> Some constr
def 6526:6543 <> dependenceAliases'
R6549:6558 proof <> dependence def
R6565:6567 proof <> com ind
R6593:6595 Coq.Init.Datatypes <> fst def
R6597:6597 proof <> d var
R6615:6617 Coq.Init.Datatypes <> snd def
R6619:6619 proof <> d var
R6636:6646 proof <> getWriteAt' def
R6650:6652 proof <> ix1 var
R6648:6648 proof <> c var
R6669:6679 proof <> getWriteAt' def
R6683:6685 proof <> ix2 var
R6681:6681 proof <> c var
R6713:6715 Coq.Init.Logic <> :type_scope:x_'='_x not
R6692:6701 Coq.Init.Datatypes <> option_map def
R6711:6712 proof <> w1 var
R6703:6709 proof <> writeIx def
R6716:6725 Coq.Init.Datatypes <> option_map def
R6735:6736 proof <> w2 var
R6727:6733 proof <> writeIx def
prf 6746:6772 <> dependenceAliases'Symmetric
R6796:6804 proof <> timepoint syndef
R6811:6813 proof <> com ind
R6856:6860 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R6821:6838 proof <> dependenceAliases' def
R6855:6855 proof <> c var
R6840:6840 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6847:6848 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6853:6853 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6841:6846 proof <> tbegin var
R6849:6852 proof <> tend var
R6861:6878 proof <> dependenceAliases' def
R6895:6895 proof <> c var
R6880:6880 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6885:6886 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6893:6893 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6881:6884 proof <> tend var
R6887:6892 proof <> tbegin var
R6931:6939 proof <> timepoint syndef
R6970:6973 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6974:6991 proof <> dependenceAliases' def
R6993:6993 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6995:6996 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6998:6998 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6994:6994 proof <> y var
R6997:6997 proof <> x var
R6943:6960 proof <> dependenceAliases' def
R6962:6962 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6964:6965 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6967:6967 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6963:6963 proof <> x var
R6966:6966 proof <> y var
R6931:6939 proof <> timepoint syndef
R6970:6973 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6974:6991 proof <> dependenceAliases' def
R6993:6993 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6995:6996 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6998:6998 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6994:6994 proof <> y var
R6997:6997 proof <> x var
R6943:6960 proof <> dependenceAliases' def
R6962:6962 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6964:6965 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6967:6967 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6963:6963 proof <> x var
R6966:6966 proof <> y var
R7013:7030 proof <> dependenceAliases' def
def 7104:7118 <> computeWriteSet
R7124:7126 proof <> com ind
R7131:7138 proof <> writeset def
R7151:7151 proof <> c var
R7162:7165 proof <> CSeq constr
R7176:7189 proof <> mergeWriteSets def
R7213:7227 proof <> writeToWriteset def
R7232:7237 proof <> comlen def
R7239:7239 proof <> c var
R7192:7206 proof <> computeWriteSet def
R7247:7252 proof <> CBegin constr
R7257:7269 proof <> emptyWriteSet def
def 7293:7323 <> dependencesFromWriteSetAndWrite
R7329:7337 proof <> timepoint syndef
R7345:7352 proof <> writeset def
R7359:7363 proof <> write ind
R7368:7380 proof <> dependenceset def
R7393:7393 proof <> w var
R7404:7408 proof <> Write constr
R7453:7454 proof <> ws var
R7480:7487 Coq.Lists.List <> map def
R7512:7538 proof <> prev_write_timepoints_at_ix var
R7501:7501 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7505:7506 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7508:7508 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7502:7504 proof <> pwt var
R7507:7507 proof <> t var
def 7562:7579 <> computeDependences
R7585:7587 proof <> com ind
R7592:7604 proof <> dependenceset def
R7617:7617 proof <> c var
R7628:7633 proof <> CBegin constr
R7638:7655 proof <> emptyDependenceSet def
R7661:7664 proof <> CSeq constr
R7694:7711 proof <> computeDependences def
R7744:7758 proof <> computeWriteSet def
R7770:7770 Coq.Init.Datatypes <> :list_scope:x_'++'_x not
R7828:7832 Coq.Init.Datatypes <> :list_scope:x_'++'_x not
R7771:7801 proof <> dependencesFromWriteSetAndWrite def
R7814:7825 proof <> prevwriteset var
R7804:7809 proof <> comlen def
R7811:7811 proof <> c var
R7833:7840 proof <> prevdeps var
prf 7933:7957 <> computeDependence0IsEmpty
R7971:7973 proof <> com ind
R7989:7992 Coq.Init.Logic <> :type_scope:x_'->'_x not
R8013:8015 Coq.Init.Logic <> :type_scope:x_'='_x not
R7993:8010 proof <> computeDependences def
R8012:8012 proof <> c var
R8016:8023 Coq.Lists.List <> nil syndef
R7985:7987 Coq.Init.Logic <> :type_scope:x_'='_x not
R7977:7982 proof <> comlen def
R7984:7984 proof <> c var
prf 8128:8150 <> computeWriteSetInBounds
R8164:8166 proof <> com ind
R8174:8178 proof <> memix syndef
R8185:8193 proof <> timepoint syndef
R8232:8235 Coq.Init.Logic <> :type_scope:x_'->'_x not
R8251:8254 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R8237:8241 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R8250:8250 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R8236:8236 proof <> t var
R8242:8247 proof <> comlen def
R8249:8249 proof <> c var
R8256:8259 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R8255:8255 proof <> t var
R8197:8203 Coq.Lists.List <> In def
R8209:8223 proof <> computeWriteSet def
R8226:8226 proof <> c var
R8229:8230 proof <> ix var
R8205:8205 proof <> t var
R8316:8330 proof <> computeWriteSet def
R8343:8357 proof <> computeWriteSet def
R8343:8357 proof <> computeWriteSet def
R8374:8387 proof <> mergeWriteSets def
R8405:8419 Coq.Lists.List <> in_app_iff thm
R8405:8419 Coq.Lists.List <> in_app_iff thm
R8405:8419 Coq.Lists.List <> in_app_iff thm
R8477:8482 proof <> comlen def
R8490:8495 proof <> comlen def
R8490:8495 proof <> comlen def
R8514:8519 proof <> comlen def
R8527:8532 proof <> comlen def
R8527:8532 proof <> comlen def
R8544:8558 proof <> writeToWriteset def
R8598:8624 proof <> destructInSingletonWriteSet thm
R8598:8624 proof <> destructInSingletonWriteSet thm
prf 8685:8713 <> computeDependencesLexPositive
R8727:8729 proof <> com ind
R8748:8757 proof <> dependence def
R8793:8796 Coq.Init.Logic <> :type_scope:x_'->'_x not
R8797:8817 proof <> dependenceLexPositive def
R8819:8819 proof <> d var
R8761:8767 Coq.Lists.List <> In def
R8772:8789 proof <> computeDependences def
R8791:8791 proof <> c var
R8769:8769 proof <> d var
R8899:8916 proof <> computeDependences def
R8945:8962 proof <> computeDependences def
R8945:8962 proof <> computeDependences def
R8992:9006 Coq.Lists.List <> in_app_iff thm
R8992:9006 Coq.Lists.List <> in_app_iff thm
R8992:9006 Coq.Lists.List <> in_app_iff thm
R9073:9103 proof <> dependencesFromWriteSetAndWrite def
R9119:9128 Coq.Lists.List <> in_map_iff thm
R9119:9128 Coq.Lists.List <> in_map_iff thm
R9172:9194 proof <> computeWriteSetInBounds thm
R9172:9194 proof <> computeWriteSetInBounds thm
R9212:9232 proof <> dependenceLexPositive def
R9319:9336 proof <> computeDependences def
prf 9391:9415 <> computeDependencesInRange
R9429:9431 proof <> com ind
R9450:9459 proof <> dependence def
R9495:9498 Coq.Init.Logic <> :type_scope:x_'->'_x not
R9499:9515 proof <> dependenceInRange def
R9519:9519 proof <> c var
R9517:9517 proof <> d var
R9463:9469 Coq.Lists.List <> In def
R9474:9491 proof <> computeDependences def
R9493:9493 proof <> c var
R9471:9471 proof <> d var
R9592:9609 proof <> computeDependences def
R9624:9641 proof <> computeDependences def
R9624:9641 proof <> computeDependences def
R9659:9673 Coq.Lists.List <> in_app_iff thm
R9659:9673 Coq.Lists.List <> in_app_iff thm
R9659:9673 Coq.Lists.List <> in_app_iff thm
R9704:9734 proof <> dependencesFromWriteSetAndWrite def
R9765:9781 proof <> dependenceInRange def
R9807:9822 proof <> commandIxInRange def
R9842:9851 Coq.Lists.List <> in_map_iff thm
R9842:9851 Coq.Lists.List <> in_map_iff thm
R9919:9941 proof <> computeWriteSetInBounds thm
R9919:9941 proof <> computeWriteSetInBounds thm
R9992:10008 proof <> dependenceInRange def
R10020:10036 proof <> dependenceInRange def
R10094:10109 proof <> commandIxInRange def
R10121:10136 proof <> commandIxInRange def
R10155:10160 proof <> comlen def
R10168:10173 proof <> comlen def
R10168:10173 proof <> comlen def
prf 10241:10266 <> getWriteAt'RangeConsistent
R10280:10282 proof <> com ind
R10289:10291 Coq.Init.Datatypes <> nat ind
R10298:10302 proof <> write ind
R10331:10334 Coq.Init.Logic <> :type_scope:x_'->'_x not
R10341:10344 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R10336:10339 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R10335:10335 proof <> i var
R10346:10349 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R10345:10345 proof <> i var
R10350:10355 proof <> comlen def
R10357:10357 proof <> c var
R10321:10324 Coq.Init.Logic <> :type_scope:x_'='_x not
R10306:10316 proof <> getWriteAt' def
R10320:10320 proof <> i var
R10318:10318 proof <> c var
R10325:10328 Coq.Init.Datatypes <> Some constr
R10330:10330 proof <> w var
R10413:10423 proof <> getWriteAt' def
R10438:10448 proof <> getWriteAt' def
R10438:10448 proof <> getWriteAt' def
R10479:10481 Coq.Init.Datatypes <> nat ind
R10490:10493 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10486:10488 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R10485:10485 proof <> x var
R10489:10489 proof <> y var
R10499:10502 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10495:10497 Coq.Init.Logic <> :type_scope:x_'='_x not
R10494:10494 proof <> x var
R10498:10498 proof <> y var
R10504:10506 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R10503:10503 proof <> x var
R10507:10507 proof <> y var
R10479:10481 Coq.Init.Datatypes <> nat ind
R10490:10493 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10486:10488 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R10485:10485 proof <> x var
R10489:10489 proof <> y var
R10499:10502 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10495:10497 Coq.Init.Logic <> :type_scope:x_'='_x not
R10494:10494 proof <> x var
R10498:10498 proof <> y var
R10504:10506 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R10503:10503 proof <> x var
R10507:10507 proof <> y var
R10549:10554 proof <> comlen def
R10567:10572 proof <> comlen def
R10567:10572 proof <> comlen def
R10608:10608 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10617:10620 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10609:10614 proof <> comlen def
R10608:10608 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10617:10620 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10609:10614 proof <> comlen def
R10680:10683 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R10685:10688 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10697:10697 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10689:10694 proof <> comlen def
R10680:10683 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R10685:10688 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10697:10697 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10689:10694 proof <> comlen def
R10717:10727 proof <> getWriteAt' def
R10717:10727 proof <> getWriteAt' def
R10750:10760 Coq.Arith.PeanoNat Nat eqb_neq thm
R10750:10760 Coq.Arith.PeanoNat Nat eqb_neq thm
R10750:10760 Coq.Arith.PeanoNat Nat eqb_neq thm
R10870:10875 proof <> comlen def
R10883:10888 proof <> comlen def
R10883:10888 proof <> comlen def
R10960:10965 proof <> comlen def
R10973:10978 proof <> comlen def
R10973:10978 proof <> comlen def
R11030:11033 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11035:11038 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11047:11047 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11039:11044 proof <> comlen def
R11030:11033 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11035:11038 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11047:11047 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11039:11044 proof <> comlen def
R11077:11087 Coq.Arith.PeanoNat Nat eqb_neq thm
R11077:11087 Coq.Arith.PeanoNat Nat eqb_neq thm
R11077:11087 Coq.Arith.PeanoNat Nat eqb_neq thm
R11254:11264 proof <> getWriteAt' def
prf 11301:11324 <> getWriteAt'RangeComplete
R11338:11340 proof <> com ind
R11347:11349 Coq.Init.Datatypes <> nat ind
R11378:11381 Coq.Init.Logic <> :type_scope:x_'->'_x not
R11382:11389 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R11398:11400 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R11393:11397 proof <> write ind
R11416:11418 Coq.Init.Logic <> :type_scope:x_'='_x not
R11401:11411 proof <> getWriteAt' def
R11415:11415 proof <> i var
R11413:11413 proof <> c var
R11419:11422 Coq.Init.Datatypes <> Some constr
R11424:11424 proof <> w var
R11359:11362 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R11354:11357 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R11353:11353 proof <> i var
R11364:11368 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11377:11377 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11363:11363 proof <> i var
R11369:11374 proof <> comlen def
R11376:11376 proof <> c var
R11480:11490 proof <> getWriteAt' def
R11498:11508 proof <> getWriteAt' def
R11498:11508 proof <> getWriteAt' def
R11523:11528 proof <> comlen def
R11523:11528 proof <> comlen def
R11557:11559 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11549:11551 Coq.Init.Logic <> :type_scope:x_'='_x not
R11553:11555 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11569:11572 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11561:11563 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R11565:11567 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11574:11576 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R11578:11580 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11557:11559 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11549:11551 Coq.Init.Logic <> :type_scope:x_'='_x not
R11553:11555 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11569:11572 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11561:11563 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R11565:11567 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11574:11576 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R11578:11580 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11677:11686 Coq.Arith.PeanoNat Nat eqb_eq thm
R11677:11686 Coq.Arith.PeanoNat Nat eqb_eq thm
R11677:11686 Coq.Arith.PeanoNat Nat eqb_eq thm
R11705:11710 proof <> comlen def
R11718:11723 proof <> comlen def
R11718:11723 proof <> comlen def
R11856:11859 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R11851:11854 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R11861:11864 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11856:11859 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R11851:11854 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R11861:11864 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11928:11931 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11933:11935 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11928:11931 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11933:11935 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11960:11970 Coq.Arith.PeanoNat Nat eqb_neq thm
R11960:11970 Coq.Arith.PeanoNat Nat eqb_neq thm
R11960:11970 Coq.Arith.PeanoNat Nat eqb_neq thm
R11988:11993 proof <> comlen def
R12001:12006 proof <> comlen def
R12001:12006 proof <> comlen def
R12082:12085 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12077:12080 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R12087:12090 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12082:12085 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12077:12080 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R12087:12090 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12102:12107 proof <> comlen def
R12120:12125 proof <> comlen def
R12120:12125 proof <> comlen def
R12184:12187 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12176:12178 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R12180:12182 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12189:12192 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12184:12187 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12176:12178 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R12180:12182 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12189:12192 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12233:12236 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R12238:12240 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12241:12246 proof <> comlen def
R12233:12236 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R12238:12240 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12241:12246 proof <> comlen def
R12272:12282 Coq.Arith.PeanoNat Nat eqb_neq thm
R12272:12282 Coq.Arith.PeanoNat Nat eqb_neq thm
R12272:12282 Coq.Arith.PeanoNat Nat eqb_neq thm
R12300:12305 proof <> comlen def
R12313:12318 proof <> comlen def
R12313:12318 proof <> comlen def
R12414:12419 proof <> comlen def
prf 12464:12480 <> getWriteAt'OnCSeq
R12494:12496 proof <> com ind
R12503:12507 proof <> write ind
R12548:12550 Coq.Init.Logic <> :type_scope:x_'='_x not
R12511:12521 proof <> getWriteAt' def
R12543:12545 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12535:12540 proof <> comlen def
R12542:12542 proof <> c var
R12524:12527 proof <> CSeq constr
R12531:12531 proof <> w var
R12529:12529 proof <> c var
R12551:12554 Coq.Init.Datatypes <> Some constr
R12556:12556 proof <> w var
R12654:12656 Coq.Init.Logic <> :type_scope:x_'='_x not
R12637:12641 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R12633:12635 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12625:12630 proof <> comlen def
R12642:12642 Coq.Init.Datatypes <> S constr
R12645:12650 proof <> comlen def
R12657:12660 Coq.Init.Datatypes <> true constr
R12654:12656 Coq.Init.Logic <> :type_scope:x_'='_x not
R12637:12641 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R12633:12635 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12625:12630 proof <> comlen def
R12642:12642 Coq.Init.Datatypes <> S constr
R12645:12650 proof <> comlen def
R12657:12660 Coq.Init.Datatypes <> true constr
R12674:12683 Coq.Arith.PeanoNat Nat eqb_eq thm
R12674:12683 Coq.Arith.PeanoNat Nat eqb_eq thm
R12674:12683 Coq.Arith.PeanoNat Nat eqb_eq thm
R12702:12707 proof <> comlen def
R12715:12720 proof <> comlen def
R12715:12720 proof <> comlen def
prf 12797:12821 <> getWriteAt'DestructOnCSeq
R12835:12837 proof <> com ind
R12845:12847 Coq.Init.Datatypes <> nat ind
R12854:12858 proof <> write ind
R12889:12892 Coq.Init.Logic <> :type_scope:x_'->'_x not
R12917:12919 Coq.Init.Logic <> :type_scope:x_'='_x not
R12893:12903 proof <> getWriteAt' def
R12916:12916 proof <> i var
R12906:12909 proof <> CSeq constr
R12913:12913 proof <> w var
R12911:12911 proof <> c var
R12920:12930 proof <> getWriteAt' def
R12934:12934 proof <> i var
R12932:12932 proof <> c var
R12879:12882 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12867:12870 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12866:12866 proof <> i var
R12871:12876 proof <> comlen def
R12878:12878 proof <> c var
R12884:12887 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R12883:12883 proof <> i var
R13017:13020 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R13002:13004 Coq.Init.Logic <> :type_scope:x_'='_x not
R13013:13015 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13005:13010 proof <> comlen def
R13022:13024 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R13034:13036 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13025:13030 proof <> comlen def
R13017:13020 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R13002:13004 Coq.Init.Logic <> :type_scope:x_'='_x not
R13013:13015 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13005:13010 proof <> comlen def
R13022:13024 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R13034:13036 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13025:13030 proof <> comlen def
R13050:13055 proof <> comlen def
R13068:13073 proof <> comlen def
R13068:13073 proof <> comlen def
R13127:13143 proof <> getWriteAt'OnCSeq thm
R13127:13143 proof <> getWriteAt'OnCSeq thm
R13127:13143 proof <> getWriteAt'OnCSeq thm
R13197:13199 Coq.Init.Logic <> :type_scope:x_'='_x not
R13177:13180 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13173:13175 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13165:13170 proof <> comlen def
R13181:13181 Coq.Init.Datatypes <> S constr
R13184:13184 Coq.Init.Datatypes <> S constr
R13187:13192 proof <> comlen def
R13200:13204 Coq.Init.Datatypes <> false constr
R13197:13199 Coq.Init.Logic <> :type_scope:x_'='_x not
R13177:13180 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13173:13175 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13165:13170 proof <> comlen def
R13181:13181 Coq.Init.Datatypes <> S constr
R13184:13184 Coq.Init.Datatypes <> S constr
R13187:13192 proof <> comlen def
R13200:13204 Coq.Init.Datatypes <> false constr
R13218:13228 Coq.Arith.PeanoNat Nat eqb_neq thm
R13218:13228 Coq.Arith.PeanoNat Nat eqb_neq thm
R13218:13228 Coq.Arith.PeanoNat Nat eqb_neq thm
R13288:13290 Coq.Init.Logic <> :type_scope:x_'='_x not
R13273:13276 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13270:13271 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13262:13267 proof <> comlen def
R13277:13277 Coq.Init.Datatypes <> S constr
R13279:13284 proof <> comlen def
R13291:13294 Coq.Init.Datatypes <> true constr
R13288:13290 Coq.Init.Logic <> :type_scope:x_'='_x not
R13273:13276 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13270:13271 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13262:13267 proof <> comlen def
R13277:13277 Coq.Init.Datatypes <> S constr
R13279:13284 proof <> comlen def
R13291:13294 Coq.Init.Datatypes <> true constr
R13306:13315 Coq.Arith.PeanoNat Nat eqb_eq thm
R13306:13315 Coq.Arith.PeanoNat Nat eqb_eq thm
R13306:13315 Coq.Arith.PeanoNat Nat eqb_eq thm
R13397:13399 Coq.Init.Logic <> :type_scope:x_'='_x not
R13374:13379 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13396:13396 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13380:13380 Coq.Init.Datatypes <> S constr
R13383:13383 Coq.Init.Datatypes <> S constr
R13386:13391 proof <> comlen def
R13400:13404 Coq.Init.Datatypes <> false constr
R13397:13399 Coq.Init.Logic <> :type_scope:x_'='_x not
R13374:13379 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13396:13396 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13380:13380 Coq.Init.Datatypes <> S constr
R13383:13383 Coq.Init.Datatypes <> S constr
R13386:13391 proof <> comlen def
R13400:13404 Coq.Init.Datatypes <> false constr
R13416:13426 Coq.Arith.PeanoNat Nat eqb_neq thm
R13416:13426 Coq.Arith.PeanoNat Nat eqb_neq thm
R13416:13426 Coq.Arith.PeanoNat Nat eqb_neq thm
R13463:13465 Coq.Init.Logic <> :type_scope:x_'='_x not
R13447:13450 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13451:13451 Coq.Init.Datatypes <> S constr
R13454:13459 proof <> comlen def
R13466:13470 Coq.Init.Datatypes <> false constr
R13463:13465 Coq.Init.Logic <> :type_scope:x_'='_x not
R13447:13450 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13451:13451 Coq.Init.Datatypes <> S constr
R13454:13459 proof <> comlen def
R13466:13470 Coq.Init.Datatypes <> false constr
R13482:13492 Coq.Arith.PeanoNat Nat eqb_neq thm
R13482:13492 Coq.Arith.PeanoNat Nat eqb_neq thm
R13482:13492 Coq.Arith.PeanoNat Nat eqb_neq thm
R13571:13576 proof <> comlen def
R13589:13594 proof <> comlen def
R13589:13594 proof <> comlen def
prf 13623:13642 <> computeWriteSetRange
R13656:13658 proof <> com ind
R13667:13671 proof <> memix syndef
R13678:13680 Coq.Init.Datatypes <> nat ind
R13722:13725 Coq.Init.Logic <> :type_scope:x_'->'_x not
R13732:13735 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R13727:13730 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R13726:13726 proof <> i var
R13737:13740 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R13736:13736 proof <> i var
R13741:13746 proof <> comlen def
R13748:13748 proof <> c var
R13684:13690 Coq.Lists.List <> In def
R13697:13711 proof <> computeWriteSet def
R13714:13714 proof <> c var
R13718:13720 proof <> wix var
R13692:13692 proof <> i var
R13797:13811 proof <> computeWriteSet def
R13826:13840 proof <> computeWriteSet def
R13826:13840 proof <> computeWriteSet def
R13857:13870 proof <> mergeWriteSets def
R13888:13902 Coq.Lists.List <> in_app_iff thm
R13888:13902 Coq.Lists.List <> in_app_iff thm
R13888:13902 Coq.Lists.List <> in_app_iff thm
R14020:14025 proof <> comlen def
R14033:14038 proof <> comlen def
R14033:14038 proof <> comlen def
R14059:14073 proof <> writeToWriteset def
R14168:14184 proof <> singletonWriteSet def
R14201:14213 proof <> addToWriteSet def
R14238:14241 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R14234:14236 Coq.Init.Logic <> :type_scope:x_'='_x not
R14245:14248 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R14238:14241 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R14234:14236 Coq.Init.Logic <> :type_scope:x_'='_x not
R14245:14248 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R14306:14315 Coq.Arith.PeanoNat Nat eqb_eq thm
R14306:14315 Coq.Arith.PeanoNat Nat eqb_eq thm
R14306:14315 Coq.Arith.PeanoNat Nat eqb_eq thm
R14366:14371 proof <> comlen def
R14379:14384 proof <> comlen def
R14379:14384 proof <> comlen def
R14396:14401 proof <> comlen def
R14414:14419 proof <> comlen def
R14414:14419 proof <> comlen def
R14480:14490 Coq.Arith.PeanoNat Nat eqb_neq thm
R14480:14490 Coq.Arith.PeanoNat Nat eqb_neq thm
R14480:14490 Coq.Arith.PeanoNat Nat eqb_neq thm
prf 14633:14659 <> computeWriteSetCharacterBwd
R14675:14677 proof <> com ind
R14686:14690 proof <> memix syndef
R14700:14707 proof <> memvalue syndef
R14714:14716 Coq.Init.Datatypes <> nat ind
R14764:14767 Coq.Init.Logic <> :type_scope:x_'->'_x not
R14768:14774 Coq.Lists.List <> In def
R14780:14794 proof <> computeWriteSet def
R14796:14796 proof <> c var
R14799:14801 proof <> wix var
R14776:14776 proof <> i var
R14739:14742 Coq.Init.Logic <> :type_scope:x_'='_x not
R14724:14734 proof <> getWriteAt' def
R14738:14738 proof <> i var
R14736:14736 proof <> c var
R14743:14746 Coq.Init.Datatypes <> Some constr
R14749:14753 proof <> Write constr
R14759:14762 proof <> wval var
R14755:14757 proof <> wix var
R14949:14963 proof <> computeWriteSet def
R14973:14987 proof <> computeWriteSet def
R14973:14987 proof <> computeWriteSet def
R14999:15012 proof <> mergeWriteSets def
R15025:15039 Coq.Lists.List <> in_app_iff thm
R15025:15039 Coq.Lists.List <> in_app_iff thm
R15025:15039 Coq.Lists.List <> in_app_iff thm
R15115:15140 proof <> getWriteAt'RangeConsistent thm
R15115:15140 proof <> getWriteAt'RangeConsistent thm
R15157:15162 proof <> comlen def
R15175:15180 proof <> comlen def
R15175:15180 proof <> comlen def
R15214:15217 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R15199:15201 Coq.Init.Logic <> :type_scope:x_'='_x not
R15210:15212 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15202:15207 proof <> comlen def
R15219:15221 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R15230:15232 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15222:15227 proof <> comlen def
R15214:15217 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R15199:15201 Coq.Init.Logic <> :type_scope:x_'='_x not
R15210:15212 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15202:15207 proof <> comlen def
R15219:15221 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R15230:15232 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15222:15227 proof <> comlen def
R15333:15347 proof <> writeToWriteset def
R15373:15389 proof <> singletonWriteSet def
R15401:15413 proof <> addToWriteSet def
R15473:15474 Coq.Init.Logic <> :type_scope:x_'='_x not
R15458:15461 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15462:15462 Coq.Init.Datatypes <> S constr
R15464:15469 proof <> comlen def
R15475:15478 Coq.Init.Datatypes <> true constr
R15473:15474 Coq.Init.Logic <> :type_scope:x_'='_x not
R15458:15461 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15462:15462 Coq.Init.Datatypes <> S constr
R15464:15469 proof <> comlen def
R15475:15478 Coq.Init.Datatypes <> true constr
R15490:15499 Coq.Arith.PeanoNat Nat eqb_eq thm
R15490:15499 Coq.Arith.PeanoNat Nat eqb_eq thm
R15490:15499 Coq.Arith.PeanoNat Nat eqb_eq thm
R15578:15580 Coq.Init.Logic <> :type_scope:x_'='_x not
R15571:15574 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15581:15584 Coq.Init.Datatypes <> true constr
R15578:15580 Coq.Init.Logic <> :type_scope:x_'='_x not
R15571:15574 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15581:15584 Coq.Init.Datatypes <> true constr
R15595:15606 Coq.Arith.PeanoNat Nat eqb_refl thm
R15595:15606 Coq.Arith.PeanoNat Nat eqb_refl thm
R15638:15647 Coq.Arith.PeanoNat Nat eqb_eq thm
R15638:15647 Coq.Arith.PeanoNat Nat eqb_eq thm
R15638:15647 Coq.Arith.PeanoNat Nat eqb_eq thm
R15735:15738 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R15730:15733 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R15740:15743 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R15744:15749 proof <> comlen def
R15735:15738 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R15730:15733 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R15740:15743 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R15744:15749 proof <> comlen def
R15785:15792 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15801:15803 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15796:15800 proof <> write ind
R15820:15822 Coq.Init.Logic <> :type_scope:x_'='_x not
R15804:15814 proof <> getWriteAt' def
R15823:15826 Coq.Init.Datatypes <> Some constr
R15828:15828 proof <> w var
R15785:15792 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15801:15803 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15796:15800 proof <> write ind
R15820:15822 Coq.Init.Logic <> :type_scope:x_'='_x not
R15804:15814 proof <> getWriteAt' def
R15823:15826 Coq.Init.Datatypes <> Some constr
R15828:15828 proof <> w var
R15859:15882 proof <> getWriteAt'RangeComplete thm
R15859:15882 proof <> getWriteAt'RangeComplete thm
R16022:16025 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R16026:16026 Coq.Init.Datatypes <> S constr
R16029:16034 proof <> comlen def
R16022:16025 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R16026:16026 Coq.Init.Datatypes <> S constr
R16029:16034 proof <> comlen def
R16064:16074 Coq.Arith.PeanoNat Nat eqb_neq thm
R16064:16074 Coq.Arith.PeanoNat Nat eqb_neq thm
R16064:16074 Coq.Arith.PeanoNat Nat eqb_neq thm
prf 16251:16275 <> destructInWriteToWriteSet
R16291:16295 proof <> write ind
R16302:16304 Coq.Init.Datatypes <> nat ind
R16316:16324 proof <> timepoint syndef
R16335:16339 proof <> memix syndef
R16388:16391 Coq.Init.Logic <> :type_scope:x_'->'_x not
R16397:16399 Coq.Init.Logic <> :type_scope:x_'='_x not
R16392:16396 proof <> curtp var
R16400:16400 proof <> n var
R16347:16353 Coq.Lists.List <> In def
R16362:16376 proof <> writeToWriteset def
R16382:16386 proof <> curix var
R16380:16380 proof <> n var
R16378:16378 proof <> w var
R16355:16359 proof <> curtp var
R16429:16443 proof <> writeToWriteset def
R16473:16499 proof <> destructInSingletonWriteSet thm
R16473:16499 proof <> destructInSingletonWriteSet thm
prf 16598:16624 <> computeWriteSetCharacterFwd
R16640:16642 proof <> com ind
R16651:16655 proof <> memix syndef
R16662:16664 Coq.Init.Datatypes <> nat ind
R16704:16707 Coq.Init.Logic <> :type_scope:x_'->'_x not
R16708:16715 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R16730:16732 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R16722:16729 proof <> memvalue syndef
R16749:16751 Coq.Init.Logic <> :type_scope:x_'='_x not
R16733:16743 proof <> getWriteAt' def
R16748:16748 proof <> i var
R16746:16746 proof <> c var
R16752:16755 Coq.Init.Datatypes <> Some constr
R16758:16762 proof <> Write constr
R16768:16771 proof <> wval var
R16764:16766 proof <> wix var
R16668:16674 Coq.Lists.List <> In def
R16680:16694 proof <> computeWriteSet def
R16697:16697 proof <> c var
R16700:16702 proof <> wix var
R16676:16676 proof <> i var
R16860:16863 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R16855:16858 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R16865:16868 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R16869:16869 Coq.Init.Datatypes <> S constr
R16872:16877 proof <> comlen def
R16860:16863 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R16855:16858 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R16865:16868 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R16869:16869 Coq.Init.Datatypes <> S constr
R16872:16877 proof <> comlen def
R16892:16914 proof <> computeWriteSetInBounds thm
R16892:16914 proof <> computeWriteSetInBounds thm
R16932:16937 proof <> comlen def
R16951:16956 proof <> comlen def
R16951:16956 proof <> comlen def
R16983:16997 proof <> computeWriteSet def
R17011:17025 proof <> computeWriteSet def
R17011:17025 proof <> computeWriteSet def
R17041:17054 proof <> mergeWriteSets def
R17074:17088 Coq.Lists.List <> in_app_iff thm
R17074:17088 Coq.Lists.List <> in_app_iff thm
R17074:17088 Coq.Lists.List <> in_app_iff thm
R17154:17157 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R17158:17163 proof <> comlen def
R17154:17157 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R17158:17163 proof <> comlen def
R17179:17201 proof <> computeWriteSetInBounds thm
R17179:17201 proof <> computeWriteSetInBounds thm
R17306:17330 proof <> getWriteAt'DestructOnCSeq thm
R17306:17330 proof <> getWriteAt'DestructOnCSeq thm
R17306:17330 proof <> getWriteAt'DestructOnCSeq thm
R17306:17330 proof <> getWriteAt'DestructOnCSeq thm
R17412:17414 Coq.Init.Logic <> :type_scope:x_'='_x not
R17423:17424 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R17415:17420 proof <> comlen def
R17412:17414 Coq.Init.Logic <> :type_scope:x_'='_x not
R17423:17424 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R17415:17420 proof <> comlen def
R17435:17459 proof <> destructInWriteToWriteSet thm
R17435:17459 proof <> destructInWriteToWriteSet thm
R17479:17484 proof <> comlen def
R17498:17503 proof <> comlen def
R17498:17503 proof <> comlen def
R17523:17528 proof <> comlen def
R17542:17547 proof <> comlen def
R17542:17547 proof <> comlen def
R17607:17632 proof <> destructInWriteToWriteSet' thm
R17607:17632 proof <> destructInWriteToWriteSet' thm
R17700:17716 proof <> getWriteAt'OnCSeq thm
R17700:17716 proof <> getWriteAt'OnCSeq thm
prf 18024:18054 <> destructDependenceAliasesInCSeq
R18068:18070 proof <> com ind
R18087:18095 proof <> timepoint syndef
R18105:18109 proof <> memix syndef
R18119:18126 proof <> memvalue syndef
R18170:18177 Coq.Init.Logic <> :type_scope:x_'->'_x not
R18237:18244 Coq.Init.Logic <> :type_scope:x_'->'_x not
R18305:18313 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R18245:18262 proof <> dependenceAliases' def
R18280:18283 proof <> CSeq constr
R18289:18293 proof <> Write constr
R18299:18302 proof <> wval var
R18295:18297 proof <> wix var
R18286:18286 proof <> c var
R18264:18264 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18271:18272 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18277:18277 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18265:18270 proof <> tbegin var
R18273:18276 proof <> tend var
R18314:18314 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18422:18431 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18492:18492 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18334:18337 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18319:18321 Coq.Init.Logic <> :type_scope:x_'='_x not
R18315:18318 proof <> tend var
R18330:18332 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18322:18327 proof <> comlen def
R18329:18329 proof <> c var
R18338:18345 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R18366:18368 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R18358:18365 proof <> memvalue syndef
R18369:18369 Coq.Init.Logic <> :type_scope:x_'='_x not
R18391:18394 Coq.Init.Logic <> :type_scope:x_'='_x not
R18370:18380 proof <> getWriteAt' def
R18385:18390 proof <> tbegin var
R18383:18383 proof <> c var
R18395:18398 Coq.Init.Datatypes <> Some constr
R18401:18405 proof <> Write constr
R18411:18420 proof <> wval_begin var
R18407:18409 proof <> wix var
R18452:18455 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18436:18439 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R18432:18435 proof <> tend var
R18448:18450 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18440:18445 proof <> comlen def
R18447:18447 proof <> c var
R18456:18473 proof <> dependenceAliases' def
R18491:18491 proof <> c var
R18475:18475 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18482:18483 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18488:18488 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18476:18481 proof <> tbegin var
R18484:18487 proof <> tend var
R18178:18194 proof <> dependenceInRange def
R18212:18215 proof <> CSeq constr
R18221:18225 proof <> Write constr
R18231:18234 proof <> wval var
R18227:18229 proof <> wix var
R18218:18218 proof <> c var
R18196:18196 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18203:18204 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18209:18209 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18197:18202 proof <> tbegin var
R18205:18208 proof <> tend var
R18134:18154 proof <> dependenceLexPositive def
R18156:18156 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18163:18164 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18169:18169 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18157:18162 proof <> tbegin var
R18165:18168 proof <> tend var
R18547:18547 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18567:18572 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18605:18605 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18552:18554 Coq.Init.Logic <> :type_scope:x_'='_x not
R18563:18565 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18555:18560 proof <> comlen def
R18592:18595 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18577:18579 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R18588:18590 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18580:18585 proof <> comlen def
R18600:18603 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R18547:18547 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18567:18572 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18605:18605 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18552:18554 Coq.Init.Logic <> :type_scope:x_'='_x not
R18563:18565 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18555:18560 proof <> comlen def
R18592:18595 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18577:18579 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R18588:18590 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18580:18585 proof <> comlen def
R18600:18603 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R18618:18634 proof <> dependenceInRange def
R18652:18667 proof <> commandIxInRange def
R18753:18770 proof <> dependenceAliases' def
R18841:18843 Coq.Init.Logic <> :type_scope:x_'='_x not
R18825:18828 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18821:18823 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18813:18818 proof <> comlen def
R18829:18829 Coq.Init.Datatypes <> S constr
R18832:18837 proof <> comlen def
R18844:18847 Coq.Init.Datatypes <> true constr
R18841:18843 Coq.Init.Logic <> :type_scope:x_'='_x not
R18825:18828 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18821:18823 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18813:18818 proof <> comlen def
R18829:18829 Coq.Init.Datatypes <> S constr
R18832:18837 proof <> comlen def
R18844:18847 Coq.Init.Datatypes <> true constr
R18859:18868 Coq.Arith.PeanoNat Nat eqb_eq thm
R18859:18868 Coq.Arith.PeanoNat Nat eqb_eq thm
R18859:18868 Coq.Arith.PeanoNat Nat eqb_eq thm
R18937:18939 Coq.Init.Logic <> :type_scope:x_'='_x not
R18921:18924 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18925:18925 Coq.Init.Datatypes <> S constr
R18928:18933 proof <> comlen def
R18940:18944 Coq.Init.Datatypes <> false constr
R18937:18939 Coq.Init.Logic <> :type_scope:x_'='_x not
R18921:18924 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18925:18925 Coq.Init.Datatypes <> S constr
R18928:18933 proof <> comlen def
R18940:18944 Coq.Init.Datatypes <> false constr
R18957:18977 proof <> dependenceLexPositive def
R19009:19019 Coq.Arith.PeanoNat Nat eqb_neq thm
R19009:19019 Coq.Arith.PeanoNat Nat eqb_neq thm
R19009:19019 Coq.Arith.PeanoNat Nat eqb_neq thm
R19093:19103 proof <> getWriteAt' def
R19093:19103 proof <> getWriteAt' def
R19144:19151 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19160:19162 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19155:19159 proof <> write ind
R19183:19185 Coq.Init.Logic <> :type_scope:x_'='_x not
R19163:19173 proof <> getWriteAt' def
R19186:19189 Coq.Init.Datatypes <> Some constr
R19191:19191 proof <> w var
R19144:19151 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19160:19162 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19155:19159 proof <> write ind
R19183:19185 Coq.Init.Logic <> :type_scope:x_'='_x not
R19163:19173 proof <> getWriteAt' def
R19186:19189 Coq.Init.Datatypes <> Some constr
R19191:19191 proof <> w var
R19203:19226 proof <> getWriteAt'RangeComplete thm
R19203:19226 proof <> getWriteAt'RangeComplete thm
R19238:19254 proof <> dependenceInRange def
R19270:19285 proof <> commandIxInRange def
R19316:19336 proof <> dependenceLexPositive def
R19446:19452 proof <> writeIx def
R19516:19518 Coq.Init.Logic <> :type_scope:x_'='_x not
R19516:19518 Coq.Init.Logic <> :type_scope:x_'='_x not
R19621:19638 proof <> dependenceAliases' def
R19716:19719 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R19701:19703 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R19712:19714 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R19704:19709 proof <> comlen def
R19726:19729 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R19716:19719 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R19701:19703 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R19712:19714 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R19704:19709 proof <> comlen def
R19726:19729 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R19743:19763 proof <> dependenceLexPositive def
R19792:19808 proof <> dependenceInRange def
R19826:19841 proof <> commandIxInRange def
R19882:19906 proof <> getWriteAt'DestructOnCSeq thm
R19882:19906 proof <> getWriteAt'DestructOnCSeq thm
R19882:19906 proof <> getWriteAt'DestructOnCSeq thm
R19882:19906 proof <> getWriteAt'DestructOnCSeq thm
R19925:19949 proof <> getWriteAt'DestructOnCSeq thm
R19925:19949 proof <> getWriteAt'DestructOnCSeq thm
R19925:19949 proof <> getWriteAt'DestructOnCSeq thm
R19925:19949 proof <> getWriteAt'DestructOnCSeq thm
R19967:19984 proof <> dependenceAliases' def
R20010:20013 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R20022:20024 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20014:20019 proof <> comlen def
R20010:20013 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R20022:20024 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20014:20019 proof <> comlen def
R20143:20160 proof <> dependenceAliases' def
R20209:20225 proof <> getWriteAt'OnCSeq thm
R20209:20225 proof <> getWriteAt'OnCSeq thm
R20209:20225 proof <> getWriteAt'OnCSeq thm
R20259:20262 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R20244:20246 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R20255:20257 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20247:20252 proof <> comlen def
R20269:20272 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R20259:20262 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R20244:20246 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R20255:20257 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20247:20252 proof <> comlen def
R20269:20272 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R20286:20306 proof <> dependenceLexPositive def
R20321:20337 proof <> dependenceInRange def
R20353:20368 proof <> commandIxInRange def
R20466:20468 Coq.Init.Logic <> :type_scope:x_'='_x not
R20421:20431 proof <> getWriteAt' def
R20435:20438 proof <> CSeq constr
R20443:20447 proof <> Write constr
R20469:20479 proof <> getWriteAt' def
R20466:20468 Coq.Init.Logic <> :type_scope:x_'='_x not
R20421:20431 proof <> getWriteAt' def
R20435:20438 proof <> CSeq constr
R20443:20447 proof <> Write constr
R20469:20479 proof <> getWriteAt' def
R20500:20524 proof <> getWriteAt'DestructOnCSeq thm
R20500:20524 proof <> getWriteAt'DestructOnCSeq thm
R20815:20832 proof <> dependenceAliases' def
R20845:20869 proof <> getWriteAt'DestructOnCSeq thm
R20845:20869 proof <> getWriteAt'DestructOnCSeq thm
R20845:20869 proof <> getWriteAt'DestructOnCSeq thm
R20845:20869 proof <> getWriteAt'DestructOnCSeq thm
R20882:20906 proof <> getWriteAt'DestructOnCSeq thm
R20882:20906 proof <> getWriteAt'DestructOnCSeq thm
R20882:20906 proof <> getWriteAt'DestructOnCSeq thm
R20882:20906 proof <> getWriteAt'DestructOnCSeq thm
R20918:20935 proof <> dependenceAliases' def
R20974:20990 proof <> dependenceInRange def
R21006:21021 proof <> commandIxInRange def
R21070:21086 proof <> dependenceInRange def
R21102:21117 proof <> commandIxInRange def
R21148:21168 proof <> dependenceLexPositive def
prf 21209:21234 <> dependenceInRangeInclusive
R21248:21257 proof <> dependence def
R21264:21266 proof <> com ind
R21273:21277 proof <> write ind
R21303:21306 Coq.Init.Logic <> :type_scope:x_'->'_x not
R21307:21323 proof <> dependenceInRange def
R21329:21332 proof <> CSeq constr
R21336:21336 proof <> w var
R21334:21334 proof <> c var
R21325:21325 proof <> d var
R21282:21298 proof <> dependenceInRange def
R21302:21302 proof <> c var
R21300:21300 proof <> d var
R21349:21365 proof <> dependenceInRange def
R21375:21390 proof <> commandIxInRange def
prf 21448:21474 <> computeDependencesAlias'Fwd
R21488:21490 proof <> com ind
R21506:21515 proof <> dependence def
R21551:21555 Coq.Init.Logic <> :type_scope:x_'->'_x not
R21556:21573 proof <> dependenceAliases' def
R21578:21578 proof <> c var
R21575:21575 proof <> d var
R21519:21525 Coq.Lists.List <> In def
R21530:21547 proof <> computeDependences def
R21549:21549 proof <> c var
R21527:21527 proof <> d var
R21635:21652 proof <> computeDependences def
R21667:21684 proof <> computeDependences def
R21667:21684 proof <> computeDependences def
R21701:21731 proof <> dependencesFromWriteSetAndWrite def
R21773:21787 Coq.Lists.List <> in_app_iff thm
R21773:21787 Coq.Lists.List <> in_app_iff thm
R21773:21787 Coq.Lists.List <> in_app_iff thm
R21817:21831 Coq.Lists.List <> in_map_iff thm
R21817:21831 Coq.Lists.List <> in_map_iff thm
R21848:21853 proof <> comlen def
R21866:21871 proof <> comlen def
R21866:21871 proof <> comlen def
R21973:21990 proof <> dependenceAliases' def
R22017:22020 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R22012:22015 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R22023:22026 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R22027:22032 proof <> comlen def
R22017:22020 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R22012:22015 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R22023:22026 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R22027:22032 proof <> comlen def
R22046:22068 proof <> computeWriteSetInBounds thm
R22046:22068 proof <> computeWriteSetInBounds thm
R22114:22116 Coq.Init.Logic <> :type_scope:x_'='_x not
R22098:22101 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22102:22102 Coq.Init.Datatypes <> S constr
R22105:22110 proof <> comlen def
R22117:22121 Coq.Init.Datatypes <> false constr
R22114:22116 Coq.Init.Logic <> :type_scope:x_'='_x not
R22098:22101 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22102:22102 Coq.Init.Datatypes <> S constr
R22105:22110 proof <> comlen def
R22117:22121 Coq.Init.Datatypes <> false constr
R22135:22145 Coq.Arith.PeanoNat Nat eqb_neq thm
R22135:22145 Coq.Arith.PeanoNat Nat eqb_neq thm
R22135:22145 Coq.Arith.PeanoNat Nat eqb_neq thm
R22187:22189 Coq.Init.Logic <> :type_scope:x_'='_x not
R22175:22178 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22167:22172 proof <> comlen def
R22179:22184 proof <> comlen def
R22190:22193 Coq.Init.Datatypes <> true constr
R22187:22189 Coq.Init.Logic <> :type_scope:x_'='_x not
R22175:22178 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22167:22172 proof <> comlen def
R22179:22184 proof <> comlen def
R22190:22193 Coq.Init.Datatypes <> true constr
R22207:22216 Coq.Arith.PeanoNat Nat eqb_eq thm
R22207:22216 Coq.Arith.PeanoNat Nat eqb_eq thm
R22207:22216 Coq.Arith.PeanoNat Nat eqb_eq thm
R22269:22295 proof <> computeWriteSetCharacterFwd thm
R22269:22295 proof <> computeWriteSetCharacterFwd thm
R22424:22454 proof <> destructDependenceAliasesInCSeq thm
R22424:22454 proof <> destructDependenceAliasesInCSeq thm
R22467:22495 proof <> computeDependencesLexPositive thm
R22467:22495 proof <> computeDependencesLexPositive thm
R22522:22546 proof <> computeDependencesInRange thm
R22522:22546 proof <> computeDependencesInRange thm
R22564:22589 proof <> dependenceInRangeInclusive thm
R22564:22589 proof <> dependenceInRangeInclusive thm
R22630:22633 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R22615:22617 Coq.Init.Logic <> :type_scope:x_'='_x not
R22626:22628 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22618:22623 proof <> comlen def
R22636:22639 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R22648:22649 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22640:22645 proof <> comlen def
R22630:22633 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R22615:22617 Coq.Init.Logic <> :type_scope:x_'='_x not
R22626:22628 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22618:22623 proof <> comlen def
R22636:22639 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R22648:22649 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22640:22645 proof <> comlen def
R22717:22741 proof <> computeDependencesInRange thm
R22717:22741 proof <> computeDependencesInRange thm
R22762:22778 proof <> dependenceInRange def
R22799:22814 proof <> commandIxInRange def
prf 23087:23117 <> dependenceInRangeDestructOnCSeq
R23131:23140 proof <> dependence def
R23147:23149 proof <> com ind
R23156:23160 proof <> write ind
R23194:23197 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23219:23222 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23246:23249 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23250:23266 proof <> dependenceInRange def
R23270:23270 proof <> c var
R23268:23268 proof <> d var
R23223:23243 proof <> dependenceLexPositive def
R23245:23245 proof <> d var
R23203:23206 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R23198:23200 Coq.Init.Datatypes <> snd def
R23202:23202 proof <> d var
R23215:23217 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R23207:23212 proof <> comlen def
R23214:23214 proof <> c var
R23164:23180 proof <> dependenceInRange def
R23185:23188 proof <> CSeq constr
R23192:23192 proof <> w var
R23190:23190 proof <> c var
R23182:23182 proof <> d var
R23289:23305 proof <> dependenceInRange def
R23317:23332 proof <> commandIxInRange def
R23344:23364 proof <> dependenceLexPositive def
prf 23422:23447 <> computeDependenceAlias'Bwd
R23463:23465 proof <> com ind
R23480:23489 proof <> dependence def
R23515:23518 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23540:23543 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23567:23571 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23572:23578 Coq.Lists.List <> In def
R23583:23600 proof <> computeDependences def
R23602:23602 proof <> c var
R23580:23580 proof <> d var
R23544:23564 proof <> dependenceLexPositive def
R23566:23566 proof <> d var
R23519:23535 proof <> dependenceInRange def
R23539:23539 proof <> c var
R23537:23537 proof <> d var
R23493:23510 proof <> dependenceAliases' def
R23514:23514 proof <> c var
R23512:23512 proof <> d var
R23756:23786 proof <> destructDependenceAliasesInCSeq thm
R23756:23786 proof <> destructDependenceAliasesInCSeq thm
R23894:23911 proof <> computeDependences def
R23919:23936 proof <> computeDependences def
R23919:23936 proof <> computeDependences def
R23950:23980 proof <> dependencesFromWriteSetAndWrite def
R23995:24009 Coq.Lists.List <> in_app_iff thm
R23995:24009 Coq.Lists.List <> in_app_iff thm
R23995:24009 Coq.Lists.List <> in_app_iff thm
R24081:24095 Coq.Lists.List <> in_map_iff thm
R24081:24095 Coq.Lists.List <> in_map_iff thm
R24081:24095 Coq.Lists.List <> in_map_iff thm
R24134:24139 proof <> comlen def
R24147:24152 proof <> comlen def
R24147:24152 proof <> comlen def
R24178:24189 Coq.Arith.PeanoNat Nat add_comm thm
R24178:24189 Coq.Arith.PeanoNat Nat add_comm thm
R24178:24189 Coq.Arith.PeanoNat Nat add_comm thm
R24216:24242 proof <> computeWriteSetCharacterBwd thm
R24216:24242 proof <> computeWriteSetCharacterBwd thm
R24330:24347 proof <> computeDependences def
R24359:24376 proof <> computeDependences def
R24359:24376 proof <> computeDependences def
R24390:24420 proof <> dependencesFromWriteSetAndWrite def
R24435:24449 Coq.Lists.List <> in_app_iff thm
R24435:24449 Coq.Lists.List <> in_app_iff thm
R24435:24449 Coq.Lists.List <> in_app_iff thm
R24531:24547 proof <> dependenceInRange def
R24549:24549 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24551:24552 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24555:24555 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24531:24547 proof <> dependenceInRange def
R24549:24549 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24551:24552 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24555:24555 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24571:24601 proof <> dependenceInRangeDestructOnCSeq thm
R24571:24601 proof <> dependenceInRangeDestructOnCSeq thm
R24791:24807 proof <> dependenceInRange def
R24827:24842 proof <> commandIxInRange def
def 24899:24908 <> runProgram
R24915:24917 proof <> com ind
R24933:24938 proof <> memory def
R24943:24948 proof <> memory def
R24961:24961 proof <> p var
R24972:24977 proof <> CBegin constr
R24982:24991 proof <> initmemory var
R24997:25000 proof <> CSeq constr
R25010:25023 proof <> writeToMemory' def
R25029:25038 proof <> runProgram def
R25043:25052 proof <> initmemory var
def 25112:25114 <> ceq
R25124:25126 proof <> com ind
R25162:25167 proof <> memory def
R25171:25171 Coq.Init.Logic <> :type_scope:x_'='_x not
R25195:25199 Coq.Init.Logic <> :type_scope:x_'='_x not
R25224:25224 Coq.Init.Logic <> :type_scope:x_'='_x not
R25172:25181 proof <> runProgram def
R25185:25194 proof <> initmemory var
R25183:25183 proof <> c var
R25200:25209 proof <> runProgram def
R25214:25223 proof <> initmemory var
R25211:25212 proof <> c' var
R25253:25255 proof <> ceq def
not 25237:25237 <> ::x_'==='_x
prf 25286:25293 <> ceq_refl
R25307:25309 proof <> com ind
R25314:25318 proof <> ::x_'==='_x not
R25313:25313 proof <> c var
R25319:25319 proof <> c var
R25348:25350 proof <> ceq def
prf 25390:25402 <> ceq_symmetric
R25418:25420 proof <> com ind
R25432:25436 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R25425:25429 proof <> ::x_'==='_x not
R25424:25424 proof <> c var
R25430:25431 proof <> c' var
R25439:25443 proof <> ::x_'==='_x not
R25437:25438 proof <> c' var
R25444:25444 proof <> c var
R25473:25475 proof <> ceq def
def 25536:25545 <> com_append
R25554:25556 proof <> com ind
R25561:25563 proof <> com ind
R25576:25577 proof <> c' var
R25588:25593 proof <> CBegin constr
R25598:25598 proof <> c var
R25604:25607 proof <> CSeq constr
R25617:25620 proof <> CSeq constr
R25624:25633 proof <> com_append def
R25638:25639 proof <> c' var
R25636:25636 proof <> c var
R25679:25688 proof <> com_append def
not 25662:25662 <> ::x_'+++'_x
prf 25719:25730 <> ceq_add_cseq
R25750:25752 proof <> com ind
R25759:25763 proof <> write ind
R25777:25780 Coq.Init.Logic <> :type_scope:x_'->'_x not
R25781:25781 proof <> ::x_'==='_x not
R25791:25798 proof <> ::x_'==='_x not
R25809:25809 proof <> ::x_'==='_x not
R25782:25785 proof <> CSeq constr
R25790:25790 proof <> w var
R25787:25788 proof <> cn var
R25799:25802 proof <> CSeq constr
R25808:25808 proof <> w var
R25804:25806 proof <> cn' var
R25769:25773 proof <> ::x_'==='_x not
R25767:25768 proof <> cn var
R25774:25776 proof <> cn' var
R25838:25840 proof <> ceq def
R25852:25861 proof <> runProgram def
R25871:25880 proof <> runProgram def
R25871:25880 proof <> runProgram def
R25902:25904 proof <> ceq def
prf 25983:26010 <> runprogram_distribute_append
R26029:26031 proof <> com ind
R26052:26057 proof <> memory def
R26092:26094 Coq.Init.Logic <> :type_scope:x_'='_x not
R26061:26070 proof <> runProgram def
R26085:26091 proof <> initmem var
R26075:26079 proof <> ::x_'+++'_x not
R26073:26074 proof <> cn var
R26080:26082 proof <> cn' var
R26095:26104 proof <> runProgram def
R26111:26120 proof <> runProgram def
R26125:26131 proof <> initmem var
R26122:26123 proof <> cn var
R26106:26108 proof <> cn' var
R26211:26220 proof <> com_append def
R26228:26237 proof <> com_append def
R26228:26237 proof <> com_append def
R26249:26258 proof <> runProgram def
R26266:26275 proof <> runProgram def
R26266:26275 proof <> runProgram def
R26325:26334 proof <> com_append def
R26346:26355 proof <> runProgram def
R26363:26372 proof <> runProgram def
R26363:26372 proof <> runProgram def
prf 26521:26535 <> ceq_append_weak
R26556:26558 proof <> com ind
R26571:26573 Coq.Init.Logic <> :type_scope:x_'->'_x not
R26582:26586 proof <> ::x_'==='_x not
R26576:26580 proof <> ::x_'+++'_x not
R26574:26575 proof <> cl var
R26581:26581 proof <> c var
R26589:26593 proof <> ::x_'+++'_x not
R26587:26588 proof <> cr var
R26594:26594 proof <> c var
R26564:26568 proof <> ::x_'==='_x not
R26562:26563 proof <> cl var
R26569:26570 proof <> cr var
R26649:26658 proof <> com_append def
R26666:26675 proof <> com_append def
R26666:26675 proof <> com_append def
R26686:26697 proof <> ceq_add_cseq thm
R26686:26697 proof <> ceq_add_cseq thm
R26741:26750 proof <> com_append def
prf 26776:26792 <> ceq_append_strong
R26818:26820 proof <> com ind
R26833:26836 Coq.Init.Logic <> :type_scope:x_'->'_x not
R26848:26851 Coq.Init.Logic <> :type_scope:x_'->'_x not
R26862:26866 proof <> ::x_'==='_x not
R26854:26858 proof <> ::x_'+++'_x not
R26852:26853 proof <> cl var
R26859:26861 proof <> cl' var
R26869:26873 proof <> ::x_'+++'_x not
R26867:26868 proof <> cr var
R26874:26876 proof <> cr' var
R26840:26844 proof <> ::x_'==='_x not
R26837:26839 proof <> cl' var
R26845:26847 proof <> cr' var
R26826:26830 proof <> ::x_'==='_x not
R26824:26825 proof <> cl var
R26831:26832 proof <> cr var
R26898:26900 proof <> ceq def
R26917:26919 proof <> ceq def
R26937:26939 proof <> ceq def
R26962:26989 proof <> runprogram_distribute_append thm
R26962:26989 proof <> runprogram_distribute_append thm
R26962:26989 proof <> runprogram_distribute_append thm
R27002:27029 proof <> runprogram_distribute_append thm
R27002:27029 proof <> runprogram_distribute_append thm
R27002:27029 proof <> runprogram_distribute_append thm
prf 27088:27106 <> ceq_switch_no_alias
R27128:27132 proof <> memix syndef
R27149:27156 proof <> memvalue syndef
R27176:27183 Coq.Init.Logic <> :type_scope:x_'->'_x not
R27240:27253 proof <> ::x_'==='_x not
R27184:27187 proof <> CSeq constr
R27223:27227 proof <> Write constr
R27234:27238 proof <> wval2 var
R27229:27232 proof <> wix2 var
R27190:27193 proof <> CSeq constr
R27203:27207 proof <> Write constr
R27214:27218 proof <> wval1 var
R27209:27212 proof <> wix1 var
R27195:27200 proof <> CBegin constr
R27254:27257 proof <> CSeq constr
R27293:27297 proof <> Write constr
R27304:27308 proof <> wval1 var
R27299:27302 proof <> wix1 var
R27260:27263 proof <> CSeq constr
R27273:27277 proof <> Write constr
R27284:27288 proof <> wval2 var
R27279:27282 proof <> wix2 var
R27265:27270 proof <> CBegin constr
R27168:27171 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R27164:27167 proof <> wix1 var
R27172:27175 proof <> wix2 var
R27331:27333 proof <> ceq def
R27355:27364 proof <> runProgram def
R27376:27389 proof <> writeToMemory' def
R27400:27424 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R27400:27424 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R27455:27458 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R27448:27450 Coq.Init.Logic <> :type_scope:x_'='_x not
R27460:27463 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R27455:27458 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R27448:27450 Coq.Init.Logic <> :type_scope:x_'='_x not
R27460:27463 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R27516:27528 proof <> writeToMemory def
R27553:27555 Coq.Init.Logic <> :type_scope:x_'='_x not
R27545:27548 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27556:27559 Coq.Init.Datatypes <> true constr
R27553:27555 Coq.Init.Logic <> :type_scope:x_'='_x not
R27545:27548 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27556:27559 Coq.Init.Datatypes <> true constr
R27571:27580 Coq.Arith.PeanoNat Nat eqb_eq thm
R27571:27580 Coq.Arith.PeanoNat Nat eqb_eq thm
R27571:27580 Coq.Arith.PeanoNat Nat eqb_eq thm
R27612:27614 Coq.Init.Logic <> :type_scope:x_'='_x not
R27604:27607 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27615:27619 Coq.Init.Datatypes <> false constr
R27612:27614 Coq.Init.Logic <> :type_scope:x_'='_x not
R27604:27607 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27615:27619 Coq.Init.Datatypes <> false constr
R27631:27641 Coq.Arith.PeanoNat Nat eqb_neq thm
R27631:27641 Coq.Arith.PeanoNat Nat eqb_neq thm
R27631:27641 Coq.Arith.PeanoNat Nat eqb_neq thm
R27700:27712 proof <> writeToMemory def
R27743:27745 Coq.Init.Logic <> :type_scope:x_'='_x not
R27735:27738 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27746:27750 Coq.Init.Datatypes <> false constr
R27743:27745 Coq.Init.Logic <> :type_scope:x_'='_x not
R27735:27738 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27746:27750 Coq.Init.Datatypes <> false constr
R27762:27772 Coq.Arith.PeanoNat Nat eqb_neq thm
R27762:27772 Coq.Arith.PeanoNat Nat eqb_neq thm
R27762:27772 Coq.Arith.PeanoNat Nat eqb_neq thm
def 28321:28342 <> scheduleMappingWitness
R28356:28359 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28360:28362 Coq.Init.Datatypes <> nat ind
R28353:28355 Coq.Init.Datatypes <> nat ind
R28372:28374 proof <> com ind
R28409:28414 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28397:28399 Coq.Init.Logic <> :type_scope:x_'='_x not
R28389:28394 proof <> comlen def
R28396:28396 proof <> c var
R28400:28405 proof <> comlen def
R28407:28408 proof <> c' var
R28432:28437 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28415:28424 Coq.Logic.ExtensionalityFacts <> is_inverse def
R28428:28431 proof <> sinv var
R28426:28426 proof <> s var
R28449:28451 Coq.Init.Datatypes <> nat ind
R28478:28500 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28509:28512 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28504:28507 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R28501:28501 proof <> s var
R28503:28503 proof <> i var
R28528:28550 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28516:28519 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R28513:28513 proof <> s var
R28515:28515 proof <> i var
R28520:28525 proof <> comlen def
R28527:28527 proof <> c var
R28562:28565 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28557:28560 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R28551:28554 proof <> sinv var
R28556:28556 proof <> i var
R28585:28607 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28572:28575 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R28566:28569 proof <> sinv var
R28571:28571 proof <> i var
R28576:28581 proof <> comlen def
R28583:28584 proof <> c' var
R28646:28668 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28623:28625 Coq.Init.Logic <> :type_scope:x_'='_x not
R28608:28618 proof <> getWriteAt' def
R28622:28622 proof <> i var
R28620:28620 proof <> c var
R28626:28636 proof <> getWriteAt' def
R28642:28642 proof <> s var
R28644:28644 proof <> i var
R28638:28639 proof <> c' var
R28691:28693 Coq.Init.Logic <> :type_scope:x_'='_x not
R28669:28679 proof <> getWriteAt' def
R28684:28687 proof <> sinv var
R28689:28689 proof <> i var
R28681:28681 proof <> c var
R28694:28704 proof <> getWriteAt' def
R28709:28709 proof <> i var
R28706:28707 proof <> c' var
R28461:28464 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28456:28459 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R28455:28455 proof <> i var
R28466:28469 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R28465:28465 proof <> i var
R28470:28475 proof <> comlen def
R28477:28477 proof <> c var
prf 28720:28750 <> scheduleMappingWitnessSymmetric
R28772:28775 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28776:28778 Coq.Init.Datatypes <> nat ind
R28769:28771 Coq.Init.Datatypes <> nat ind
R28788:28790 proof <> com ind
R28832:28835 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28836:28857 proof <> scheduleMappingWitness def
R28869:28869 proof <> c var
R28866:28867 proof <> c' var
R28864:28864 proof <> s var
R28859:28862 proof <> sinv var
R28798:28819 proof <> scheduleMappingWitness def
R28830:28831 proof <> c' var
R28828:28828 proof <> c var
R28823:28826 proof <> sinv var
R28821:28821 proof <> s var
R28888:28909 proof <> scheduleMappingWitness def
R28987:28996 Coq.Logic.ExtensionalityFacts <> is_inverse def
R29006:29015 Coq.Logic.ExtensionalityFacts <> is_inverse def
def 29265:29289 <> applyScheduleToDependence
R29298:29301 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29302:29304 Coq.Init.Datatypes <> nat ind
R29295:29297 Coq.Init.Datatypes <> nat ind
R29311:29320 proof <> dependence def
R29325:29334 proof <> dependence def
R29347:29347 proof <> d var
R29358:29358 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29361:29362 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29365:29365 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29370:29370 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29375:29376 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29381:29381 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29371:29371 proof <> s var
R29377:29377 proof <> s var
def 29402:29427 <> scheduleRespectsDependence
R29436:29439 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29440:29442 Coq.Init.Datatypes <> nat ind
R29433:29435 Coq.Init.Datatypes <> nat ind
R29449:29458 proof <> dependence def
R29473:29493 proof <> dependenceLexPositive def
R29496:29520 proof <> applyScheduleToDependence def
R29524:29524 proof <> d var
R29522:29522 proof <> s var
def 29540:29568 <> scheduleRespectsDependenceSet
R29577:29580 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29581:29583 Coq.Init.Datatypes <> nat ind
R29574:29576 Coq.Init.Datatypes <> nat ind
R29591:29603 proof <> dependenceset def
R29627:29636 proof <> dependence def
R29652:29655 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29656:29681 proof <> scheduleRespectsDependence def
R29685:29685 proof <> d var
R29683:29683 proof <> s var
R29640:29646 Coq.Lists.List <> In def
R29650:29651 proof <> ds var
R29648:29648 proof <> d var
def 30058:30072 <> validDependence
R30078:30080 proof <> com ind
R30087:30096 proof <> dependence def
R30133:30136 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30111:30128 proof <> dependenceAliases' def
R30132:30132 proof <> c var
R30130:30130 proof <> d var
R30158:30161 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30137:30153 proof <> dependenceInRange def
R30157:30157 proof <> c var
R30155:30155 proof <> d var
R30162:30182 proof <> dependenceLexPositive def
R30184:30184 proof <> d var
R30199:30213 proof <> validDependence def
def 30228:30248 <> completeDependenceSet
R30254:30256 proof <> com ind
R30264:30276 proof <> dependenceset def
R30302:30311 proof <> dependence def
R30319:30319 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30355:30364 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30400:30400 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30339:30342 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30343:30349 Coq.Lists.List <> In def
R30353:30354 proof <> ds var
R30351:30351 proof <> d var
R30320:30334 proof <> validDependence def
R30338:30338 proof <> d var
R30336:30336 proof <> c var
R30377:30380 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30381:30395 proof <> validDependence def
R30399:30399 proof <> d var
R30397:30397 proof <> c var
R30365:30371 Coq.Lists.List <> In def
R30375:30376 proof <> ds var
R30373:30373 proof <> d var
prf 30504:30538 <> emptyDependenceSetImpliesNoAliasing
R30555:30557 Coq.Init.Datatypes <> nat ind
R30564:30566 proof <> com ind
R30607:30610 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30639:30642 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30669:30673 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30674:30681 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30693:30695 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30688:30692 proof <> write ind
R30720:30723 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30711:30713 Coq.Init.Logic <> :type_scope:x_'='_x not
R30696:30706 proof <> getWriteAt' def
R30710:30710 proof <> i var
R30708:30708 proof <> c var
R30714:30717 Coq.Init.Datatypes <> Some constr
R30719:30719 proof <> w var
R30749:30752 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30739:30741 Coq.Init.Logic <> :type_scope:x_'='_x not
R30724:30734 proof <> getWriteAt' def
R30738:30738 proof <> j var
R30736:30736 proof <> c var
R30742:30745 Coq.Init.Datatypes <> Some constr
R30747:30748 proof <> w' var
R30762:30765 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R30753:30759 proof <> writeIx def
R30761:30761 proof <> w var
R30766:30772 proof <> writeIx def
R30774:30775 proof <> w' var
R30643:30659 proof <> dependenceInRange def
R30668:30668 proof <> c var
R30661:30661 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30663:30664 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30666:30666 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30662:30662 proof <> i var
R30665:30665 proof <> j var
R30611:30631 proof <> dependenceLexPositive def
R30633:30633 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30635:30636 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30638:30638 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30634:30634 proof <> i var
R30637:30637 proof <> j var
R30570:30590 proof <> completeDependenceSet def
R30594:30606 Coq.Init.Datatypes <> nil constr
R30592:30592 proof <> c var
R30805:30812 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30822:30824 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30817:30821 proof <> write ind
R30840:30842 Coq.Init.Logic <> :type_scope:x_'='_x not
R30825:30835 proof <> getWriteAt' def
R30843:30846 Coq.Init.Datatypes <> Some constr
R30848:30849 proof <> wi var
R30805:30812 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30822:30824 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30817:30821 proof <> write ind
R30840:30842 Coq.Init.Logic <> :type_scope:x_'='_x not
R30825:30835 proof <> getWriteAt' def
R30843:30846 Coq.Init.Datatypes <> Some constr
R30848:30849 proof <> wi var
R30862:30878 proof <> dependenceInRange def
R30922:30937 proof <> commandIxInRange def
R30954:30977 proof <> getWriteAt'RangeComplete thm
R30954:30977 proof <> getWriteAt'RangeComplete thm
R30999:31006 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31016:31018 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31011:31015 proof <> write ind
R31034:31036 Coq.Init.Logic <> :type_scope:x_'='_x not
R31019:31029 proof <> getWriteAt' def
R31037:31040 Coq.Init.Datatypes <> Some constr
R31042:31043 proof <> wj var
R30999:31006 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31016:31018 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31011:31015 proof <> write ind
R31034:31036 Coq.Init.Logic <> :type_scope:x_'='_x not
R31019:31029 proof <> getWriteAt' def
R31037:31040 Coq.Init.Datatypes <> Some constr
R31042:31043 proof <> wj var
R31056:31072 proof <> dependenceInRange def
R31116:31139 proof <> getWriteAt'RangeComplete thm
R31116:31139 proof <> getWriteAt'RangeComplete thm
R31151:31166 proof <> commandIxInRange def
R31313:31316 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R31300:31302 Coq.Init.Logic <> :type_scope:x_'='_x not
R31291:31297 proof <> writeIx def
R31303:31309 proof <> writeIx def
R31326:31329 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R31317:31323 proof <> writeIx def
R31330:31336 proof <> writeIx def
R31313:31316 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R31300:31302 Coq.Init.Logic <> :type_scope:x_'='_x not
R31291:31297 proof <> writeIx def
R31303:31309 proof <> writeIx def
R31326:31329 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R31317:31323 proof <> writeIx def
R31330:31336 proof <> writeIx def
R31426:31446 proof <> completeDependenceSet def
R31473:31473 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31475:31476 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31478:31478 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31473:31473 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31475:31476 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31478:31478 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31536:31540 Coq.Init.Logic <> False ind
R31536:31540 Coq.Init.Logic <> False ind
R31587:31601 proof <> validDependence def
R31628:31645 proof <> dependenceAliases' def
prf 31871:31906 <> emptyDependenceSetImpliesNoAliasing'
R31923:31925 Coq.Init.Datatypes <> nat ind
R31932:31934 proof <> com ind
R31975:31978 Coq.Init.Logic <> :type_scope:x_'->'_x not
R31985:31989 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32010:32013 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32034:32037 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32038:32045 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32057:32059 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32052:32056 proof <> write ind
R32084:32087 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32075:32077 Coq.Init.Logic <> :type_scope:x_'='_x not
R32060:32070 proof <> getWriteAt' def
R32074:32074 proof <> i var
R32072:32072 proof <> c var
R32078:32081 Coq.Init.Datatypes <> Some constr
R32083:32083 proof <> w var
R32113:32116 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32103:32105 Coq.Init.Logic <> :type_scope:x_'='_x not
R32088:32098 proof <> getWriteAt' def
R32102:32102 proof <> j var
R32100:32100 proof <> c var
R32106:32109 Coq.Init.Datatypes <> Some constr
R32111:32112 proof <> w' var
R32126:32129 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32117:32123 proof <> writeIx def
R32125:32125 proof <> w var
R32130:32136 proof <> writeIx def
R32138:32139 proof <> w' var
R32014:32029 proof <> commandIxInRange def
R32033:32033 proof <> j var
R32031:32031 proof <> c var
R31990:32005 proof <> commandIxInRange def
R32009:32009 proof <> i var
R32007:32007 proof <> c var
R31980:31983 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R31979:31979 proof <> i var
R31984:31984 proof <> j var
R31938:31958 proof <> completeDependenceSet def
R31962:31974 Coq.Init.Datatypes <> nil constr
R31960:31960 proof <> c var
R32167:32170 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R32163:32165 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R32172:32174 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R32167:32170 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R32163:32165 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R32172:32174 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R32266:32300 proof <> emptyDependenceSetImpliesNoAliasing thm
R32266:32300 proof <> emptyDependenceSetImpliesNoAliasing thm
R32327:32347 proof <> dependenceLexPositive def
R32380:32396 proof <> dependenceInRange def
R32445:32452 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32464:32466 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32459:32463 proof <> write ind
R32491:32494 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32482:32484 Coq.Init.Logic <> :type_scope:x_'='_x not
R32467:32477 proof <> getWriteAt' def
R32485:32488 Coq.Init.Datatypes <> Some constr
R32490:32490 proof <> w var
R32520:32523 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32510:32512 Coq.Init.Logic <> :type_scope:x_'='_x not
R32495:32505 proof <> getWriteAt' def
R32513:32516 Coq.Init.Datatypes <> Some constr
R32518:32519 proof <> w' var
R32533:32536 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32524:32530 proof <> writeIx def
R32532:32532 proof <> w var
R32537:32543 proof <> writeIx def
R32545:32546 proof <> w' var
R32445:32452 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32464:32466 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32459:32463 proof <> write ind
R32491:32494 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32482:32484 Coq.Init.Logic <> :type_scope:x_'='_x not
R32467:32477 proof <> getWriteAt' def
R32485:32488 Coq.Init.Datatypes <> Some constr
R32490:32490 proof <> w var
R32520:32523 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32510:32512 Coq.Init.Logic <> :type_scope:x_'='_x not
R32495:32505 proof <> getWriteAt' def
R32513:32516 Coq.Init.Datatypes <> Some constr
R32518:32519 proof <> w' var
R32533:32536 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32524:32530 proof <> writeIx def
R32532:32532 proof <> w var
R32537:32543 proof <> writeIx def
R32545:32546 proof <> w' var
R32562:32596 proof <> emptyDependenceSetImpliesNoAliasing thm
R32562:32596 proof <> emptyDependenceSetImpliesNoAliasing thm
R32640:32656 proof <> dependenceInRange def
prf 32874:32914 <> scheduleMappingWitnessDestructOnCSeqEqual
R32934:32936 proof <> com ind
R32951:32954 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32955:32957 Coq.Init.Datatypes <> nat ind
R32948:32950 Coq.Init.Datatypes <> nat ind
R32964:32968 proof <> write ind
R32976:32988 proof <> dependenceset def
R33022:33029 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33082:33089 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33124:33131 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33132:33153 proof <> scheduleMappingWitness def
R33164:33165 proof <> c' var
R33162:33162 proof <> c var
R33157:33160 proof <> sinv var
R33155:33155 proof <> s var
R33090:33118 proof <> scheduleRespectsDependenceSet def
R33122:33123 proof <> ds var
R33120:33120 proof <> s var
R33030:33051 proof <> scheduleMappingWitness def
R33072:33075 proof <> CSeq constr
R33080:33080 proof <> w var
R33077:33078 proof <> c' var
R33061:33064 proof <> CSeq constr
R33068:33068 proof <> w var
R33066:33066 proof <> c var
R33055:33058 proof <> sinv var
R33053:33053 proof <> s var
R32996:33016 proof <> completeDependenceSet def
R33020:33021 proof <> ds var
R33018:33018 proof <> c var
R33194:33215 proof <> scheduleMappingWitness def
R33227:33248 proof <> scheduleMappingWitness def
R33316:33321 proof <> comlen def
R33335:33340 proof <> comlen def
R33335:33340 proof <> comlen def
R33520:33525 proof <> comlen def
R33533:33538 proof <> comlen def
R33533:33538 proof <> comlen def
R33561:33566 proof <> comlen def
R33580:33585 proof <> comlen def
R33580:33585 proof <> comlen def
R33634:33639 proof <> comlen def
R33653:33658 proof <> comlen def
R33653:33658 proof <> comlen def
R33689:33691 Coq.Init.Logic <> :type_scope:x_'='_x not
R33681:33686 proof <> comlen def
R33692:33697 proof <> comlen def
R33689:33691 Coq.Init.Logic <> :type_scope:x_'='_x not
R33681:33686 proof <> comlen def
R33692:33697 proof <> comlen def
R33724:33752 proof <> scheduleRespectsDependenceSet def
prf 33836:33855 <> writesEqualDecidable
R33872:33876 proof <> write ind
R33886:33889 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R33881:33883 Coq.Init.Logic <> :type_scope:x_'='_x not
R33880:33880 proof <> w var
R33884:33885 proof <> w' var
R33891:33894 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R33890:33890 proof <> w var
R33895:33896 proof <> w' var
R33954:33957 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R33949:33951 Coq.Init.Logic <> :type_scope:x_'='_x not
R33959:33962 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R33954:33957 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R33949:33951 Coq.Init.Logic <> :type_scope:x_'='_x not
R33959:33962 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R33991:33994 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R33986:33988 Coq.Init.Logic <> :type_scope:x_'='_x not
R33996:33999 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R33991:33994 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R33986:33988 Coq.Init.Logic <> :type_scope:x_'='_x not
R33996:33999 Coq.Init.Logic <> :type_scope:x_'<>'_x not
def 34182:34216 <> NoAliasingBetweenSubprogramAndWrite
R34222:34224 proof <> com ind
R34233:34237 proof <> memix syndef
R34263:34265 Coq.Init.Datatypes <> nat ind
R34289:34311 Coq.Init.Logic <> :type_scope:x_'->'_x not
R34348:34351 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34312:34321 Coq.Init.Datatypes <> option_map def
R34332:34342 proof <> getWriteAt' def
R34346:34346 proof <> i var
R34344:34344 proof <> c var
R34323:34329 proof <> writeIx def
R34352:34355 Coq.Init.Datatypes <> Some constr
R34357:34359 proof <> wix var
R34269:34284 proof <> commandIxInRange def
R34288:34288 proof <> i var
R34286:34286 proof <> c var
prf 34438:34486 <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq
R34502:34504 proof <> com ind
R34522:34526 proof <> memix syndef
R34536:34543 proof <> memvalue syndef
R34621:34628 Coq.Init.Logic <> :type_scope:x_'->'_x not
R34675:34678 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R34629:34663 proof <> NoAliasingBetweenSubprogramAndWrite def
R34667:34674 proof <> wixalias var
R34665:34665 proof <> c var
R34682:34685 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34679:34681 proof <> wix var
R34686:34693 proof <> wixalias var
R34551:34585 proof <> NoAliasingBetweenSubprogramAndWrite def
R34613:34620 proof <> wixalias var
R34588:34591 proof <> CSeq constr
R34596:34600 proof <> Write constr
R34606:34609 proof <> wval var
R34602:34604 proof <> wix var
R34593:34593 proof <> c var
R34778:34812 proof <> NoAliasingBetweenSubprogramAndWrite def
R34826:34860 proof <> NoAliasingBetweenSubprogramAndWrite def
R34948:34950 Coq.Init.Logic <> :type_scope:x_'='_x not
R34931:34934 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R34935:34935 Coq.Init.Datatypes <> S constr
R34938:34943 proof <> comlen def
R34951:34955 Coq.Init.Datatypes <> false constr
R34948:34950 Coq.Init.Logic <> :type_scope:x_'='_x not
R34931:34934 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R34935:34935 Coq.Init.Datatypes <> S constr
R34938:34943 proof <> comlen def
R34951:34955 Coq.Init.Datatypes <> false constr
R34971:34981 Coq.Arith.PeanoNat Nat eqb_neq thm
R34971:34981 Coq.Arith.PeanoNat Nat eqb_neq thm
R34971:34981 Coq.Arith.PeanoNat Nat eqb_neq thm
R34991:35006 proof <> commandIxInRange def
R35066:35090 proof <> commandIxInRangeInclusive thm
R35066:35090 proof <> commandIxInRangeInclusive thm
R35158:35192 proof <> NoAliasingBetweenSubprogramAndWrite def
R35227:35229 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35219:35224 proof <> comlen def
R35227:35229 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35219:35224 proof <> comlen def
R35291:35293 Coq.Init.Logic <> :type_scope:x_'='_x not
R35275:35278 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R35271:35273 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35263:35268 proof <> comlen def
R35279:35279 Coq.Init.Datatypes <> S constr
R35282:35287 proof <> comlen def
R35294:35297 Coq.Init.Datatypes <> true constr
R35291:35293 Coq.Init.Logic <> :type_scope:x_'='_x not
R35275:35278 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R35271:35273 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35263:35268 proof <> comlen def
R35279:35279 Coq.Init.Datatypes <> S constr
R35282:35287 proof <> comlen def
R35294:35297 Coq.Init.Datatypes <> true constr
R35309:35318 Coq.Arith.PeanoNat Nat eqb_eq thm
R35309:35318 Coq.Arith.PeanoNat Nat eqb_eq thm
R35309:35318 Coq.Arith.PeanoNat Nat eqb_eq thm
R35402:35405 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35409:35412 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35385:35388 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35377:35380 Coq.Init.Datatypes <> Some constr
R35389:35392 Coq.Init.Datatypes <> Some constr
R35402:35405 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35409:35412 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35385:35388 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35377:35380 Coq.Init.Datatypes <> Some constr
R35389:35392 Coq.Init.Datatypes <> Some constr
R35464:35479 proof <> commandIxInRange def
R35493:35498 proof <> comlen def
R35506:35511 proof <> comlen def
R35506:35511 proof <> comlen def
def 35604:35631 <> NoAliasingBetweenSubprograms
R35641:35643 proof <> com ind
R35673:35675 Coq.Init.Datatypes <> nat ind
R35704:35710 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35732:35739 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35777:35780 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35740:35749 Coq.Init.Datatypes <> option_map def
R35760:35770 proof <> getWriteAt' def
R35775:35775 proof <> i var
R35772:35773 proof <> c1 var
R35751:35757 proof <> writeIx def
R35781:35790 Coq.Init.Datatypes <> option_map def
R35801:35811 proof <> getWriteAt' def
R35816:35816 proof <> j var
R35813:35814 proof <> c2 var
R35792:35798 proof <> writeIx def
R35711:35726 proof <> commandIxInRange def
R35731:35731 proof <> j var
R35728:35729 proof <> c2 var
R35683:35698 proof <> commandIxInRange def
R35703:35703 proof <> i var
R35700:35701 proof <> c1 var
prf 35827:35868 <> NoAliasingBetweenSubprogramsDestructOnCSeq
R35886:35888 proof <> com ind
R35897:35901 proof <> memix syndef
R35911:35918 proof <> memvalue syndef
R35984:35991 Coq.Init.Logic <> :type_scope:x_'->'_x not
R36026:36033 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R35992:36019 proof <> NoAliasingBetweenSubprograms def
R36024:36025 proof <> c2 var
R36021:36022 proof <> c1 var
R36034:36068 proof <> NoAliasingBetweenSubprogramAndWrite def
R36073:36075 proof <> wix var
R36070:36071 proof <> c2 var
R35926:35953 proof <> NoAliasingBetweenSubprograms def
R35982:35983 proof <> c2 var
R35956:35959 proof <> CSeq constr
R35965:35969 proof <> Write constr
R35975:35978 proof <> wval var
R35971:35973 proof <> wix var
R35961:35962 proof <> c1 var
R36158:36185 proof <> NoAliasingBetweenSubprograms def
R36207:36234 proof <> NoAliasingBetweenSubprograms def
R36274:36289 proof <> commandIxInRange def
R36292:36295 proof <> CSeq constr
R36301:36305 proof <> Write constr
R36274:36289 proof <> commandIxInRange def
R36292:36295 proof <> CSeq constr
R36301:36305 proof <> Write constr
R36330:36354 proof <> commandIxInRangeInclusive thm
R36330:36354 proof <> commandIxInRangeInclusive thm
R36397:36421 proof <> getWriteAt'DestructOnCSeq thm
R36397:36421 proof <> getWriteAt'DestructOnCSeq thm
R36397:36421 proof <> getWriteAt'DestructOnCSeq thm
R36397:36421 proof <> getWriteAt'DestructOnCSeq thm
R36449:36464 proof <> commandIxInRange def
R36520:36554 proof <> NoAliasingBetweenSubprogramAndWrite def
R36566:36593 proof <> NoAliasingBetweenSubprograms def
R36627:36629 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36618:36623 proof <> comlen def
R36627:36629 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36618:36623 proof <> comlen def
R36645:36660 proof <> commandIxInRange def
R36699:36701 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36690:36695 proof <> comlen def
R36663:36666 proof <> CSeq constr
R36672:36676 proof <> Write constr
R36645:36660 proof <> commandIxInRange def
R36699:36701 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36690:36695 proof <> comlen def
R36663:36666 proof <> CSeq constr
R36672:36676 proof <> Write constr
R36716:36731 proof <> commandIxInRange def
R36741:36746 proof <> comlen def
R36754:36759 proof <> comlen def
R36754:36759 proof <> comlen def
R36858:36860 Coq.Init.Logic <> :type_scope:x_'='_x not
R36842:36845 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R36838:36840 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36829:36834 proof <> comlen def
R36846:36846 Coq.Init.Datatypes <> S constr
R36848:36853 proof <> comlen def
R36861:36864 Coq.Init.Datatypes <> true constr
R36858:36860 Coq.Init.Logic <> :type_scope:x_'='_x not
R36842:36845 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R36838:36840 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36829:36834 proof <> comlen def
R36846:36846 Coq.Init.Datatypes <> S constr
R36848:36853 proof <> comlen def
R36861:36864 Coq.Init.Datatypes <> true constr
R36878:36887 Coq.Arith.PeanoNat Nat eqb_eq thm
R36878:36887 Coq.Arith.PeanoNat Nat eqb_eq thm
R36878:36887 Coq.Arith.PeanoNat Nat eqb_eq thm
prf 37066:37118 <> NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough
R37134:37136 proof <> com ind
R37145:37149 proof <> memix syndef
R37158:37163 proof <> memory def
R37212:37219 Coq.Init.Logic <> :type_scope:x_'->'_x not
R37242:37244 Coq.Init.Logic <> :type_scope:x_'='_x not
R37221:37230 proof <> runProgram def
R37234:37236 proof <> mem var
R37232:37232 proof <> c var
R37239:37241 proof <> wix var
R37245:37247 proof <> mem var
R37249:37251 proof <> wix var
R37171:37205 proof <> NoAliasingBetweenSubprogramAndWrite def
R37209:37211 proof <> wix var
R37207:37207 proof <> c var
R37295:37304 proof <> runProgram def
R37312:37321 proof <> runProgram def
R37312:37321 proof <> runProgram def
R37333:37346 proof <> writeToMemory' def
R37380:37392 proof <> writeToMemory def
R37412:37415 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R37408:37410 Coq.Init.Logic <> :type_scope:x_'='_x not
R37419:37422 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37412:37415 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R37408:37410 Coq.Init.Logic <> :type_scope:x_'='_x not
R37419:37422 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37558:37592 proof <> NoAliasingBetweenSubprogramAndWrite def
R37615:37618 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37615:37618 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37682:37684 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37674:37679 proof <> comlen def
R37682:37684 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37674:37679 proof <> comlen def
R37701:37716 proof <> commandIxInRange def
R37731:37736 proof <> comlen def
R37749:37754 proof <> comlen def
R37749:37754 proof <> comlen def
R37786:37789 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R37782:37784 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37774:37779 proof <> comlen def
R37791:37793 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37794:37799 proof <> comlen def
R37786:37789 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R37782:37784 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37774:37779 proof <> comlen def
R37791:37793 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37794:37799 proof <> comlen def
R37836:37839 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R37832:37834 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37824:37829 proof <> comlen def
R37836:37839 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R37832:37834 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37824:37829 proof <> comlen def
R37971:37973 Coq.Init.Logic <> :type_scope:x_'='_x not
R37955:37958 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R37951:37953 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37943:37948 proof <> comlen def
R37959:37959 Coq.Init.Datatypes <> S constr
R37962:37967 proof <> comlen def
R37974:37977 Coq.Init.Datatypes <> true constr
R37971:37973 Coq.Init.Logic <> :type_scope:x_'='_x not
R37955:37958 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R37951:37953 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37943:37948 proof <> comlen def
R37959:37959 Coq.Init.Datatypes <> S constr
R37962:37967 proof <> comlen def
R37974:37977 Coq.Init.Datatypes <> true constr
R37990:37999 Coq.Arith.PeanoNat Nat eqb_eq thm
R37990:37999 Coq.Arith.PeanoNat Nat eqb_eq thm
R37990:37999 Coq.Arith.PeanoNat Nat eqb_eq thm
R38072:38075 Coq.Init.Logic <> :type_scope:x_'->'_x not
R38079:38082 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38060:38063 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38054:38057 Coq.Init.Datatypes <> Some constr
R38064:38067 Coq.Init.Datatypes <> Some constr
R38072:38075 Coq.Init.Logic <> :type_scope:x_'->'_x not
R38079:38082 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38060:38063 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38054:38057 Coq.Init.Datatypes <> Some constr
R38064:38067 Coq.Init.Datatypes <> Some constr
R38233:38235 Coq.Init.Logic <> :type_scope:x_'='_x not
R38228:38231 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R38236:38240 Coq.Init.Datatypes <> false constr
R38233:38235 Coq.Init.Logic <> :type_scope:x_'='_x not
R38228:38231 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R38236:38240 Coq.Init.Datatypes <> false constr
R38252:38262 Coq.Arith.PeanoNat Nat eqb_neq thm
R38252:38262 Coq.Arith.PeanoNat Nat eqb_neq thm
R38252:38262 Coq.Arith.PeanoNat Nat eqb_neq thm
R38282:38330 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R38282:38330 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R38459:38468 proof <> runProgram def
R38476:38485 proof <> runProgram def
R38476:38485 proof <> runProgram def
prf 38511:38561 <> NoAliasingBetweenSubprogramAndWriteAllowsReordering
R38577:38579 proof <> com ind
R38588:38592 proof <> memix syndef
R38603:38610 proof <> memvalue syndef
R38619:38624 proof <> memory def
R38673:38680 Coq.Init.Logic <> :type_scope:x_'->'_x not
R38731:38737 Coq.Init.Logic <> :type_scope:x_'='_x not
R38681:38690 proof <> runProgram def
R38695:38708 proof <> writeToMemory' def
R38727:38729 proof <> mem var
R38711:38715 proof <> Write constr
R38721:38724 proof <> wval var
R38717:38719 proof <> wix var
R38692:38692 proof <> c var
R38738:38751 proof <> writeToMemory' def
R38771:38780 proof <> runProgram def
R38784:38786 proof <> mem var
R38782:38782 proof <> c var
R38754:38758 proof <> Write constr
R38764:38767 proof <> wval var
R38760:38762 proof <> wix var
R38632:38666 proof <> NoAliasingBetweenSubprogramAndWrite def
R38670:38672 proof <> wix var
R38668:38668 proof <> c var
R38815:38839 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R38815:38839 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R38869:38872 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R38863:38865 Coq.Init.Logic <> :type_scope:x_'='_x not
R38874:38877 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38869:38872 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R38863:38865 Coq.Init.Logic <> :type_scope:x_'='_x not
R38874:38877 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38947:38960 proof <> writeToMemory' def
R38972:38984 proof <> writeToMemory def
R39005:39007 Coq.Init.Logic <> :type_scope:x_'='_x not
R38998:39001 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39008:39011 Coq.Init.Datatypes <> true constr
R39005:39007 Coq.Init.Logic <> :type_scope:x_'='_x not
R38998:39001 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39008:39011 Coq.Init.Datatypes <> true constr
R39023:39032 Coq.Arith.PeanoNat Nat eqb_eq thm
R39023:39032 Coq.Arith.PeanoNat Nat eqb_eq thm
R39023:39032 Coq.Arith.PeanoNat Nat eqb_eq thm
R39061:39073 proof <> writeToMemory def
R39061:39073 proof <> writeToMemory def
R39097:39101 proof <> memix syndef
R39111:39114 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39109:39110 proof <> ix var
R39139:39140 proof <> ix var
R39097:39101 proof <> memix syndef
R39111:39114 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39109:39110 proof <> ix var
R39139:39140 proof <> ix var
R39185:39187 Coq.Init.Logic <> :type_scope:x_'='_x not
R39164:39173 proof <> runProgram def
R39185:39187 Coq.Init.Logic <> :type_scope:x_'='_x not
R39164:39173 proof <> runProgram def
R39207:39259 proof <> NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough thm
R39207:39259 proof <> NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough thm
R39374:39376 Coq.Init.Logic <> :type_scope:x_'='_x not
R39367:39370 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39377:39381 Coq.Init.Datatypes <> false constr
R39374:39376 Coq.Init.Logic <> :type_scope:x_'='_x not
R39367:39370 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39377:39381 Coq.Init.Datatypes <> false constr
R39393:39403 Coq.Arith.PeanoNat Nat eqb_neq thm
R39393:39403 Coq.Arith.PeanoNat Nat eqb_neq thm
R39393:39403 Coq.Arith.PeanoNat Nat eqb_neq thm
R39576:39589 proof <> writeToMemory' def
R39602:39623 proof <> readFromWriteDifferent thm
R39602:39623 proof <> readFromWriteDifferent thm
R39602:39623 proof <> readFromWriteDifferent thm
R39602:39623 proof <> readFromWriteDifferent thm
R39635:39644 proof <> runProgram def
R39652:39661 proof <> runProgram def
R39652:39661 proof <> runProgram def
R39775:39778 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R39734:39768 proof <> NoAliasingBetweenSubprogramAndWrite def
R39780:39783 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R39775:39778 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R39734:39768 proof <> NoAliasingBetweenSubprogramAndWrite def
R39780:39783 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R39798:39846 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R39798:39846 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R39921:39934 proof <> writeToMemory' def
R39953:39966 proof <> writeToMemory' def
R39984:39987 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R39980:39982 Coq.Init.Logic <> :type_scope:x_'='_x not
R39989:39992 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R39984:39987 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R39980:39982 Coq.Init.Logic <> :type_scope:x_'='_x not
R39989:39992 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R40062:40074 proof <> writeToMemory def
R40095:40097 Coq.Init.Logic <> :type_scope:x_'='_x not
R40090:40093 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40098:40101 Coq.Init.Datatypes <> true constr
R40095:40097 Coq.Init.Logic <> :type_scope:x_'='_x not
R40090:40093 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40098:40101 Coq.Init.Datatypes <> true constr
R40113:40122 Coq.Arith.PeanoNat Nat eqb_eq thm
R40113:40122 Coq.Arith.PeanoNat Nat eqb_eq thm
R40113:40122 Coq.Arith.PeanoNat Nat eqb_eq thm
R40245:40247 Coq.Init.Logic <> :type_scope:x_'='_x not
R40206:40218 proof <> writeToMemory def
R40225:40234 proof <> runProgram def
R40248:40257 proof <> runProgram def
R40245:40247 Coq.Init.Logic <> :type_scope:x_'='_x not
R40206:40218 proof <> writeToMemory def
R40225:40234 proof <> runProgram def
R40248:40257 proof <> runProgram def
R40281:40293 proof <> writeToMemory def
R40310:40312 Coq.Init.Logic <> :type_scope:x_'='_x not
R40305:40308 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40313:40317 Coq.Init.Datatypes <> false constr
R40310:40312 Coq.Init.Logic <> :type_scope:x_'='_x not
R40305:40308 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40313:40317 Coq.Init.Datatypes <> false constr
R40329:40339 Coq.Arith.PeanoNat Nat eqb_neq thm
R40329:40339 Coq.Arith.PeanoNat Nat eqb_neq thm
R40329:40339 Coq.Arith.PeanoNat Nat eqb_neq thm
R40474:40476 Coq.Init.Logic <> :type_scope:x_'='_x not
R40410:40422 proof <> writeToMemory def
R40429:40438 proof <> runProgram def
R40443:40455 proof <> writeToMemory def
R40477:40486 proof <> runProgram def
R40474:40476 Coq.Init.Logic <> :type_scope:x_'='_x not
R40410:40422 proof <> writeToMemory def
R40429:40438 proof <> runProgram def
R40443:40455 proof <> writeToMemory def
R40477:40486 proof <> runProgram def
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40518:40539 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40578:40599 proof <> readFromWriteDifferent thm
R40739:40748 proof <> runProgram def
R40756:40765 proof <> runProgram def
R40756:40765 proof <> runProgram def
prf 40801:40844 <> NoAliasingBetweenSubprogramsAllowsReordering
R40862:40864 proof <> com ind
R40906:40909 Coq.Init.Logic <> :type_scope:x_'->'_x not
R40919:40923 proof <> ::x_'==='_x not
R40912:40916 proof <> ::x_'+++'_x not
R40910:40911 proof <> c1 var
R40917:40918 proof <> c2 var
R40926:40930 proof <> ::x_'+++'_x not
R40924:40925 proof <> c2 var
R40931:40932 proof <> c1 var
R40872:40899 proof <> NoAliasingBetweenSubprograms def
R40904:40905 proof <> c2 var
R40901:40902 proof <> c1 var
R40963:40965 proof <> ceq def
R40988:41015 proof <> runprogram_distribute_append thm
R40988:41015 proof <> runprogram_distribute_append thm
R40988:41015 proof <> runprogram_distribute_append thm
R41028:41055 proof <> runprogram_distribute_append thm
R41028:41055 proof <> runprogram_distribute_append thm
R41028:41055 proof <> runprogram_distribute_append thm
R41229:41238 proof <> runProgram def
R41246:41255 proof <> runProgram def
R41246:41255 proof <> runProgram def
R41329:41370 proof <> NoAliasingBetweenSubprogramsDestructOnCSeq thm
R41329:41370 proof <> NoAliasingBetweenSubprogramsDestructOnCSeq thm
R41468:41477 proof <> runProgram def
R41468:41477 proof <> runProgram def
R41521:41571 proof <> NoAliasingBetweenSubprogramAndWriteAllowsReordering thm
R41521:41571 proof <> NoAliasingBetweenSubprogramAndWriteAllowsReordering thm
R41630:41639 proof <> runProgram def
R41647:41656 proof <> runProgram def
R41647:41656 proof <> runProgram def
def 41694:41719 <> aliasingWriteTimepointsSet
R41725:41727 proof <> com ind
R41735:41739 proof <> memix syndef
R41746:41749 Coq.Init.Datatypes <> list ind
R41751:41759 proof <> timepoint syndef
R41786:41791 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R41774:41783 Coq.Lists.List <> NoDup ind
R41785:41785 proof <> l var
R41803:41811 proof <> timepoint syndef
R41830:41833 Coq.Init.Logic <> :type_scope:x_'->'_x not
R41854:41858 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R41922:41922 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R41834:41849 proof <> commandIxInRange def
R41853:41853 proof <> t var
R41851:41851 proof <> c var
R41859:41866 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R41881:41883 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R41873:41880 proof <> memvalue syndef
R41899:41901 Coq.Init.Logic <> :type_scope:x_'='_x not
R41884:41894 proof <> getWriteAt' def
R41898:41898 proof <> t var
R41896:41896 proof <> c var
R41902:41905 Coq.Init.Datatypes <> Some constr
R41908:41912 proof <> Write constr
R41917:41920 proof <> wval var
R41914:41915 proof <> ix var
R41819:41825 Coq.Lists.List <> In def
R41829:41829 proof <> l var
R41827:41827 proof <> t var
prf 44173:44203 <> list_length_1_implies_singleton
R44227:44230 Coq.Init.Datatypes <> list ind
R44232:44232 proof <> a var
R44248:44251 Coq.Init.Logic <> :type_scope:x_'->'_x not
R44252:44259 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44264:44266 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44263:44263 proof <> a var
R44268:44270 Coq.Init.Logic <> :type_scope:x_'='_x not
R44267:44267 proof <> l var
R44271:44279 Coq.Lists.List <> cons syndef
R44283:44290 Coq.Lists.List <> nil syndef
R44281:44281 proof <> x var
R44244:44246 Coq.Init.Logic <> :type_scope:x_'='_x not
R44236:44241 Coq.Init.Datatypes <> length def
R44243:44243 proof <> l var
R44379:44402 Coq.Lists.List <> length_zero_iff_nil thm
R44379:44402 Coq.Lists.List <> length_zero_iff_nil thm
R44379:44402 Coq.Lists.List <> length_zero_iff_nil thm
prf 44522:44550 <> list_length_2_implies_2_elems
R44574:44577 Coq.Init.Datatypes <> list ind
R44579:44579 proof <> a var
R44599:44602 Coq.Init.Logic <> :type_scope:x_'->'_x not
R44603:44610 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44618:44620 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44617:44617 proof <> a var
R44622:44624 Coq.Init.Logic <> :type_scope:x_'='_x not
R44621:44621 proof <> l var
R44625:44633 Coq.Lists.List <> cons syndef
R44638:44646 Coq.Lists.List <> cons syndef
R44651:44658 Coq.Lists.List <> nil syndef
R44648:44649 proof <> x' var
R44635:44635 proof <> x var
R44595:44597 Coq.Init.Logic <> :type_scope:x_'='_x not
R44587:44592 Coq.Init.Datatypes <> length def
R44594:44594 proof <> l var
R44746:44776 proof <> list_length_1_implies_singleton thm
R44746:44776 proof <> list_length_1_implies_singleton thm
prf 44864:44904 <> list_length_gt_2_implies_at_least_2_elems
R44928:44931 Coq.Init.Datatypes <> list ind
R44933:44933 proof <> a var
R44954:44957 Coq.Init.Logic <> :type_scope:x_'->'_x not
R44958:44965 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44987:44989 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44973:44973 proof <> a var
R44981:44984 Coq.Init.Datatypes <> list ind
R44986:44986 proof <> a var
R44991:44993 Coq.Init.Logic <> :type_scope:x_'='_x not
R44990:44990 proof <> l var
R44994:45002 Coq.Lists.List <> cons syndef
R45007:45015 Coq.Lists.List <> cons syndef
R45020:45021 proof <> l' var
R45017:45018 proof <> x' var
R45004:45004 proof <> x var
R44949:44952 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R44941:44946 Coq.Init.Datatypes <> length def
R44948:44948 proof <> l var
def 45180:45220 <> getLatestAliasingWriteTimepointForProgram
R45226:45228 proof <> com ind
R45236:45240 proof <> memix syndef
R45245:45250 Coq.Init.Datatypes <> option ind
R45252:45260 proof <> timepoint syndef
R45273:45273 proof <> c var
R45284:45289 proof <> CBegin constr
R45294:45297 Coq.Init.Datatypes <> None constr
R45303:45306 proof <> CSeq constr
R45328:45331 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R45319:45325 proof <> writeIx def
R45332:45333 proof <> ix var
R45397:45437 proof <> getLatestAliasingWriteTimepointForProgram def
R45442:45443 proof <> ix var
R45357:45360 Coq.Init.Datatypes <> Some constr
R45363:45368 proof <> comlen def
R45370:45370 proof <> c var
def 45464:45495 <> latestAliasingWriteTimepointSpec
R45501:45503 proof <> com ind
R45511:45515 proof <> memix syndef
R45527:45532 Coq.Init.Datatypes <> option ind
R45534:45542 proof <> timepoint syndef
R45556:45556 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R45841:45848 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R45988:45988 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R45557:45564 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45577:45585 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45568:45576 proof <> timepoint syndef
R45586:45586 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45602:45612 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45593:45595 Coq.Init.Logic <> :type_scope:x_'='_x not
R45587:45592 proof <> latest var
R45596:45599 Coq.Init.Datatypes <> Some constr
R45601:45601 proof <> n var
R45633:45642 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45613:45628 proof <> commandIxInRange def
R45632:45632 proof <> n var
R45630:45630 proof <> c var
R45643:45643 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45707:45717 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45644:45651 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45666:45668 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45658:45665 proof <> memvalue syndef
R45684:45686 Coq.Init.Logic <> :type_scope:x_'='_x not
R45669:45679 proof <> getWriteAt' def
R45683:45683 proof <> n var
R45681:45681 proof <> c var
R45687:45690 Coq.Init.Datatypes <> Some constr
R45693:45697 proof <> Write constr
R45702:45705 proof <> wval var
R45699:45700 proof <> ix var
R45729:45737 proof <> timepoint syndef
R45746:45749 Coq.Init.Logic <> :type_scope:x_'->'_x not
R45770:45778 Coq.Init.Logic <> :type_scope:x_'->'_x not
R45779:45786 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45795:45797 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45790:45794 proof <> write ind
R45822:45825 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45813:45815 Coq.Init.Logic <> :type_scope:x_'='_x not
R45798:45808 proof <> getWriteAt' def
R45812:45812 proof <> t var
R45810:45810 proof <> c var
R45816:45819 Coq.Init.Datatypes <> Some constr
R45821:45821 proof <> w var
R45835:45838 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R45826:45832 proof <> writeIx def
R45834:45834 proof <> w var
R45839:45840 proof <> ix var
R45750:45765 proof <> commandIxInRange def
R45769:45769 proof <> t var
R45767:45767 proof <> c var
R45742:45744 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R45741:45741 proof <> t var
R45745:45745 proof <> n var
R45862:45868 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45855:45857 Coq.Init.Logic <> :type_scope:x_'='_x not
R45849:45854 proof <> latest var
R45858:45861 Coq.Init.Datatypes <> None constr
R45880:45888 proof <> timepoint syndef
R45917:45925 Coq.Init.Logic <> :type_scope:x_'->'_x not
R45926:45933 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45942:45944 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45937:45941 proof <> write ind
R45969:45972 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45960:45962 Coq.Init.Logic <> :type_scope:x_'='_x not
R45945:45955 proof <> getWriteAt' def
R45959:45959 proof <> t var
R45957:45957 proof <> c var
R45963:45966 Coq.Init.Datatypes <> Some constr
R45968:45968 proof <> w var
R45982:45985 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R45973:45979 proof <> writeIx def
R45981:45981 proof <> w var
R45986:45987 proof <> ix var
R45897:45912 proof <> commandIxInRange def
R45916:45916 proof <> t var
R45914:45914 proof <> c var
prf 46022:46066 <> emptyDependenceSetWillHaveSingleAliasingWrite
R46082:46084 proof <> com ind
R46092:46096 proof <> memix syndef
R46104:46107 Coq.Init.Datatypes <> list ind
R46109:46117 proof <> timepoint syndef
R46157:46164 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46199:46206 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46207:46207 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46264:46268 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46208:46215 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46228:46238 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46219:46227 proof <> timepoint syndef
R46241:46243 Coq.Init.Logic <> :type_scope:x_'='_x not
R46239:46240 proof <> lt var
R46244:46252 Coq.Lists.List <> cons syndef
R46256:46263 Coq.Lists.List <> nil syndef
R46254:46254 proof <> t var
R46271:46273 Coq.Init.Logic <> :type_scope:x_'='_x not
R46269:46270 proof <> lt var
R46274:46281 Coq.Lists.List <> nil syndef
R46165:46190 proof <> aliasingWriteTimepointsSet def
R46197:46198 proof <> lt var
R46194:46195 proof <> ix var
R46192:46192 proof <> c var
R46125:46145 proof <> completeDependenceSet def
R46149:46156 Coq.Lists.List <> nil syndef
R46147:46147 proof <> c var
R46303:46328 proof <> aliasingWriteTimepointsSet def
R46361:46364 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46356:46359 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R46347:46352 Coq.Init.Datatypes <> length def
R46374:46377 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R46365:46370 Coq.Init.Datatypes <> length def
R46361:46364 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46356:46359 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R46347:46352 Coq.Init.Datatypes <> length def
R46374:46377 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R46365:46370 Coq.Init.Datatypes <> length def
R46478:46481 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46474:46476 Coq.Init.Logic <> :type_scope:x_'='_x not
R46465:46470 Coq.Init.Datatypes <> length def
R46491:46493 Coq.Init.Logic <> :type_scope:x_'='_x not
R46482:46487 Coq.Init.Datatypes <> length def
R46478:46481 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46474:46476 Coq.Init.Logic <> :type_scope:x_'='_x not
R46465:46470 Coq.Init.Datatypes <> length def
R46491:46493 Coq.Init.Logic <> :type_scope:x_'='_x not
R46482:46487 Coq.Init.Datatypes <> length def
R46584:46586 Coq.Init.Logic <> :type_scope:x_'='_x not
R46587:46594 Coq.Lists.List <> nil syndef
R46584:46586 Coq.Init.Logic <> :type_scope:x_'='_x not
R46587:46594 Coq.Lists.List <> nil syndef
R46615:46633 Coq.Lists.List <> length_zero_iff_nil thm
R46615:46633 Coq.Lists.List <> length_zero_iff_nil thm
R46615:46633 Coq.Lists.List <> length_zero_iff_nil thm
R46725:46755 proof <> list_length_1_implies_singleton thm
R46725:46755 proof <> list_length_1_implies_singleton thm
R46873:46913 proof <> list_length_gt_2_implies_at_least_2_elems thm
R46873:46913 proof <> list_length_gt_2_implies_at_least_2_elems thm
R46985:46991 Coq.Lists.List <> In def
R46985:46991 Coq.Lists.List <> In def
R47033:47037 Coq.Lists.List <> in_eq thm
R47033:47037 Coq.Lists.List <> in_eq thm
R47052:47058 Coq.Lists.List <> In def
R47052:47058 Coq.Lists.List <> In def
R47107:47113 Coq.Lists.List <> In def
R47164:47167 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R47159:47161 Coq.Init.Logic <> :type_scope:x_'='_x not
R47169:47172 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R47164:47167 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R47159:47161 Coq.Init.Logic <> :type_scope:x_'='_x not
R47169:47172 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R47355:47373 Coq.Lists.List <> NoDup_cons_iff thm
R47355:47373 Coq.Lists.List <> NoDup_cons_iff thm
R47355:47373 Coq.Lists.List <> NoDup_cons_iff thm
R47415:47421 Coq.Lists.List <> In def
R47429:47432 Coq.Init.Datatypes <> :list_scope:x_'::'_x not
R47415:47421 Coq.Lists.List <> In def
R47429:47432 Coq.Init.Datatypes <> :list_scope:x_'::'_x not
R47446:47452 Coq.Lists.List <> In def
R47644:47661 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R47624:47639 proof <> commandIxInRange def
R47662:47669 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47684:47686 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47676:47683 proof <> memvalue syndef
R47702:47704 Coq.Init.Logic <> :type_scope:x_'='_x not
R47687:47697 proof <> getWriteAt' def
R47705:47708 Coq.Init.Datatypes <> Some constr
R47711:47715 proof <> Write constr
R47720:47723 proof <> wval var
R47644:47661 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R47624:47639 proof <> commandIxInRange def
R47662:47669 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47684:47686 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47676:47683 proof <> memvalue syndef
R47702:47704 Coq.Init.Logic <> :type_scope:x_'='_x not
R47687:47697 proof <> getWriteAt' def
R47705:47708 Coq.Init.Datatypes <> Some constr
R47711:47715 proof <> Write constr
R47720:47723 proof <> wval var
R47791:47808 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R47770:47785 proof <> commandIxInRange def
R47809:47816 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47831:47833 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47823:47830 proof <> memvalue syndef
R47850:47852 Coq.Init.Logic <> :type_scope:x_'='_x not
R47834:47844 proof <> getWriteAt' def
R47853:47856 Coq.Init.Datatypes <> Some constr
R47859:47863 proof <> Write constr
R47868:47871 proof <> wval var
R47791:47808 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R47770:47785 proof <> commandIxInRange def
R47809:47816 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47831:47833 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47823:47830 proof <> memvalue syndef
R47850:47852 Coq.Init.Logic <> :type_scope:x_'='_x not
R47834:47844 proof <> getWriteAt' def
R47853:47856 Coq.Init.Datatypes <> Some constr
R47859:47863 proof <> Write constr
R47868:47871 proof <> wval var
R47996:48003 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48015:48034 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48010:48014 proof <> write ind
R48059:48079 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48050:48052 Coq.Init.Logic <> :type_scope:x_'='_x not
R48035:48045 proof <> getWriteAt' def
R48053:48056 Coq.Init.Datatypes <> Some constr
R48058:48058 proof <> w var
R48106:48126 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48096:48098 Coq.Init.Logic <> :type_scope:x_'='_x not
R48080:48090 proof <> getWriteAt' def
R48099:48102 Coq.Init.Datatypes <> Some constr
R48104:48105 proof <> w' var
R48136:48139 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R48127:48133 proof <> writeIx def
R48135:48135 proof <> w var
R48140:48146 proof <> writeIx def
R48148:48149 proof <> w' var
R47996:48003 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48015:48034 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48010:48014 proof <> write ind
R48059:48079 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48050:48052 Coq.Init.Logic <> :type_scope:x_'='_x not
R48035:48045 proof <> getWriteAt' def
R48053:48056 Coq.Init.Datatypes <> Some constr
R48058:48058 proof <> w var
R48106:48126 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48096:48098 Coq.Init.Logic <> :type_scope:x_'='_x not
R48080:48090 proof <> getWriteAt' def
R48099:48102 Coq.Init.Datatypes <> Some constr
R48104:48105 proof <> w' var
R48136:48139 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R48127:48133 proof <> writeIx def
R48135:48135 proof <> w var
R48140:48146 proof <> writeIx def
R48148:48149 proof <> w' var
R48166:48201 proof <> emptyDependenceSetImpliesNoAliasing' thm
R48166:48201 proof <> emptyDependenceSetImpliesNoAliasing' thm
def 48608:48635 <> applyScheduleToDependenceSet
R48644:48647 Coq.Init.Logic <> :type_scope:x_'->'_x not
R48648:48650 Coq.Init.Datatypes <> nat ind
R48641:48643 Coq.Init.Datatypes <> nat ind
R48658:48670 proof <> dependenceset def
R48675:48687 proof <> dependenceset def
R48694:48701 Coq.Lists.List <> map def
R48733:48734 proof <> ds var
R48704:48728 proof <> applyScheduleToDependence def
R48730:48730 proof <> s var
prf 48838:48882 <> dependenceAliasesTransportAcrossValidSchedule
R48901:48903 proof <> com ind
R48918:48921 Coq.Init.Logic <> :type_scope:x_'->'_x not
R48922:48924 Coq.Init.Datatypes <> nat ind
R48915:48917 Coq.Init.Datatypes <> nat ind
R48931:48940 proof <> dependence def
R48982:48989 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49012:49019 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49041:49049 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49050:49067 proof <> dependenceAliases' def
R49101:49102 proof <> c' var
R49070:49094 proof <> applyScheduleToDependence def
R49098:49098 proof <> d var
R49096:49096 proof <> s var
R49020:49036 proof <> dependenceInRange def
R49040:49040 proof <> c var
R49038:49038 proof <> d var
R48990:49007 proof <> dependenceAliases' def
R49011:49011 proof <> c var
R49009:49009 proof <> d var
R48948:48969 proof <> scheduleMappingWitness def
R48980:48981 proof <> c' var
R48978:48978 proof <> c var
R48973:48976 proof <> sinv var
R48971:48971 proof <> s var
R49121:49138 proof <> dependenceAliases' def
R49206:49227 proof <> scheduleMappingWitness def
R49247:49257 proof <> getWriteAt' def
R49247:49257 proof <> getWriteAt' def
R49289:49299 proof <> getWriteAt' def
R49289:49299 proof <> getWriteAt' def
R49360:49370 proof <> getWriteAt' def
R49360:49370 proof <> getWriteAt' def
R49409:49419 proof <> getWriteAt' def
R49409:49419 proof <> getWriteAt' def
R49479:49481 Coq.Init.Logic <> :type_scope:x_'='_x not
R49459:49469 proof <> getWriteAt' def
R49482:49492 proof <> getWriteAt' def
R49479:49481 Coq.Init.Logic <> :type_scope:x_'='_x not
R49459:49469 proof <> getWriteAt' def
R49482:49492 proof <> getWriteAt' def
R49537:49540 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R49532:49535 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R49542:49545 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R49546:49551 proof <> comlen def
R49537:49540 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R49532:49535 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R49542:49545 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R49546:49551 proof <> comlen def
R49578:49594 proof <> dependenceInRange def
R49610:49625 proof <> commandIxInRange def
R49769:49771 Coq.Init.Logic <> :type_scope:x_'='_x not
R49748:49758 proof <> getWriteAt' def
R49772:49782 proof <> getWriteAt' def
R49769:49771 Coq.Init.Logic <> :type_scope:x_'='_x not
R49748:49758 proof <> getWriteAt' def
R49772:49782 proof <> getWriteAt' def
R49826:49829 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R49821:49824 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R49832:49835 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R49836:49841 proof <> comlen def
R49826:49829 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R49821:49824 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R49832:49835 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R49836:49841 proof <> comlen def
R49854:49870 proof <> dependenceInRange def
R49886:49901 proof <> commandIxInRange def
prf 50037:50081 <> dependenceInRangeTransportAcrossValidSchedule
R50100:50102 proof <> com ind
R50117:50120 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50121:50123 Coq.Init.Datatypes <> nat ind
R50114:50116 Coq.Init.Datatypes <> nat ind
R50130:50139 proof <> dependence def
R50181:50188 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50210:50218 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50219:50235 proof <> dependenceInRange def
R50269:50270 proof <> c' var
R50238:50262 proof <> applyScheduleToDependence def
R50266:50266 proof <> d var
R50264:50264 proof <> s var
R50189:50205 proof <> dependenceInRange def
R50209:50209 proof <> c var
R50207:50207 proof <> d var
R50147:50168 proof <> scheduleMappingWitness def
R50179:50180 proof <> c' var
R50177:50177 proof <> c var
R50172:50175 proof <> sinv var
R50170:50170 proof <> s var
R50289:50305 proof <> dependenceInRange def
R50317:50338 proof <> scheduleMappingWitness def
R50350:50374 proof <> applyScheduleToDependence def
R50386:50401 proof <> commandIxInRange def
R50488:50491 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R50484:50486 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R50493:50496 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R50497:50502 proof <> comlen def
R50488:50491 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R50484:50486 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R50493:50496 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R50497:50502 proof <> comlen def
prf 50649:50697 <> dependenceLexPositiveTransportAcrossValidSchedule
R50713:50715 proof <> com ind
R50725:50728 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50729:50731 Coq.Init.Datatypes <> nat ind
R50722:50724 Coq.Init.Datatypes <> nat ind
R50738:50747 proof <> dependence def
R50755:50767 proof <> dependenceset def
R50801:50808 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50843:50850 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50874:50881 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50904:50911 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50933:50941 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50942:50962 proof <> dependenceLexPositive def
R50965:50989 proof <> applyScheduleToDependence def
R50993:50993 proof <> d var
R50991:50991 proof <> s var
R50912:50928 proof <> dependenceInRange def
R50932:50932 proof <> c var
R50930:50930 proof <> d var
R50882:50899 proof <> dependenceAliases' def
R50903:50903 proof <> c var
R50901:50901 proof <> d var
R50851:50871 proof <> dependenceLexPositive def
R50873:50873 proof <> d var
R50809:50837 proof <> scheduleRespectsDependenceSet def
R50841:50842 proof <> ds var
R50839:50839 proof <> s var
R50775:50795 proof <> completeDependenceSet def
R50799:50800 proof <> ds var
R50797:50797 proof <> c var
R51045:51045 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51047:51048 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51051:51051 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51045:51045 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51047:51048 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51051:51051 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51064:51084 proof <> completeDependenceSet def
R51101:51107 Coq.Lists.List <> In def
R51109:51109 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51111:51112 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51115:51115 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51101:51107 Coq.Lists.List <> In def
R51109:51109 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51111:51112 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51115:51115 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51153:51178 proof <> scheduleRespectsDependence def
prf 51227:51277 <> dependenceLexPositiveTransportAcrossValidSchedule''
R51296:51298 proof <> com ind
R51313:51316 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51317:51319 Coq.Init.Datatypes <> nat ind
R51310:51312 Coq.Init.Datatypes <> nat ind
R51326:51335 proof <> dependence def
R51343:51355 proof <> dependenceset def
R51389:51397 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51432:51439 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51474:51481 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51504:51511 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51533:51540 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51564:51571 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51572:51592 proof <> dependenceLexPositive def
R51595:51619 proof <> applyScheduleToDependence def
R51623:51623 proof <> d var
R51621:51621 proof <> s var
R51541:51561 proof <> dependenceLexPositive def
R51563:51563 proof <> d var
R51512:51528 proof <> dependenceInRange def
R51532:51532 proof <> c var
R51530:51530 proof <> d var
R51482:51499 proof <> dependenceAliases' def
R51503:51503 proof <> c var
R51501:51501 proof <> d var
R51440:51468 proof <> scheduleRespectsDependenceSet def
R51472:51473 proof <> ds var
R51470:51470 proof <> s var
R51398:51419 proof <> scheduleMappingWitness def
R51430:51431 proof <> c' var
R51428:51428 proof <> c var
R51423:51426 proof <> sinv var
R51421:51421 proof <> s var
R51363:51383 proof <> completeDependenceSet def
R51387:51388 proof <> ds var
R51385:51385 proof <> c var
R51842:51845 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R51833:51835 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R51863:51866 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R51854:51856 Coq.Init.Logic <> :type_scope:x_'='_x not
R51875:51877 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R51842:51845 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R51833:51835 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R51863:51866 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R51854:51856 Coq.Init.Logic <> :type_scope:x_'='_x not
R51875:51877 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R52246:52248 Coq.Init.Logic <> :type_scope:x_'='_x not
R52246:52248 Coq.Init.Logic <> :type_scope:x_'='_x not
R52305:52307 Coq.Init.Logic <> :type_scope:x_'='_x not
R52305:52307 Coq.Init.Logic <> :type_scope:x_'='_x not
R52333:52354 proof <> scheduleMappingWitness def
R52420:52429 Coq.Logic.ExtensionalityFacts <> is_inverse def
R52536:52556 proof <> dependenceLexPositive def
R52609:52612 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R52602:52604 Coq.Init.Logic <> :type_scope:x_'='_x not
R52619:52621 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R52609:52612 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R52602:52604 Coq.Init.Logic <> :type_scope:x_'='_x not
R52619:52621 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R52917:52945 proof <> scheduleRespectsDependenceSet def
R52973:52998 proof <> scheduleRespectsDependence def
R53002:53002 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53009:53010 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53015:53015 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R52973:52998 proof <> scheduleRespectsDependence def
R53002:53002 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53009:53010 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53015:53015 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53093:53093 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53100:53101 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53106:53106 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53093:53093 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53100:53101 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53106:53106 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53135:53155 proof <> completeDependenceSet def
R53197:53211 proof <> validDependence def
R53237:53262 proof <> scheduleRespectsDependence def
R53304:53324 proof <> dependenceLexPositive def
R53366:53390 proof <> applyScheduleToDependence def
R53489:53492 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R53480:53482 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R53501:53503 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R53489:53492 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R53480:53482 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R53501:53503 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R53629:53657 proof <> scheduleRespectsDependenceSet def
R53687:53703 proof <> dependenceInRange def
R53729:53744 proof <> commandIxInRange def
prf 53807:53826 <> is_inverse_injective
R53851:53854 Coq.Init.Logic <> :type_scope:x_'->'_x not
R53855:53855 proof <> B var
R53850:53850 proof <> A var
R53863:53866 Coq.Init.Logic <> :type_scope:x_'->'_x not
R53867:53867 proof <> A var
R53862:53862 proof <> B var
R53876:53876 proof <> A var
R53894:53897 Coq.Init.Logic <> :type_scope:x_'->'_x not
R53907:53910 Coq.Init.Logic <> :type_scope:x_'->'_x not
R53912:53914 Coq.Init.Logic <> :type_scope:x_'='_x not
R53911:53911 proof <> a var
R53915:53915 proof <> b var
R53901:53903 Coq.Init.Logic <> :type_scope:x_'='_x not
R53898:53898 proof <> f var
R53900:53900 proof <> a var
R53904:53904 proof <> f var
R53906:53906 proof <> b var
R53880:53889 Coq.Logic.ExtensionalityFacts <> is_inverse def
R53893:53893 proof <> g var
R53891:53891 proof <> f var
R53952:53954 Coq.Init.Logic <> :type_scope:x_'='_x not
R53952:53954 Coq.Init.Logic <> :type_scope:x_'='_x not
R54010:54019 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54047:54049 Coq.Init.Logic <> :type_scope:x_'='_x not
R54047:54049 Coq.Init.Logic <> :type_scope:x_'='_x not
R54068:54070 Coq.Init.Logic <> :type_scope:x_'='_x not
R54068:54070 Coq.Init.Logic <> :type_scope:x_'='_x not
prf 54161:54180 <> is_inverse_symmetric
R54205:54208 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54209:54209 proof <> B var
R54204:54204 proof <> A var
R54217:54220 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54221:54221 proof <> A var
R54216:54216 proof <> B var
R54239:54242 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54243:54252 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54256:54256 proof <> f var
R54254:54254 proof <> g var
R54225:54234 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54238:54238 proof <> g var
R54236:54236 proof <> f var
R54285:54294 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 54564:54604 <> dependenceSetTransportAcrossValidSchedule
R54623:54625 proof <> com ind
R54640:54643 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54644:54646 Coq.Init.Datatypes <> nat ind
R54637:54639 Coq.Init.Datatypes <> nat ind
R54654:54666 proof <> dependenceset def
R54700:54707 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54742:54749 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54784:54791 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54792:54812 proof <> completeDependenceSet def
R54818:54845 proof <> applyScheduleToDependenceSet def
R54849:54850 proof <> ds var
R54847:54847 proof <> s var
R54814:54815 proof <> c' var
R54750:54778 proof <> scheduleRespectsDependenceSet def
R54782:54783 proof <> ds var
R54780:54780 proof <> s var
R54708:54729 proof <> scheduleMappingWitness def
R54740:54741 proof <> c' var
R54738:54738 proof <> c var
R54733:54736 proof <> sinv var
R54731:54731 proof <> s var
R54674:54694 proof <> completeDependenceSet def
R54698:54699 proof <> ds var
R54696:54696 proof <> c var
R54883:54904 proof <> scheduleMappingWitness def
R54883:54904 proof <> scheduleMappingWitness def
R54941:54971 proof <> scheduleMappingWitnessSymmetric thm
R54941:54971 proof <> scheduleMappingWitnessSymmetric thm
R54995:55015 proof <> completeDependenceSet def
R55073:55087 proof <> validDependence def
R55180:55207 proof <> applyScheduleToDependenceSet def
R55217:55241 proof <> applyScheduleToDependence def
R55254:55268 Coq.Lists.List <> in_map_iff thm
R55254:55268 Coq.Lists.List <> in_map_iff thm
R55254:55268 Coq.Lists.List <> in_map_iff thm
R55281:55305 proof <> applyScheduleToDependence def
R55281:55305 proof <> applyScheduleToDependence def
R55351:55375 proof <> applyScheduleToDependence def
R55399:55401 Coq.Init.Datatypes <> nat ind
R55415:55417 Coq.Init.Logic <> :type_scope:x_'='_x not
R55413:55413 proof <> n var
R55418:55418 proof <> n var
R55399:55401 Coq.Init.Datatypes <> nat ind
R55415:55417 Coq.Init.Logic <> :type_scope:x_'='_x not
R55413:55413 proof <> n var
R55418:55418 proof <> n var
R55429:55450 proof <> scheduleMappingWitness def
R55477:55486 Coq.Logic.ExtensionalityFacts <> is_inverse def
R55540:55554 proof <> validDependence def
R55576:55620 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R55576:55620 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R55691:55735 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R55691:55735 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R55784:55801 proof <> dependenceAliases' def
R55804:55828 proof <> applyScheduleToDependence def
R55784:55801 proof <> dependenceAliases' def
R55804:55828 proof <> applyScheduleToDependence def
R55852:55896 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R55852:55896 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R56025:56028 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56013:56015 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56052:56055 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56040:56042 Coq.Init.Logic <> :type_scope:x_'='_x not
R56067:56069 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R56025:56028 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56013:56015 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56052:56055 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56040:56042 Coq.Init.Logic <> :type_scope:x_'='_x not
R56067:56069 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R56155:56175 proof <> dependenceLexPositive def
R56178:56202 proof <> applyScheduleToDependence def
R56281:56283 Coq.Init.Logic <> :type_scope:x_'='_x not
R56281:56283 Coq.Init.Logic <> :type_scope:x_'='_x not
R56300:56319 proof <> is_inverse_injective thm
R56300:56319 proof <> is_inverse_injective thm
R56331:56352 proof <> scheduleMappingWitness def
R56443:56463 proof <> dependenceLexPositive def
R56502:56505 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R56495:56497 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56512:56514 Coq.Init.Logic <> :type_scope:x_'='_x not
R56502:56505 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R56495:56497 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56512:56514 Coq.Init.Logic <> :type_scope:x_'='_x not
R56579:56585 Coq.Lists.List <> In def
R56588:56612 proof <> applyScheduleToDependence def
R56619:56619 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56624:56625 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56632:56632 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56579:56585 Coq.Lists.List <> In def
R56588:56612 proof <> applyScheduleToDependence def
R56619:56619 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56624:56625 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56632:56632 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56662:56682 proof <> completeDependenceSet def
R56746:56760 proof <> validDependence def
R56779:56823 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R56779:56823 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R56857:56883 proof <> dependenceAliases'Symmetric thm
R56857:56883 proof <> dependenceAliases'Symmetric thm
R56857:56883 proof <> dependenceAliases'Symmetric thm
R56904:56929 proof <> dependenceInRangeSymmetric thm
R56904:56929 proof <> dependenceInRangeSymmetric thm
R56904:56929 proof <> dependenceInRangeSymmetric thm
R56956:57000 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R56956:57000 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R57034:57059 proof <> dependenceInRangeSymmetric thm
R57034:57059 proof <> dependenceInRangeSymmetric thm
R57034:57059 proof <> dependenceInRangeSymmetric thm
R57078:57098 proof <> dependenceLexPositive def
R57279:57281 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57279:57281 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57302:57330 proof <> scheduleRespectsDependenceSet def
R57383:57408 proof <> scheduleRespectsDependence def
R57445:57465 proof <> dependenceLexPositive def
R57502:57523 proof <> scheduleMappingWitness def
R57593:57602 Coq.Logic.ExtensionalityFacts <> is_inverse def
R57672:57674 Coq.Init.Logic <> :type_scope:x_'='_x not
R57672:57674 Coq.Init.Logic <> :type_scope:x_'='_x not
R57706:57708 Coq.Init.Logic <> :type_scope:x_'='_x not
R57706:57708 Coq.Init.Logic <> :type_scope:x_'='_x not
R57864:57867 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R57855:57857 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57874:57876 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57864:57867 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R57855:57857 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57874:57876 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57905:57925 proof <> dependenceLexPositive def
R58139:58153 proof <> validDependence def
R58167:58194 proof <> applyScheduleToDependenceSet def
R58232:58246 Coq.Lists.List <> in_map_iff thm
R58232:58246 Coq.Lists.List <> in_map_iff thm
R58232:58246 Coq.Lists.List <> in_map_iff thm
R58402:58422 proof <> completeDependenceSet def
R58536:58550 proof <> validDependence def
R58617:58661 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R58617:58661 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R58751:58795 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R58751:58795 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R58835:58883 proof <> dependenceLexPositiveTransportAcrossValidSchedule thm
R58835:58883 proof <> dependenceLexPositiveTransportAcrossValidSchedule thm
prf 58954:58992 <> completeDependenceSetConsDestructOnCSeq
R59008:59010 proof <> com ind
R59019:59023 proof <> memix syndef
R59033:59040 proof <> memvalue syndef
R59066:59074 proof <> timepoint syndef
R59082:59094 proof <> dependenceset def
R59172:59179 Coq.Init.Logic <> :type_scope:x_'->'_x not
R59180:59180 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59282:59291 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59312:59312 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59200:59209 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R59281:59281 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R59185:59187 Coq.Init.Logic <> :type_scope:x_'='_x not
R59181:59184 proof <> tend var
R59196:59198 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59188:59193 proof <> comlen def
R59195:59195 proof <> c var
R59210:59217 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R59233:59235 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R59225:59232 proof <> memvalue syndef
R59256:59258 Coq.Init.Logic <> :type_scope:x_'='_x not
R59236:59246 proof <> getWriteAt' def
R59250:59255 proof <> tbegin var
R59248:59248 proof <> c var
R59259:59262 Coq.Init.Datatypes <> Some constr
R59265:59269 proof <> Write constr
R59275:59279 proof <> wval' var
R59271:59273 proof <> wix var
R59296:59299 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R59292:59295 proof <> tend var
R59308:59310 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59300:59305 proof <> comlen def
R59307:59307 proof <> c var
R59102:59122 proof <> completeDependenceSet def
R59165:59168 Coq.Init.Datatypes <> :list_scope:x_'::'_x not
R59151:59151 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59158:59159 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59164:59164 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59152:59157 proof <> tbegin var
R59160:59163 proof <> tend var
R59169:59170 proof <> ds var
R59125:59128 proof <> CSeq constr
R59133:59137 proof <> Write constr
R59143:59146 proof <> wval var
R59139:59141 proof <> wix var
R59130:59130 proof <> c var
R59402:59405 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59387:59389 Coq.Init.Logic <> :type_scope:x_'='_x not
R59398:59400 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59390:59395 proof <> comlen def
R59422:59425 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59410:59413 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R59414:59419 proof <> comlen def
R59430:59432 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R59441:59443 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59433:59438 proof <> comlen def
R59402:59405 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59387:59389 Coq.Init.Logic <> :type_scope:x_'='_x not
R59398:59400 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59390:59395 proof <> comlen def
R59422:59425 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59410:59413 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R59414:59419 proof <> comlen def
R59430:59432 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R59441:59443 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59433:59438 proof <> comlen def
R59601:59621 proof <> completeDependenceSet def
R59673:59673 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59680:59681 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59686:59686 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59673:59673 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59680:59681 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59686:59686 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59750:59764 proof <> validDependence def
R59792:59792 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59799:59800 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59805:59805 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59767:59770 proof <> CSeq constr
R59775:59779 proof <> Write constr
R59750:59764 proof <> validDependence def
R59792:59792 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59799:59800 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59805:59805 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59767:59770 proof <> CSeq constr
R59775:59779 proof <> Write constr
R59857:59863 Coq.Lists.List <> In def
R59896:59910 proof <> validDependence def
R60001:60008 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60016:60018 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60011:60015 proof <> write ind
R60039:60041 Coq.Init.Logic <> :type_scope:x_'='_x not
R60019:60029 proof <> getWriteAt' def
R60042:60045 Coq.Init.Datatypes <> Some constr
R60047:60047 proof <> w var
R60001:60008 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60016:60018 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60011:60015 proof <> write ind
R60039:60041 Coq.Init.Logic <> :type_scope:x_'='_x not
R60019:60029 proof <> getWriteAt' def
R60042:60045 Coq.Init.Datatypes <> Some constr
R60047:60047 proof <> w var
R60080:60103 proof <> getWriteAt'RangeComplete thm
R60080:60103 proof <> getWriteAt'RangeComplete thm
R60117:60133 proof <> dependenceInRange def
R60135:60150 proof <> commandIxInRange def
R60153:60158 proof <> comlen def
R60184:60189 proof <> comlen def
R60184:60189 proof <> comlen def
R60296:60316 proof <> dependenceLexPositive def
R60513:60530 proof <> dependenceAliases' def
R60600:60602 Coq.Init.Logic <> :type_scope:x_'='_x not
R60585:60588 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60589:60589 Coq.Init.Datatypes <> S constr
R60591:60596 proof <> comlen def
R60603:60607 Coq.Init.Datatypes <> false constr
R60600:60602 Coq.Init.Logic <> :type_scope:x_'='_x not
R60585:60588 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60589:60589 Coq.Init.Datatypes <> S constr
R60591:60596 proof <> comlen def
R60603:60607 Coq.Init.Datatypes <> false constr
R60639:60641 Coq.Init.Logic <> :type_scope:x_'='_x not
R60624:60627 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60628:60628 Coq.Init.Datatypes <> S constr
R60630:60635 proof <> comlen def
R60642:60645 Coq.Init.Datatypes <> true constr
R60639:60641 Coq.Init.Logic <> :type_scope:x_'='_x not
R60624:60627 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60628:60628 Coq.Init.Datatypes <> S constr
R60630:60635 proof <> comlen def
R60642:60645 Coq.Init.Datatypes <> true constr
R60919:60928 Coq.Arith.PeanoNat Nat eqb_eq thm
R60919:60928 Coq.Arith.PeanoNat Nat eqb_eq thm
R60919:60928 Coq.Arith.PeanoNat Nat eqb_eq thm
R60938:60954 proof <> dependenceInRange def
R60957:60972 proof <> commandIxInRange def
R60975:60995 proof <> dependenceLexPositive def
R61075:61085 Coq.Arith.PeanoNat Nat eqb_neq thm
R61075:61085 Coq.Arith.PeanoNat Nat eqb_neq thm
R61075:61085 Coq.Arith.PeanoNat Nat eqb_neq thm
R61095:61111 proof <> dependenceInRange def
R61114:61129 proof <> commandIxInRange def
R61132:61152 proof <> dependenceLexPositive def
prf 61256:61301 <> latestAliasingWriteTimepointSpecDestructOnCSeq
R61317:61319 proof <> com ind
R61332:61336 proof <> write ind
R61348:61352 proof <> memix syndef
R61374:61382 proof <> timepoint syndef
R61470:61477 Coq.Init.Logic <> :type_scope:x_'->'_x not
R61510:61517 Coq.Init.Logic <> :type_scope:x_'->'_x not
R61518:61549 proof <> latestAliasingWriteTimepointSpec def
R61561:61564 Coq.Init.Datatypes <> Some constr
R61566:61581 proof <> latest_aliasingt var
R61553:61558 proof <> readix var
R61551:61551 proof <> c var
R61494:61497 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R61478:61493 proof <> latest_aliasingt var
R61506:61508 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R61498:61503 proof <> comlen def
R61505:61505 proof <> c var
R61390:61421 proof <> latestAliasingWriteTimepointSpec def
R61448:61451 Coq.Init.Datatypes <> Some constr
R61453:61468 proof <> latest_aliasingt var
R61440:61445 proof <> readix var
R61424:61427 proof <> CSeq constr
R61431:61437 proof <> latestw var
R61429:61429 proof <> c var
R61611:61642 proof <> latestAliasingWriteTimepointSpec def
R61654:61685 proof <> latestAliasingWriteTimepointSpec def
R61883:61898 proof <> commandIxInRange def
R61917:61922 proof <> comlen def
R61935:61940 proof <> comlen def
R61935:61940 proof <> comlen def
R62058:62060 Coq.Init.Logic <> :type_scope:x_'='_x not
R62028:62038 proof <> getWriteAt' def
R62041:62044 proof <> CSeq constr
R62061:62071 proof <> getWriteAt' def
R62058:62060 Coq.Init.Logic <> :type_scope:x_'='_x not
R62028:62038 proof <> getWriteAt' def
R62041:62044 proof <> CSeq constr
R62061:62071 proof <> getWriteAt' def
R62180:62204 proof <> getWriteAt'DestructOnCSeq thm
R62180:62204 proof <> getWriteAt'DestructOnCSeq thm
R62180:62204 proof <> getWriteAt'DestructOnCSeq thm
R62180:62204 proof <> getWriteAt'DestructOnCSeq thm
R62239:62254 proof <> commandIxInRange def
R62270:62275 proof <> comlen def
R62289:62294 proof <> comlen def
R62289:62294 proof <> comlen def
R62359:62374 proof <> commandIxInRange def
R62377:62380 proof <> CSeq constr
R62359:62374 proof <> commandIxInRange def
R62377:62380 proof <> CSeq constr
R62620:62622 Coq.Init.Logic <> :type_scope:x_'='_x not
R62589:62599 proof <> getWriteAt' def
R62602:62605 proof <> CSeq constr
R62623:62633 proof <> getWriteAt' def
R62620:62622 Coq.Init.Logic <> :type_scope:x_'='_x not
R62589:62599 proof <> getWriteAt' def
R62602:62605 proof <> CSeq constr
R62623:62633 proof <> getWriteAt' def
R62652:62676 proof <> getWriteAt'DestructOnCSeq thm
R62652:62676 proof <> getWriteAt'DestructOnCSeq thm
R62690:62705 proof <> commandIxInRange def
R62785:62809 proof <> commandIxInRangeInclusive thm
R62785:62809 proof <> commandIxInRangeInclusive thm
prf 62883:62917 <> noLatestAliasingWriteDestructOnCSeq
R62933:62935 proof <> com ind
R62942:62946 proof <> write ind
R62958:62962 proof <> memix syndef
R63025:63032 Coq.Init.Logic <> :type_scope:x_'->'_x not
R63033:63064 proof <> latestAliasingWriteTimepointSpec def
R63075:63078 Coq.Init.Datatypes <> None constr
R63068:63073 proof <> readix var
R63066:63066 proof <> c var
R62970:63001 proof <> latestAliasingWriteTimepointSpec def
R63021:63024 Coq.Init.Datatypes <> None constr
R63014:63019 proof <> readix var
R63004:63007 proof <> CSeq constr
R63011:63011 proof <> w var
R63009:63009 proof <> c var
R63134:63165 proof <> latestAliasingWriteTimepointSpec def
R63245:63260 proof <> commandIxInRange def
R63263:63266 proof <> CSeq constr
R63245:63260 proof <> commandIxInRange def
R63263:63266 proof <> CSeq constr
R63310:63334 proof <> commandIxInRangeInclusive thm
R63310:63334 proof <> commandIxInRangeInclusive thm
R63389:63391 Coq.Init.Logic <> :type_scope:x_'='_x not
R63368:63378 proof <> getWriteAt' def
R63392:63402 proof <> getWriteAt' def
R63405:63408 proof <> CSeq constr
R63389:63391 Coq.Init.Logic <> :type_scope:x_'='_x not
R63368:63378 proof <> getWriteAt' def
R63392:63402 proof <> getWriteAt' def
R63405:63408 proof <> CSeq constr
R63464:63488 proof <> getWriteAt'DestructOnCSeq thm
R63464:63488 proof <> getWriteAt'DestructOnCSeq thm
R63498:63513 proof <> commandIxInRange def
R63552:63559 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63571:63573 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63566:63570 proof <> write ind
R63604:63606 Coq.Init.Logic <> :type_scope:x_'='_x not
R63574:63584 proof <> getWriteAt' def
R63587:63590 proof <> CSeq constr
R63607:63610 Coq.Init.Datatypes <> Some constr
R63612:63614 proof <> w_t var
R63552:63559 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63571:63573 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63566:63570 proof <> write ind
R63604:63606 Coq.Init.Logic <> :type_scope:x_'='_x not
R63574:63584 proof <> getWriteAt' def
R63587:63590 proof <> CSeq constr
R63607:63610 Coq.Init.Datatypes <> Some constr
R63612:63614 proof <> w_t var
R63650:63673 proof <> getWriteAt'RangeComplete thm
R63676:63679 proof <> CSeq constr
R63650:63673 proof <> getWriteAt'RangeComplete thm
R63676:63679 proof <> CSeq constr
R63755:63770 proof <> commandIxInRange def
R63798:63803 proof <> comlen def
R63811:63816 proof <> comlen def
R63811:63816 proof <> comlen def
R64011:64042 proof <> latestAliasingWriteTimepointSpec def
R64218:64221 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R64199:64205 proof <> writeIx def
R64218:64221 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R64199:64205 proof <> writeIx def
R64353:64355 Coq.Init.Logic <> :type_scope:x_'='_x not
R64353:64355 Coq.Init.Logic <> :type_scope:x_'='_x not
prf 64493:64531 <> noLatestAliasingWriteAllowsPunchthrough
R64545:64547 proof <> com ind
R64559:64563 proof <> memix syndef
R64577:64582 proof <> memory def
R64636:64643 Coq.Init.Logic <> :type_scope:x_'->'_x not
R64671:64674 Coq.Init.Logic <> :type_scope:x_'='_x not
R64689:64689 Coq.Init.Logic <> :type_scope:x_'='_x not
R64644:64653 proof <> runProgram def
R64665:64670 proof <> readix var
R64657:64663 proof <> initmem var
R64655:64655 proof <> c var
R64675:64681 proof <> initmem var
R64683:64688 proof <> readix var
R64590:64621 proof <> latestAliasingWriteTimepointSpec def
R64632:64635 Coq.Init.Datatypes <> None constr
R64625:64630 proof <> readix var
R64623:64623 proof <> c var
R64774:64805 proof <> latestAliasingWriteTimepointSpec def
R64816:64819 Coq.Init.Datatypes <> None constr
R64774:64805 proof <> latestAliasingWriteTimepointSpec def
R64816:64819 Coq.Init.Datatypes <> None constr
R64846:64880 proof <> noLatestAliasingWriteDestructOnCSeq thm
R64846:64880 proof <> noLatestAliasingWriteDestructOnCSeq thm
R64957:64960 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R64948:64950 Coq.Init.Logic <> :type_scope:x_'='_x not
R64964:64967 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R64957:64960 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R64948:64950 Coq.Init.Logic <> :type_scope:x_'='_x not
R64964:64967 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65158:65161 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65158:65161 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65180:65211 proof <> latestAliasingWriteTimepointSpec def
R65371:65373 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65363:65368 proof <> comlen def
R65371:65373 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65363:65368 proof <> comlen def
R65391:65406 proof <> commandIxInRange def
R65443:65445 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65435:65440 proof <> comlen def
R65409:65412 proof <> CSeq constr
R65417:65421 proof <> Write constr
R65391:65406 proof <> commandIxInRange def
R65443:65445 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65435:65440 proof <> comlen def
R65409:65412 proof <> CSeq constr
R65417:65421 proof <> Write constr
R65473:65488 proof <> commandIxInRange def
R65491:65496 proof <> comlen def
R65504:65509 proof <> comlen def
R65504:65509 proof <> comlen def
R65639:65641 Coq.Init.Logic <> :type_scope:x_'='_x not
R65624:65627 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R65620:65622 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65612:65617 proof <> comlen def
R65628:65628 Coq.Init.Datatypes <> S constr
R65630:65635 proof <> comlen def
R65642:65645 Coq.Init.Datatypes <> true constr
R65639:65641 Coq.Init.Logic <> :type_scope:x_'='_x not
R65624:65627 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R65620:65622 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65612:65617 proof <> comlen def
R65628:65628 Coq.Init.Datatypes <> S constr
R65630:65635 proof <> comlen def
R65642:65645 Coq.Init.Datatypes <> true constr
R65672:65681 Coq.Arith.PeanoNat Nat eqb_eq thm
R65672:65681 Coq.Arith.PeanoNat Nat eqb_eq thm
R65672:65681 Coq.Arith.PeanoNat Nat eqb_eq thm
R65837:65840 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R65828:65830 Coq.Init.Logic <> :type_scope:x_'='_x not
R65844:65847 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65837:65840 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R65828:65830 Coq.Init.Logic <> :type_scope:x_'='_x not
R65844:65847 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65931:65940 proof <> runProgram def
R65952:65961 proof <> runProgram def
R65952:65961 proof <> runProgram def
R65975:65988 proof <> writeToMemory' def
R66003:66024 proof <> readFromWriteDifferent thm
R66003:66024 proof <> readFromWriteDifferent thm
R66003:66024 proof <> readFromWriteDifferent thm
R66003:66024 proof <> readFromWriteDifferent thm
R66120:66129 proof <> runProgram def
prf 66178:66207 <> latestAliasingWriteWillBeValue
R66221:66223 proof <> com ind
R66235:66239 proof <> memix syndef
R66254:66262 proof <> timepoint syndef
R66272:66279 proof <> memvalue syndef
R66292:66297 proof <> memory def
R66363:66370 Coq.Init.Logic <> :type_scope:x_'->'_x not
R66371:66371 Coq.Init.Logic <> :type_scope:x_'->'_x not
R66423:66431 Coq.Init.Logic <> :type_scope:x_'->'_x not
R66459:66461 Coq.Init.Logic <> :type_scope:x_'='_x not
R66432:66441 proof <> runProgram def
R66453:66458 proof <> readix var
R66445:66451 proof <> initmem var
R66443:66443 proof <> c var
R66462:66465 proof <> wval var
R66396:66398 Coq.Init.Logic <> :type_scope:x_'='_x not
R66372:66382 proof <> getWriteAt' def
R66387:66395 proof <> aliasingt var
R66384:66384 proof <> c var
R66399:66402 Coq.Init.Datatypes <> Some constr
R66405:66409 proof <> Write constr
R66418:66421 proof <> wval var
R66411:66416 proof <> readix var
R66305:66336 proof <> latestAliasingWriteTimepointSpec def
R66348:66351 Coq.Init.Datatypes <> Some constr
R66353:66361 proof <> aliasingt var
R66340:66345 proof <> readix var
R66338:66338 proof <> c var
R66624:66627 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R66610:66612 Coq.Init.Logic <> :type_scope:x_'='_x not
R66613:66613 Coq.Init.Datatypes <> S constr
R66615:66620 proof <> comlen def
R66637:66639 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R66640:66640 Coq.Init.Datatypes <> S constr
R66643:66648 proof <> comlen def
R66624:66627 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R66610:66612 Coq.Init.Logic <> :type_scope:x_'='_x not
R66613:66613 Coq.Init.Datatypes <> S constr
R66615:66620 proof <> comlen def
R66637:66639 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R66640:66640 Coq.Init.Datatypes <> S constr
R66643:66648 proof <> comlen def
R66665:66690 proof <> getWriteAt'RangeConsistent thm
R66665:66690 proof <> getWriteAt'RangeConsistent thm
R66722:66727 proof <> comlen def
R66753:66758 proof <> comlen def
R66753:66758 proof <> comlen def
R66960:66962 Coq.Init.Logic <> :type_scope:x_'='_x not
R66963:66967 proof <> Write constr
R66960:66962 Coq.Init.Logic <> :type_scope:x_'='_x not
R66963:66967 proof <> Write constr
R66994:67004 proof <> getWriteAt' def
R67036:67041 proof <> comlen def
R67067:67072 proof <> comlen def
R67067:67072 proof <> comlen def
R67133:67135 Coq.Init.Logic <> :type_scope:x_'='_x not
R67117:67120 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R67105:67105 Coq.Init.Datatypes <> S constr
R67108:67113 proof <> comlen def
R67122:67124 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R67125:67130 proof <> comlen def
R67136:67139 Coq.Init.Datatypes <> true constr
R67133:67135 Coq.Init.Logic <> :type_scope:x_'='_x not
R67117:67120 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R67105:67105 Coq.Init.Datatypes <> S constr
R67108:67113 proof <> comlen def
R67122:67124 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R67125:67130 proof <> comlen def
R67136:67139 Coq.Init.Datatypes <> true constr
R67177:67186 Coq.Arith.PeanoNat Nat eqb_eq thm
R67177:67186 Coq.Arith.PeanoNat Nat eqb_eq thm
R67177:67186 Coq.Arith.PeanoNat Nat eqb_eq thm
R67319:67328 proof <> runProgram def
R67336:67345 proof <> runProgram def
R67336:67345 proof <> runProgram def
R67359:67372 proof <> writeToMemory' def
R67385:67406 proof <> readFromWriteIdentical thm
R67385:67406 proof <> readFromWriteIdentical thm
R67521:67524 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67521:67524 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67568:67571 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R67558:67561 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67580:67582 Coq.Init.Logic <> :type_scope:x_'='_x not
R67568:67571 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R67558:67561 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67580:67582 Coq.Init.Logic <> :type_scope:x_'='_x not
R67717:67748 proof <> latestAliasingWriteTimepointSpec def
R67994:67994 Coq.Init.Datatypes <> S constr
R67997:68002 proof <> comlen def
R67994:67994 Coq.Init.Datatypes <> S constr
R67997:68002 proof <> comlen def
R68038:68040 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R68026:68026 Coq.Init.Datatypes <> S constr
R68029:68034 proof <> comlen def
R68038:68040 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R68026:68026 Coq.Init.Datatypes <> S constr
R68029:68034 proof <> comlen def
R68114:68129 proof <> commandIxInRange def
R68168:68168 Coq.Init.Datatypes <> S constr
R68171:68176 proof <> comlen def
R68132:68135 proof <> CSeq constr
R68140:68144 proof <> Write constr
R68114:68129 proof <> commandIxInRange def
R68168:68168 Coq.Init.Datatypes <> S constr
R68171:68176 proof <> comlen def
R68132:68135 proof <> CSeq constr
R68140:68144 proof <> Write constr
R68199:68214 proof <> commandIxInRange def
R68224:68229 proof <> comlen def
R68237:68242 proof <> comlen def
R68237:68242 proof <> comlen def
R68326:68336 proof <> getWriteAt' def
R68419:68421 Coq.Init.Logic <> :type_scope:x_'='_x not
R68373:68376 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R68361:68361 Coq.Init.Datatypes <> S constr
R68364:68369 proof <> comlen def
R68377:68382 proof <> comlen def
R68385:68388 proof <> CSeq constr
R68393:68397 proof <> Write constr
R68422:68425 Coq.Init.Datatypes <> true constr
R68419:68421 Coq.Init.Logic <> :type_scope:x_'='_x not
R68373:68376 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R68361:68361 Coq.Init.Datatypes <> S constr
R68364:68369 proof <> comlen def
R68377:68382 proof <> comlen def
R68385:68388 proof <> CSeq constr
R68393:68397 proof <> Write constr
R68422:68425 Coq.Init.Datatypes <> true constr
R68444:68449 proof <> comlen def
R68457:68462 proof <> comlen def
R68457:68462 proof <> comlen def
R68473:68482 Coq.Arith.PeanoNat Nat eqb_eq thm
R68473:68482 Coq.Arith.PeanoNat Nat eqb_eq thm
R68473:68482 Coq.Arith.PeanoNat Nat eqb_eq thm
R68716:68719 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R68706:68709 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R68728:68730 Coq.Init.Logic <> :type_scope:x_'='_x not
R68716:68719 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R68706:68709 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R68728:68730 Coq.Init.Logic <> :type_scope:x_'='_x not
R68954:68956 Coq.Init.Logic <> :type_scope:x_'='_x not
R68931:68941 proof <> getWriteAt' def
R68957:68960 Coq.Init.Datatypes <> Some constr
R68963:68967 proof <> Write constr
R68954:68956 Coq.Init.Logic <> :type_scope:x_'='_x not
R68931:68941 proof <> getWriteAt' def
R68957:68960 Coq.Init.Datatypes <> Some constr
R68963:68967 proof <> Write constr
R69052:69076 proof <> getWriteAt'DestructOnCSeq thm
R69052:69076 proof <> getWriteAt'DestructOnCSeq thm
R69093:69118 proof <> getWriteAt'RangeConsistent thm
R69093:69118 proof <> getWriteAt'RangeConsistent thm
R69170:69179 proof <> runProgram def
R69187:69196 proof <> runProgram def
R69187:69196 proof <> runProgram def
R69214:69227 proof <> writeToMemory' def
R69246:69267 proof <> readFromWriteDifferent thm
R69246:69267 proof <> readFromWriteDifferent thm
R69246:69267 proof <> readFromWriteDifferent thm
R69246:69267 proof <> readFromWriteDifferent thm
R69391:69436 proof <> latestAliasingWriteTimepointSpecDestructOnCSeq thm
R69391:69436 proof <> latestAliasingWriteTimepointSpecDestructOnCSeq thm
R69550:69560 proof <> getWriteAt' def
prf 69627:69684 <> noLatestAliasingWriteTimepointTransportAcrossValidSchedule
R69708:69711 Coq.Init.Logic <> :type_scope:x_'->'_x not
R69712:69714 Coq.Init.Datatypes <> nat ind
R69705:69707 Coq.Init.Datatypes <> nat ind
R69724:69726 proof <> com ind
R69738:69742 proof <> memix syndef
R69784:69791 Coq.Init.Logic <> :type_scope:x_'->'_x not
R69838:69846 Coq.Init.Logic <> :type_scope:x_'->'_x not
R69847:69878 proof <> latestAliasingWriteTimepointSpec def
R69890:69893 Coq.Init.Datatypes <> None constr
R69883:69888 proof <> readix var
R69880:69881 proof <> c' var
R69792:69823 proof <> latestAliasingWriteTimepointSpec def
R69834:69837 Coq.Init.Datatypes <> None constr
R69827:69832 proof <> readix var
R69825:69825 proof <> c var
R69750:69771 proof <> scheduleMappingWitness def
R69782:69783 proof <> c' var
R69780:69780 proof <> c var
R69775:69778 proof <> sinv var
R69773:69773 proof <> s var
R69964:69995 proof <> latestAliasingWriteTimepointSpec def
R70272:70287 proof <> commandIxInRange def
R70272:70287 proof <> commandIxInRange def
R70314:70329 proof <> commandIxInRange def
R70348:70369 proof <> scheduleMappingWitness def
R70494:70497 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R70489:70492 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R70500:70503 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R70504:70509 proof <> comlen def
R70494:70497 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R70489:70492 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R70500:70503 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R70504:70509 proof <> comlen def
R70729:70731 Coq.Init.Logic <> :type_scope:x_'='_x not
R70712:70722 proof <> getWriteAt' def
R70732:70742 proof <> getWriteAt' def
R70729:70731 Coq.Init.Logic <> :type_scope:x_'='_x not
R70712:70722 proof <> getWriteAt' def
R70732:70742 proof <> getWriteAt' def
R70769:70790 proof <> scheduleMappingWitness def
R70896:70899 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R70891:70894 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R70902:70905 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R70906:70911 proof <> comlen def
R70896:70899 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R70891:70894 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R70902:70905 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R70906:70911 proof <> comlen def
R70936:70951 proof <> commandIxInRange def
prf 71079:71121 <> commandIxInRangeTransportAlongValidSchedule
R71145:71148 Coq.Init.Logic <> :type_scope:x_'->'_x not
R71149:71151 Coq.Init.Datatypes <> nat ind
R71142:71144 Coq.Init.Datatypes <> nat ind
R71161:71163 proof <> com ind
R71171:71179 proof <> timepoint syndef
R71221:71229 Coq.Init.Logic <> :type_scope:x_'->'_x not
R71286:71286 Coq.Init.Logic <> :type_scope:x_'->'_x not
R71251:71259 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R71230:71245 proof <> commandIxInRange def
R71249:71250 proof <> tp var
R71247:71247 proof <> c var
R71260:71275 proof <> commandIxInRange def
R71281:71281 proof <> s var
R71283:71284 proof <> tp var
R71277:71278 proof <> c' var
R71187:71208 proof <> scheduleMappingWitness def
R71219:71220 proof <> c' var
R71217:71217 proof <> c var
R71212:71215 proof <> sinv var
R71210:71210 proof <> s var
R71379:71394 proof <> commandIxInRange def
R71411:71432 proof <> scheduleMappingWitness def
R71515:71518 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R71510:71513 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R71521:71524 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R71525:71530 proof <> comlen def
R71515:71518 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R71510:71513 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R71521:71524 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R71525:71530 proof <> comlen def
R71681:71696 proof <> commandIxInRange def
R71713:71734 proof <> scheduleMappingWitness def
R71830:71832 Coq.Init.Logic <> :type_scope:x_'='_x not
R71830:71832 Coq.Init.Logic <> :type_scope:x_'='_x not
R71847:71856 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 71936:71973 <> getWriteAt'TransportAlongValidSchedule
R71997:72000 Coq.Init.Logic <> :type_scope:x_'->'_x not
R72001:72003 Coq.Init.Datatypes <> nat ind
R71994:71996 Coq.Init.Datatypes <> nat ind
R72013:72015 proof <> com ind
R72023:72031 proof <> timepoint syndef
R72038:72042 proof <> write ind
R72084:72092 Coq.Init.Logic <> :type_scope:x_'->'_x not
R72157:72157 Coq.Init.Logic <> :type_scope:x_'->'_x not
R72118:72126 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R72109:72111 Coq.Init.Logic <> :type_scope:x_'='_x not
R72093:72103 proof <> getWriteAt' def
R72107:72108 proof <> tp var
R72105:72105 proof <> c var
R72112:72115 Coq.Init.Datatypes <> Some constr
R72117:72117 proof <> w var
R72148:72150 Coq.Init.Logic <> :type_scope:x_'='_x not
R72127:72137 proof <> getWriteAt' def
R72143:72143 proof <> s var
R72145:72146 proof <> tp var
R72139:72140 proof <> c' var
R72151:72154 Coq.Init.Datatypes <> Some constr
R72156:72156 proof <> w var
R72050:72071 proof <> scheduleMappingWitness def
R72082:72083 proof <> c' var
R72080:72080 proof <> c var
R72075:72078 proof <> sinv var
R72073:72073 proof <> s var
R72206:72227 proof <> scheduleMappingWitness def
R72315:72318 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72310:72313 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72321:72324 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72325:72330 proof <> comlen def
R72315:72318 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72310:72313 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72321:72324 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72325:72330 proof <> comlen def
R72345:72370 proof <> getWriteAt'RangeConsistent thm
R72345:72370 proof <> getWriteAt'RangeConsistent thm
R72537:72558 proof <> scheduleMappingWitness def
R72659:72662 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72654:72657 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72667:72670 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72671:72676 proof <> comlen def
R72659:72662 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72654:72657 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72667:72670 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72671:72676 proof <> comlen def
R72692:72717 proof <> getWriteAt'RangeConsistent thm
R72692:72717 proof <> getWriteAt'RangeConsistent thm
R72867:72869 Coq.Init.Logic <> :type_scope:x_'='_x not
R72851:72861 proof <> getWriteAt' def
R72870:72880 proof <> getWriteAt' def
R72867:72869 Coq.Init.Logic <> :type_scope:x_'='_x not
R72851:72861 proof <> getWriteAt' def
R72870:72880 proof <> getWriteAt' def
R72962:72971 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 73060:73082 <> is_inverse_cancellation
R73109:73112 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73113:73113 proof <> A var
R73108:73108 proof <> A var
R73120:73120 proof <> A var
R73143:73147 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73162:73162 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73148:73148 Coq.Init.Logic <> :type_scope:x_'='_x not
R73157:73160 Coq.Init.Logic <> :type_scope:x_'='_x not
R73149:73149 proof <> s var
R73152:73153 proof <> s' var
R73155:73155 proof <> a var
R73161:73161 proof <> a var
R73128:73137 Coq.Logic.ExtensionalityFacts <> is_inverse def
R73141:73142 proof <> s' var
R73139:73139 proof <> s var
R73191:73200 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 73308:73367 <> latestAliasingWriteTimepointSpecTransportAcrossValidSchedule
R73384:73396 proof <> dependenceset def
R73412:73415 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73416:73418 Coq.Init.Datatypes <> nat ind
R73409:73411 Coq.Init.Datatypes <> nat ind
R73428:73430 proof <> com ind
R73445:73453 proof <> timepoint syndef
R73465:73469 proof <> memix syndef
R73503:73511 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73546:73553 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73588:73595 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73654:73661 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73662:73693 proof <> latestAliasingWriteTimepointSpec def
R73706:73709 Coq.Init.Datatypes <> Some constr
R73712:73712 proof <> s var
R73714:73722 proof <> latest_tp var
R73698:73703 proof <> readix var
R73695:73696 proof <> c' var
R73596:73627 proof <> latestAliasingWriteTimepointSpec def
R73639:73642 Coq.Init.Datatypes <> Some constr
R73644:73652 proof <> latest_tp var
R73631:73636 proof <> readix var
R73629:73629 proof <> c var
R73554:73582 proof <> scheduleRespectsDependenceSet def
R73586:73587 proof <> ds var
R73584:73584 proof <> s var
R73512:73533 proof <> scheduleMappingWitness def
R73544:73545 proof <> c' var
R73542:73542 proof <> c var
R73537:73540 proof <> sinv var
R73535:73535 proof <> s var
R73477:73497 proof <> completeDependenceSet def
R73501:73502 proof <> ds var
R73499:73499 proof <> c var
R73831:73862 proof <> latestAliasingWriteTimepointSpec def
R73929:73960 proof <> latestAliasingWriteTimepointSpec def
R74152:74173 proof <> scheduleMappingWitness def
R74152:74173 proof <> scheduleMappingWitness def
R74199:74229 proof <> scheduleMappingWitnessSymmetric thm
R74199:74229 proof <> scheduleMappingWitnessSymmetric thm
R74260:74269 Coq.Logic.ExtensionalityFacts <> is_inverse def
R74260:74269 Coq.Logic.ExtensionalityFacts <> is_inverse def
R74305:74326 proof <> scheduleMappingWitness def
R74371:74390 proof <> is_inverse_symmetric thm
R74371:74390 proof <> is_inverse_symmetric thm
R74545:74587 proof <> commandIxInRangeTransportAlongValidSchedule thm
R74545:74587 proof <> commandIxInRangeTransportAlongValidSchedule thm
R74625:74647 proof <> is_inverse_cancellation thm
R74625:74647 proof <> is_inverse_cancellation thm
R74625:74647 proof <> is_inverse_cancellation thm
R74625:74647 proof <> is_inverse_cancellation thm
R74791:74828 proof <> getWriteAt'TransportAlongValidSchedule thm
R74791:74828 proof <> getWriteAt'TransportAlongValidSchedule thm
R74871:74893 proof <> is_inverse_cancellation thm
R74871:74893 proof <> is_inverse_cancellation thm
R74871:74893 proof <> is_inverse_cancellation thm
R74871:74893 proof <> is_inverse_cancellation thm
R75068:75075 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75084:75086 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75079:75083 proof <> write ind
R75104:75106 Coq.Init.Logic <> :type_scope:x_'='_x not
R75087:75097 proof <> getWriteAt' def
R75107:75110 Coq.Init.Datatypes <> Some constr
R75112:75112 proof <> w var
R75068:75075 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75084:75086 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75079:75083 proof <> write ind
R75104:75106 Coq.Init.Logic <> :type_scope:x_'='_x not
R75087:75097 proof <> getWriteAt' def
R75107:75110 Coq.Init.Datatypes <> Some constr
R75112:75112 proof <> w var
R75162:75185 proof <> getWriteAt'RangeComplete thm
R75162:75185 proof <> getWriteAt'RangeComplete thm
R75207:75222 proof <> commandIxInRange def
R75497:75500 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R75488:75490 Coq.Init.Logic <> :type_scope:x_'='_x not
R75473:75479 proof <> writeIx def
R75516:75519 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R75501:75507 proof <> writeIx def
R75497:75500 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R75488:75490 Coq.Init.Logic <> :type_scope:x_'='_x not
R75473:75479 proof <> writeIx def
R75516:75519 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R75501:75507 proof <> writeIx def
R75950:75970 proof <> dependenceLexPositive def
R75972:75972 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R75984:75985 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R75988:75988 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R75950:75970 proof <> dependenceLexPositive def
R75972:75972 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R75984:75985 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R75988:75988 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76027:76047 proof <> dependenceLexPositive def
R76092:76109 proof <> dependenceAliases' def
R76111:76111 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76123:76124 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76127:76127 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76092:76109 proof <> dependenceAliases' def
R76111:76111 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76123:76124 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76127:76127 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76170:76187 proof <> dependenceAliases' def
R76283:76292 Coq.Init.Datatypes <> option_map def
R76455:76457 Coq.Init.Logic <> :type_scope:x_'='_x not
R76427:76437 proof <> getWriteAt' def
R76458:76461 Coq.Init.Datatypes <> Some constr
R76464:76468 proof <> Write constr
R76455:76457 Coq.Init.Logic <> :type_scope:x_'='_x not
R76427:76437 proof <> getWriteAt' def
R76458:76461 Coq.Init.Datatypes <> Some constr
R76464:76468 proof <> Write constr
R76517:76554 proof <> getWriteAt'TransportAlongValidSchedule thm
R76517:76554 proof <> getWriteAt'TransportAlongValidSchedule thm
R76611:76633 proof <> is_inverse_cancellation thm
R76611:76633 proof <> is_inverse_cancellation thm
R76611:76633 proof <> is_inverse_cancellation thm
R76611:76633 proof <> is_inverse_cancellation thm
R76813:76829 proof <> dependenceInRange def
R76831:76831 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76843:76844 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76847:76847 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76813:76829 proof <> dependenceInRange def
R76831:76831 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76843:76844 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76847:76847 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76879:76895 proof <> dependenceInRange def
R76973:77015 proof <> commandIxInRangeTransportAlongValidSchedule thm
R76973:77015 proof <> commandIxInRangeTransportAlongValidSchedule thm
R77072:77094 proof <> is_inverse_cancellation thm
R77072:77094 proof <> is_inverse_cancellation thm
R77072:77094 proof <> is_inverse_cancellation thm
R77072:77094 proof <> is_inverse_cancellation thm
R77185:77210 proof <> getWriteAt'RangeConsistent thm
R77185:77210 proof <> getWriteAt'RangeConsistent thm
R77257:77272 proof <> commandIxInRange def
R77310:77330 proof <> completeDependenceSet def
R77336:77363 proof <> applyScheduleToDependenceSet def
R77310:77330 proof <> completeDependenceSet def
R77336:77363 proof <> applyScheduleToDependenceSet def
R77415:77455 proof <> dependenceSetTransportAcrossValidSchedule thm
R77415:77455 proof <> dependenceSetTransportAcrossValidSchedule thm
R77666:77672 Coq.Lists.List <> In def
R77693:77720 proof <> applyScheduleToDependenceSet def
R77674:77674 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77686:77687 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77690:77690 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77666:77672 Coq.Lists.List <> In def
R77693:77720 proof <> applyScheduleToDependenceSet def
R77674:77674 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77686:77687 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77690:77690 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77768:77788 proof <> completeDependenceSet def
R77848:77848 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77860:77861 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77864:77864 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77848:77848 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77860:77861 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77864:77864 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77921:77935 proof <> validDependence def
R77993:78020 proof <> applyScheduleToDependenceSet def
R78062:78076 Coq.Lists.List <> in_map_iff thm
R78062:78076 Coq.Lists.List <> in_map_iff thm
R78062:78076 Coq.Lists.List <> in_map_iff thm
R78492:78494 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R78492:78494 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R78576:78591 proof <> commandIxInRange def
R78576:78591 proof <> commandIxInRange def
R78851:78853 Coq.Init.Logic <> :type_scope:x_'='_x not
R78830:78833 Coq.Init.Datatypes <> Some constr
R78854:78857 Coq.Init.Datatypes <> Some constr
R78851:78853 Coq.Init.Logic <> :type_scope:x_'='_x not
R78830:78833 Coq.Init.Datatypes <> Some constr
R78854:78857 Coq.Init.Datatypes <> Some constr
R78927:78964 proof <> getWriteAt'TransportAlongValidSchedule thm
R78927:78964 proof <> getWriteAt'TransportAlongValidSchedule thm
R79021:79043 proof <> is_inverse_cancellation thm
R79021:79043 proof <> is_inverse_cancellation thm
R79021:79043 proof <> is_inverse_cancellation thm
R79021:79043 proof <> is_inverse_cancellation thm
R79100:79119 proof <> is_inverse_symmetric thm
R79100:79119 proof <> is_inverse_symmetric thm
R79255:79297 proof <> commandIxInRangeTransportAlongValidSchedule thm
R79255:79297 proof <> commandIxInRangeTransportAlongValidSchedule thm
R79354:79376 proof <> is_inverse_cancellation thm
R79354:79376 proof <> is_inverse_cancellation thm
R79354:79376 proof <> is_inverse_cancellation thm
R79354:79376 proof <> is_inverse_cancellation thm
R79433:79452 proof <> is_inverse_symmetric thm
R79433:79452 proof <> is_inverse_symmetric thm
R79500:79502 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R79500:79502 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R79552:79554 Coq.Init.Logic <> :type_scope:x_'='_x not
R79552:79554 Coq.Init.Logic <> :type_scope:x_'='_x not
R79592:79611 proof <> is_inverse_injective thm
R79592:79611 proof <> is_inverse_injective thm
R79640:79649 Coq.Logic.ExtensionalityFacts <> is_inverse def
R79640:79649 Coq.Logic.ExtensionalityFacts <> is_inverse def
R79698:79717 proof <> is_inverse_symmetric thm
R79698:79717 proof <> is_inverse_symmetric thm
R79865:79867 Coq.Init.Logic <> :type_scope:x_'='_x not
R79865:79867 Coq.Init.Logic <> :type_scope:x_'='_x not
R79939:79961 proof <> is_inverse_cancellation thm
R79939:79961 proof <> is_inverse_cancellation thm
R79939:79961 proof <> is_inverse_cancellation thm
R79939:79961 proof <> is_inverse_cancellation thm
R80090:80110 proof <> dependenceLexPositive def
R80112:80112 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80124:80125 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80135:80135 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80090:80110 proof <> dependenceLexPositive def
R80112:80112 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80124:80125 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80135:80135 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80164:80184 proof <> completeDependenceSet def
R80224:80224 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80236:80237 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80247:80247 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80224:80224 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80236:80237 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80247:80247 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80406:80426 proof <> dependenceLexPositive def
prf 80733:80780 <> getLatestAliasingWriteTimepointForProgramCorrect
R80794:80796 proof <> com ind
R80809:80813 proof <> memix syndef
R80821:80852 proof <> latestAliasingWriteTimepointSpec def
R80865:80905 proof <> getLatestAliasingWriteTimepointForProgram def
R80909:80915 proof <> aliasix var
R80907:80907 proof <> c var
R80856:80862 proof <> aliasix var
R80854:80854 proof <> c var
R80953:80984 proof <> latestAliasingWriteTimepointSpec def
R81020:81051 proof <> latestAliasingWriteTimepointSpec def
R81105:81108 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R81095:81097 Coq.Init.Logic <> :type_scope:x_'='_x not
R81112:81115 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R81105:81108 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R81095:81097 Coq.Init.Logic <> :type_scope:x_'='_x not
R81112:81115 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R81238:81240 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81230:81235 proof <> comlen def
R81238:81240 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81230:81235 proof <> comlen def
R81256:81296 proof <> getLatestAliasingWriteTimepointForProgram def
R81308:81348 proof <> getLatestAliasingWriteTimepointForProgram def
R81308:81348 proof <> getLatestAliasingWriteTimepointForProgram def
R81390:81392 Coq.Init.Logic <> :type_scope:x_'='_x not
R81379:81382 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R81393:81396 Coq.Init.Datatypes <> true constr
R81390:81392 Coq.Init.Logic <> :type_scope:x_'='_x not
R81379:81382 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R81393:81396 Coq.Init.Datatypes <> true constr
R81431:81440 Coq.Arith.PeanoNat Nat eqb_eq thm
R81431:81440 Coq.Arith.PeanoNat Nat eqb_eq thm
R81431:81440 Coq.Arith.PeanoNat Nat eqb_eq thm
R81539:81541 Coq.Init.Logic <> :type_scope:x_'='_x not
R81527:81527 Coq.Init.Datatypes <> S constr
R81530:81535 proof <> comlen def
R81550:81552 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81542:81547 proof <> comlen def
R81539:81541 Coq.Init.Logic <> :type_scope:x_'='_x not
R81527:81527 Coq.Init.Datatypes <> S constr
R81530:81535 proof <> comlen def
R81550:81552 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81542:81547 proof <> comlen def
R81645:81660 proof <> commandIxInRange def
R81670:81675 proof <> comlen def
R81683:81688 proof <> comlen def
R81683:81688 proof <> comlen def
R81768:81770 Coq.Init.Logic <> :type_scope:x_'='_x not
R81752:81755 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R81748:81750 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81740:81745 proof <> comlen def
R81756:81756 Coq.Init.Datatypes <> S constr
R81759:81764 proof <> comlen def
R81771:81774 Coq.Init.Datatypes <> true constr
R81768:81770 Coq.Init.Logic <> :type_scope:x_'='_x not
R81752:81755 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R81748:81750 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81740:81745 proof <> comlen def
R81756:81756 Coq.Init.Datatypes <> S constr
R81759:81764 proof <> comlen def
R81771:81774 Coq.Init.Datatypes <> true constr
R81797:81806 Coq.Arith.PeanoNat Nat eqb_eq thm
R81797:81806 Coq.Arith.PeanoNat Nat eqb_eq thm
R81797:81806 Coq.Arith.PeanoNat Nat eqb_eq thm
R81971:81986 proof <> commandIxInRange def
R82014:82019 proof <> comlen def
R82045:82050 proof <> comlen def
R82045:82050 proof <> comlen def
R82150:82152 Coq.Init.Logic <> :type_scope:x_'='_x not
R82139:82142 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R82153:82157 Coq.Init.Datatypes <> false constr
R82150:82152 Coq.Init.Logic <> :type_scope:x_'='_x not
R82139:82142 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R82153:82157 Coq.Init.Datatypes <> false constr
R82169:82179 Coq.Arith.PeanoNat Nat eqb_neq thm
R82169:82179 Coq.Arith.PeanoNat Nat eqb_neq thm
R82169:82179 Coq.Arith.PeanoNat Nat eqb_neq thm
R82200:82240 proof <> getLatestAliasingWriteTimepointForProgram def
R82263:82303 proof <> getLatestAliasingWriteTimepointForProgram def
R82263:82303 proof <> getLatestAliasingWriteTimepointForProgram def
R82536:82560 proof <> commandIxInRangeInclusive thm
R82536:82560 proof <> commandIxInRangeInclusive thm
R82736:82739 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R82721:82723 Coq.Init.Logic <> :type_scope:x_'='_x not
R82724:82724 Coq.Init.Datatypes <> S constr
R82727:82732 proof <> comlen def
R82750:82753 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R82754:82754 Coq.Init.Datatypes <> S constr
R82757:82762 proof <> comlen def
R82736:82739 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R82721:82723 Coq.Init.Logic <> :type_scope:x_'='_x not
R82724:82724 Coq.Init.Datatypes <> S constr
R82727:82732 proof <> comlen def
R82750:82753 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R82754:82754 Coq.Init.Datatypes <> S constr
R82757:82762 proof <> comlen def
R82863:82888 proof <> getWriteAt'RangeConsistent thm
R82863:82888 proof <> getWriteAt'RangeConsistent thm
R83018:83021 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R83006:83006 Coq.Init.Datatypes <> S constr
R83009:83014 proof <> comlen def
R83022:83027 proof <> comlen def
R83018:83021 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R83006:83006 Coq.Init.Datatypes <> S constr
R83009:83014 proof <> comlen def
R83022:83027 proof <> comlen def
R83129:83131 Coq.Init.Logic <> :type_scope:x_'='_x not
R83113:83116 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R83117:83117 Coq.Init.Datatypes <> S constr
R83120:83125 proof <> comlen def
R83132:83136 Coq.Init.Datatypes <> false constr
R83129:83131 Coq.Init.Logic <> :type_scope:x_'='_x not
R83113:83116 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R83117:83117 Coq.Init.Datatypes <> S constr
R83120:83125 proof <> comlen def
R83132:83136 Coq.Init.Datatypes <> false constr
R83179:83189 Coq.Arith.PeanoNat Nat eqb_neq thm
R83179:83189 Coq.Arith.PeanoNat Nat eqb_neq thm
R83179:83189 Coq.Arith.PeanoNat Nat eqb_neq thm
R83578:83598 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R83563:83565 Coq.Init.Logic <> :type_scope:x_'='_x not
R83566:83566 Coq.Init.Datatypes <> S constr
R83569:83574 proof <> comlen def
R83615:83617 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R83618:83618 Coq.Init.Datatypes <> S constr
R83621:83626 proof <> comlen def
R83578:83598 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R83563:83565 Coq.Init.Logic <> :type_scope:x_'='_x not
R83566:83566 Coq.Init.Datatypes <> S constr
R83569:83574 proof <> comlen def
R83615:83617 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R83618:83618 Coq.Init.Datatypes <> S constr
R83621:83626 proof <> comlen def
R83649:83664 proof <> commandIxInRange def
R83688:83693 proof <> comlen def
R83706:83711 proof <> comlen def
R83706:83711 proof <> comlen def
R83889:83891 Coq.Init.Logic <> :type_scope:x_'='_x not
R83874:83877 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R83878:83878 Coq.Init.Datatypes <> S constr
R83880:83885 proof <> comlen def
R83892:83895 Coq.Init.Datatypes <> true constr
R83889:83891 Coq.Init.Logic <> :type_scope:x_'='_x not
R83874:83877 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R83878:83878 Coq.Init.Datatypes <> S constr
R83880:83885 proof <> comlen def
R83892:83895 Coq.Init.Datatypes <> true constr
R83916:83925 Coq.Arith.PeanoNat Nat eqb_eq thm
R83916:83925 Coq.Arith.PeanoNat Nat eqb_eq thm
R83916:83925 Coq.Arith.PeanoNat Nat eqb_eq thm
R83983:83987 proof <> Write constr
R83983:83987 proof <> Write constr
R84117:84119 Coq.Init.Logic <> :type_scope:x_'='_x not
R84101:84104 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84105:84105 Coq.Init.Datatypes <> S constr
R84108:84113 proof <> comlen def
R84120:84124 Coq.Init.Datatypes <> false constr
R84117:84119 Coq.Init.Logic <> :type_scope:x_'='_x not
R84101:84104 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84105:84105 Coq.Init.Datatypes <> S constr
R84108:84113 proof <> comlen def
R84120:84124 Coq.Init.Datatypes <> false constr
R84145:84155 Coq.Arith.PeanoNat Nat eqb_neq thm
R84145:84155 Coq.Arith.PeanoNat Nat eqb_neq thm
R84145:84155 Coq.Arith.PeanoNat Nat eqb_neq thm
R84205:84220 proof <> commandIxInRange def
R84205:84220 proof <> commandIxInRange def
R84299:84314 proof <> commandIxInRange def
R84338:84343 proof <> comlen def
R84356:84361 proof <> comlen def
R84356:84361 proof <> comlen def
R84470:84501 proof <> latestAliasingWriteTimepointSpec def
R84559:84562 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R84549:84551 Coq.Init.Logic <> :type_scope:x_'='_x not
R84566:84569 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R84559:84562 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R84549:84551 Coq.Init.Logic <> :type_scope:x_'='_x not
R84566:84569 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R84663:84703 proof <> getLatestAliasingWriteTimepointForProgram def
R84743:84745 Coq.Init.Logic <> :type_scope:x_'='_x not
R84732:84735 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84746:84749 Coq.Init.Datatypes <> true constr
R84743:84745 Coq.Init.Logic <> :type_scope:x_'='_x not
R84732:84735 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84746:84749 Coq.Init.Datatypes <> true constr
R84761:84770 Coq.Arith.PeanoNat Nat eqb_eq thm
R84761:84770 Coq.Arith.PeanoNat Nat eqb_eq thm
R84761:84770 Coq.Arith.PeanoNat Nat eqb_eq thm
R84818:84818 Coq.Init.Datatypes <> S constr
R84821:84826 proof <> comlen def
R84818:84818 Coq.Init.Datatypes <> S constr
R84821:84826 proof <> comlen def
R84905:84920 proof <> commandIxInRange def
R84930:84935 proof <> comlen def
R84943:84948 proof <> comlen def
R84943:84948 proof <> comlen def
R85062:85064 Coq.Init.Logic <> :type_scope:x_'='_x not
R85050:85053 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85042:85047 proof <> comlen def
R85054:85059 proof <> comlen def
R85065:85068 Coq.Init.Datatypes <> true constr
R85062:85064 Coq.Init.Logic <> :type_scope:x_'='_x not
R85050:85053 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85042:85047 proof <> comlen def
R85054:85059 proof <> comlen def
R85065:85068 Coq.Init.Datatypes <> true constr
R85091:85100 Coq.Arith.PeanoNat Nat eqb_eq thm
R85091:85100 Coq.Arith.PeanoNat Nat eqb_eq thm
R85091:85100 Coq.Arith.PeanoNat Nat eqb_eq thm
R85235:85250 proof <> commandIxInRange def
R85266:85271 proof <> comlen def
R85285:85290 proof <> comlen def
R85285:85290 proof <> comlen def
R85336:85339 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R85320:85323 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R85325:85327 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R85328:85333 proof <> comlen def
R85342:85344 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R85345:85345 Coq.Init.Datatypes <> S constr
R85348:85353 proof <> comlen def
R85336:85339 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R85320:85323 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R85325:85327 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R85328:85333 proof <> comlen def
R85342:85344 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R85345:85345 Coq.Init.Datatypes <> S constr
R85348:85353 proof <> comlen def
R85458:85460 Coq.Init.Logic <> :type_scope:x_'='_x not
R85447:85450 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85461:85465 Coq.Init.Datatypes <> false constr
R85458:85460 Coq.Init.Logic <> :type_scope:x_'='_x not
R85447:85450 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85461:85465 Coq.Init.Datatypes <> false constr
R85502:85512 Coq.Arith.PeanoNat Nat eqb_neq thm
R85502:85512 Coq.Arith.PeanoNat Nat eqb_neq thm
R85502:85512 Coq.Arith.PeanoNat Nat eqb_neq thm
R85534:85574 proof <> getLatestAliasingWriteTimepointForProgram def
R85599:85639 proof <> getLatestAliasingWriteTimepointForProgram def
R85599:85639 proof <> getLatestAliasingWriteTimepointForProgram def
R85761:85764 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R85746:85748 Coq.Init.Logic <> :type_scope:x_'='_x not
R85749:85749 Coq.Init.Datatypes <> S constr
R85752:85757 proof <> comlen def
R85767:85770 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R85771:85771 Coq.Init.Datatypes <> S constr
R85774:85779 proof <> comlen def
R85761:85764 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R85746:85748 Coq.Init.Logic <> :type_scope:x_'='_x not
R85749:85749 Coq.Init.Datatypes <> S constr
R85752:85757 proof <> comlen def
R85767:85770 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R85771:85771 Coq.Init.Datatypes <> S constr
R85774:85779 proof <> comlen def
R85878:85880 Coq.Init.Logic <> :type_scope:x_'='_x not
R85862:85865 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85866:85866 Coq.Init.Datatypes <> S constr
R85869:85874 proof <> comlen def
R85881:85884 Coq.Init.Datatypes <> true constr
R85878:85880 Coq.Init.Logic <> :type_scope:x_'='_x not
R85862:85865 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85866:85866 Coq.Init.Datatypes <> S constr
R85869:85874 proof <> comlen def
R85881:85884 Coq.Init.Datatypes <> true constr
R85907:85916 Coq.Arith.PeanoNat Nat eqb_eq thm
R85907:85916 Coq.Arith.PeanoNat Nat eqb_eq thm
R85907:85916 Coq.Arith.PeanoNat Nat eqb_eq thm
R85978:85982 proof <> Write constr
R85978:85982 proof <> Write constr
R86050:86052 Coq.Init.Logic <> :type_scope:x_'='_x not
R86034:86037 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R86038:86038 Coq.Init.Datatypes <> S constr
R86041:86046 proof <> comlen def
R86053:86057 Coq.Init.Datatypes <> false constr
R86050:86052 Coq.Init.Logic <> :type_scope:x_'='_x not
R86034:86037 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R86038:86038 Coq.Init.Datatypes <> S constr
R86041:86046 proof <> comlen def
R86053:86057 Coq.Init.Datatypes <> false constr
R86080:86090 Coq.Arith.PeanoNat Nat eqb_neq thm
R86080:86090 Coq.Arith.PeanoNat Nat eqb_neq thm
R86080:86090 Coq.Arith.PeanoNat Nat eqb_neq thm
R86175:86190 proof <> commandIxInRange def
R86175:86190 proof <> commandIxInRange def
R86234:86249 proof <> commandIxInRange def
R86275:86280 proof <> comlen def
R86304:86309 proof <> comlen def
R86304:86309 proof <> comlen def
R86423:86463 proof <> getLatestAliasingWriteTimepointForProgram def
R86477:86508 proof <> latestAliasingWriteTimepointSpec def
prf 86628:86666 <> getWriteAt'TransportAlongValidSchedule'
R86690:86693 Coq.Init.Logic <> :type_scope:x_'->'_x not
R86694:86696 Coq.Init.Datatypes <> nat ind
R86687:86689 Coq.Init.Datatypes <> nat ind
R86706:86708 proof <> com ind
R86716:86724 proof <> timepoint syndef
R86731:86735 proof <> write ind
R86777:86785 Coq.Init.Logic <> :type_scope:x_'->'_x not
R86802:86804 Coq.Init.Logic <> :type_scope:x_'='_x not
R86786:86796 proof <> getWriteAt' def
R86800:86801 proof <> tp var
R86798:86798 proof <> c var
R86805:86815 proof <> getWriteAt' def
R86821:86821 proof <> s var
R86823:86824 proof <> tp var
R86817:86818 proof <> c' var
R86743:86764 proof <> scheduleMappingWitness def
R86775:86776 proof <> c' var
R86773:86773 proof <> c var
R86768:86771 proof <> sinv var
R86766:86766 proof <> s var
R86848:86848 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86874:86878 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86856:86859 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R86851:86854 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R86862:86865 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R86866:86871 proof <> comlen def
R86885:86888 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86881:86883 Coq.Init.Logic <> :type_scope:x_'='_x not
R86891:86893 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R86894:86899 proof <> comlen def
R86848:86848 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86874:86878 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86856:86859 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R86851:86854 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R86862:86865 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R86866:86871 proof <> comlen def
R86885:86888 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86881:86883 Coq.Init.Logic <> :type_scope:x_'='_x not
R86891:86893 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R86894:86899 proof <> comlen def
prf 87177:87204 <> reschedulePreservesSemantics
R87221:87223 proof <> com ind
R87231:87243 proof <> dependenceset def
R87258:87261 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87262:87264 Coq.Init.Datatypes <> nat ind
R87255:87257 Coq.Init.Datatypes <> nat ind
R87298:87301 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87336:87343 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87378:87381 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87383:87387 proof <> ::x_'==='_x not
R87382:87382 proof <> c var
R87388:87389 proof <> c' var
R87344:87372 proof <> scheduleRespectsDependenceSet def
R87376:87377 proof <> ds var
R87374:87374 proof <> s var
R87302:87323 proof <> scheduleMappingWitness def
R87334:87335 proof <> c' var
R87332:87332 proof <> c var
R87327:87330 proof <> sinv var
R87325:87325 proof <> s var
R87272:87292 proof <> completeDependenceSet def
R87296:87297 proof <> ds var
R87294:87294 proof <> c var
R87485:87487 proof <> ceq def
R87519:87543 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R87519:87543 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R87588:87628 proof <> getLatestAliasingWriteTimepointForProgram def
R87588:87628 proof <> getLatestAliasingWriteTimepointForProgram def
R87651:87682 proof <> latestAliasingWriteTimepointSpec def
R87694:87734 proof <> getLatestAliasingWriteTimepointForProgram def
R87651:87682 proof <> latestAliasingWriteTimepointSpec def
R87694:87734 proof <> getLatestAliasingWriteTimepointForProgram def
R87772:87819 proof <> getLatestAliasingWriteTimepointForProgramCorrect thm
R87772:87819 proof <> getLatestAliasingWriteTimepointForProgramCorrect thm
R87899:87930 proof <> latestAliasingWriteTimepointSpec def
R88319:88321 Coq.Init.Logic <> :type_scope:x_'='_x not
R88289:88298 proof <> runProgram def
R88319:88321 Coq.Init.Logic <> :type_scope:x_'='_x not
R88289:88298 proof <> runProgram def
R88348:88377 proof <> latestAliasingWriteWillBeValue thm
R88348:88377 proof <> latestAliasingWriteWillBeValue thm
R88536:88538 Coq.Init.Logic <> :type_scope:x_'='_x not
R88505:88514 proof <> runProgram def
R88536:88538 Coq.Init.Logic <> :type_scope:x_'='_x not
R88505:88514 proof <> runProgram def
R88566:88597 proof <> latestAliasingWriteTimepointSpec def
R88610:88613 Coq.Init.Datatypes <> Some constr
R88566:88597 proof <> latestAliasingWriteTimepointSpec def
R88610:88613 Coq.Init.Datatypes <> Some constr
R88661:88720 proof <> latestAliasingWriteTimepointSpecTransportAcrossValidSchedule thm
R88661:88720 proof <> latestAliasingWriteTimepointSpecTransportAcrossValidSchedule thm
R88862:88891 proof <> latestAliasingWriteWillBeValue thm
R88862:88891 proof <> latestAliasingWriteWillBeValue thm
R88958:88960 Coq.Init.Logic <> :type_scope:x_'='_x not
R88927:88937 proof <> getWriteAt' def
R88961:88964 Coq.Init.Datatypes <> Some constr
R88966:88970 proof <> Write constr
R88958:88960 Coq.Init.Logic <> :type_scope:x_'='_x not
R88927:88937 proof <> getWriteAt' def
R88961:88964 Coq.Init.Datatypes <> Some constr
R88966:88970 proof <> Write constr
R89006:89043 proof <> getWriteAt'TransportAlongValidSchedule thm
R89006:89043 proof <> getWriteAt'TransportAlongValidSchedule thm
R89054:89084 proof <> scheduleMappingWitnessSymmetric thm
R89054:89084 proof <> scheduleMappingWitnessSymmetric thm
R89114:89136 proof <> is_inverse_cancellation thm
R89114:89136 proof <> is_inverse_cancellation thm
R89114:89136 proof <> is_inverse_cancellation thm
R89114:89136 proof <> is_inverse_cancellation thm
R89180:89201 proof <> scheduleMappingWitness def
R89256:89275 proof <> is_inverse_symmetric thm
R89256:89275 proof <> is_inverse_symmetric thm
R89351:89354 Coq.Init.Logic <> :type_scope:x_'='_x not
R89372:89372 Coq.Init.Logic <> :type_scope:x_'='_x not
R89321:89330 proof <> runProgram def
R89351:89354 Coq.Init.Logic <> :type_scope:x_'='_x not
R89372:89372 Coq.Init.Logic <> :type_scope:x_'='_x not
R89321:89330 proof <> runProgram def
R89393:89431 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89393:89431 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89553:89556 Coq.Init.Logic <> :type_scope:x_'='_x not
R89574:89574 Coq.Init.Logic <> :type_scope:x_'='_x not
R89522:89531 proof <> runProgram def
R89553:89556 Coq.Init.Logic <> :type_scope:x_'='_x not
R89574:89574 Coq.Init.Logic <> :type_scope:x_'='_x not
R89522:89531 proof <> runProgram def
R89596:89634 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89596:89634 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89700:89731 proof <> latestAliasingWriteTimepointSpec def
R89743:89746 Coq.Init.Datatypes <> None constr
R89700:89731 proof <> latestAliasingWriteTimepointSpec def
R89743:89746 Coq.Init.Datatypes <> None constr
R89787:89844 proof <> noLatestAliasingWriteTimepointTransportAcrossValidSchedule thm
R89787:89844 proof <> noLatestAliasingWriteTimepointTransportAcrossValidSchedule thm
