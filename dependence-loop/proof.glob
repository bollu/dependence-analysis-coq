DIGEST f6da9af9d1fdc9cf18d524ba633631ba
Fproof
R15:28 Coq.Lists.List <> <> lib
R46:51 Coq.funind.FunInd <> <> lib
R69:85 Coq.Lists.ListSet <> <> lib
R103:119 Coq.ZArith.BinInt <> <> lib
R137:156 Coq.ZArith.BinIntDef <> <> lib
R174:192 Coq.Numbers.BinNums <> <> lib
R210:223 Coq.Lists.List <> <> lib
R241:256 Coq.ZArith.Zbool <> <> lib
R274:287 Coq.ZArith.Int <> <> lib
R305:327 Coq.Sorting.Permutation <> <> lib
R345:378 Coq.Logic.FunctionalExtensionality <> <> lib
R396:424 Coq.Logic.ExtensionalityFacts <> <> lib
R442:446 Coq.omega.Omega <> <> lib
R464:479 Coq.Bool.Sumbool <> <> lib
R497:513 Coq.ZArith.Zhints <> <> lib
R531:550 Coq.Classes.EquivDec <> <> lib
R568:592 Coq.Structures.Equalities <> <> lib
R610:632 Coq.FSets.FMapInterface <> <> lib
R650:656 Coq.FSets.FMapAVL <> <> lib
R674:682 Coq.FSets.FMapFacts <> <> lib
R700:715 Coq.Logic.FinFun <> <> lib
R733:735 Coq.Init.Nat <> <> lib
R753:761 Coq.Vectors.VectorDef <> <> lib
R779:790 Coq.MSets.MSetWeakList <> <> lib
R808:820 Coq.FSets.FSetInterface <> <> lib
R838:845 Coq.FSets.FSetList <> <> lib
R863:882 Coq.Program.Equality <> <> lib
R900:923 CoLoR.Util.FSet.FSetUtil <> <> lib
R1158:1175 Coq.FSets.FMapList <> <> lib
R1179:1206 Coq.Structures.OrderedTypeEx <> <> lib
R1229:1241 Coq.FSets.FMapList Make <> modtype
R1243:1249 Coq.Structures.OrderedTypeEx Z_as_OT <> modtype
mod 1224:1224 <> M
R1277:1282 Coq.FSets.FMapFacts WFacts <> modtype
R1284:1284 proof M <> modtype
mod 1267:1272 <> MFacts
R1308:1326 Coq.FSets.FMapFacts <> <> lib
syndef 1413:1417 <> memix
R1422:1424 Coq.Init.Datatypes <> nat ind
syndef 1460:1467 <> memvalue
R1472:1472 Coq.Numbers.BinNums <> Z ind
ind 1486:1490 <> write
constr 1504:1508 <> Write
R1516:1519 Coq.Init.Logic <> :type_scope:x_'->'_x not
R1528:1531 Coq.Init.Logic <> :type_scope:x_'->'_x not
R1532:1536 proof <> write ind
R1520:1527 proof <> memvalue syndef
R1511:1515 proof <> memix syndef
def 1552:1557 <> memory
R1568:1571 Coq.Init.Logic <> :type_scope:x_'->'_x not
R1572:1579 proof <> memvalue syndef
R1563:1567 proof <> memix syndef
R1611:1616 proof <> memory def
not 1592:1592 <> ::x_'::='_x
def 1683:1692 <> initMemory
R1696:1701 proof <> memory def
R1716:1717 Coq.Numbers.BinNums <> Z0 constr
prf 1729:1748 <> initMemoryAlwaysZero
R1765:1769 proof <> memix syndef
R1773:1773 Coq.Init.Logic <> :type_scope:x_'='_x not
R1788:1791 Coq.Init.Logic <> :type_scope:x_'='_x not
R1774:1783 proof <> initMemory def
R1785:1787 proof <> wix var
R1792:1793 Coq.Numbers.BinNums <> Z0 constr
def 1829:1841 <> writeToMemory
R1849:1853 proof <> memix syndef
R1863:1870 proof <> memvalue syndef
R1880:1885 proof <> memory def
R1890:1895 proof <> memory def
R1918:1921 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R1916:1917 proof <> ix var
R1922:1924 proof <> wix var
R1942:1945 proof <> mold var
R1947:1948 proof <> ix var
R1932:1935 proof <> wval var
def 1963:1976 <> writeToMemory'
R1982:1986 proof <> write ind
R1996:2001 proof <> memory def
R2006:2011 proof <> memory def
R2024:2024 proof <> w var
R2035:2039 proof <> Write constr
R2051:2063 proof <> writeToMemory def
R2072:2075 proof <> mold var
prf 2093:2114 <> readFromWriteIdentical
R2131:2135 proof <> memix syndef
R2145:2152 proof <> memvalue syndef
R2161:2166 proof <> memory def
R2206:2208 Coq.Init.Logic <> :type_scope:x_'='_x not
R2175:2187 proof <> writeToMemory def
R2198:2200 proof <> mem var
R2193:2196 proof <> wval var
R2189:2191 proof <> wix var
R2203:2205 proof <> wix var
R2209:2212 proof <> wval var
R2254:2266 proof <> writeToMemory def
R2279:2290 Coq.Arith.PeanoNat Nat eqb_refl thm
R2279:2290 Coq.Arith.PeanoNat Nat eqb_refl thm
R2279:2290 Coq.Arith.PeanoNat Nat eqb_refl thm
prf 2383:2404 <> readFromWriteDifferent
R2421:2425 proof <> memix syndef
R2434:2438 proof <> memix syndef
R2449:2456 proof <> memvalue syndef
R2465:2470 proof <> memory def
R2488:2491 Coq.Init.Logic <> :type_scope:x_'->'_x not
R2524:2526 Coq.Init.Logic <> :type_scope:x_'='_x not
R2493:2505 proof <> writeToMemory def
R2516:2518 proof <> mem var
R2511:2514 proof <> wval var
R2507:2509 proof <> wix var
R2521:2523 proof <> rix var
R2527:2529 proof <> mem var
R2531:2533 proof <> rix var
R2481:2484 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R2478:2480 proof <> rix var
R2485:2487 proof <> wix var
R2601:2613 proof <> writeToMemory def
R2625:2625 Coq.Init.Logic <> :type_scope:x_'='_x not
R2636:2639 Coq.Init.Logic <> :type_scope:x_'='_x not
R2629:2632 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R2640:2644 Coq.Init.Datatypes <> false constr
R2625:2625 Coq.Init.Logic <> :type_scope:x_'='_x not
R2636:2639 Coq.Init.Logic <> :type_scope:x_'='_x not
R2629:2632 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R2640:2644 Coq.Init.Datatypes <> false constr
R2656:2666 Coq.Arith.PeanoNat Nat eqb_neq thm
R2656:2666 Coq.Arith.PeanoNat Nat eqb_neq thm
def 2789:2808 <> modelWriteSideEffect
R2817:2822 proof <> memory def
R2829:2833 proof <> write ind
R2838:2843 proof <> memory def
R2856:2856 proof <> w var
R2867:2871 proof <> Write constr
R2886:2898 proof <> writeToMemory def
R2909:2912 proof <> mold var
ind 2934:2936 <> com
constr 2949:2952 <> CSeq
constr 2977:2982 <> CBegin
R2958:2961 Coq.Init.Logic <> :type_scope:x_'->'_x not
R2967:2970 Coq.Init.Logic <> :type_scope:x_'->'_x not
R2971:2973 proof <> com ind
R2962:2966 proof <> write ind
R2955:2957 proof <> com ind
R2985:2987 proof <> com ind
def 3000:3005 <> comlen
R3011:3013 proof <> com ind
R3018:3020 Coq.Init.Datatypes <> nat ind
R3033:3033 proof <> c var
R3044:3049 proof <> CBegin constr
R3060:3063 proof <> CSeq constr
R3074:3076 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R3077:3082 proof <> comlen def
prf 3103:3135 <> n_minus_1_plus_1_eq_n_when_n_gt_0
R3149:3151 Coq.Init.Datatypes <> nat ind
R3160:3163 Coq.Init.Logic <> :type_scope:x_'->'_x not
R3173:3175 Coq.Init.Logic <> :type_scope:x_'='_x not
R3169:3171 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R3165:3167 Coq.Init.Peano <> :nat_scope:x_'-'_x not
R3164:3164 proof <> n var
R3176:3176 proof <> n var
R3156:3158 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R3155:3155 proof <> n var
def 3217:3226 <> c_example'
R3230:3232 proof <> com ind
R3238:3241 proof <> CSeq constr
R3274:3278 proof <> Write constr
R3244:3247 proof <> CSeq constr
R3257:3261 proof <> Write constr
R3249:3254 proof <> CBegin constr
syndef 3302:3310 <> timepoint
R3316:3318 Coq.Init.Datatypes <> nat ind
def 3332:3339 <> writeset
R3355:3358 Coq.Init.Logic <> :type_scope:x_'->'_x not
R3359:3362 Coq.Init.Datatypes <> list ind
R3364:3372 proof <> timepoint syndef
R3350:3354 proof <> memix syndef
def 3387:3399 <> emptyWriteSet
R3403:3410 proof <> writeset def
R3425:3432 Coq.Lists.List <> nil syndef
def 3446:3458 <> addToWriteSet
R3465:3472 proof <> writeset def
R3480:3484 proof <> memix syndef
R3492:3500 proof <> timepoint syndef
R3505:3512 proof <> writeset def
R3536:3539 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R3533:3535 proof <> ix' var
R3540:3541 proof <> ix var
R3601:3602 proof <> ws var
R3604:3606 proof <> ix' var
R3561:3569 Coq.Lists.List <> cons syndef
R3575:3576 proof <> ws var
R3578:3580 proof <> ix' var
R3571:3572 proof <> tp var
def 3620:3636 <> singletonWriteSet
R3643:3647 proof <> memix syndef
R3655:3663 proof <> timepoint syndef
R3668:3675 proof <> writeset def
R3682:3694 proof <> addToWriteSet def
R3713:3714 proof <> tp var
R3710:3711 proof <> ix var
R3696:3708 proof <> emptyWriteSet def
prf 3788:3814 <> destructInSingletonWriteSet
R3837:3841 proof <> memix syndef
R3855:3863 proof <> timepoint syndef
R3918:3921 Coq.Init.Logic <> :type_scope:x_'->'_x not
R3932:3935 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R3927:3929 Coq.Init.Logic <> :type_scope:x_'='_x not
R3922:3926 proof <> curtp var
R3930:3931 proof <> tp var
R3938:3940 Coq.Init.Logic <> :type_scope:x_'='_x not
R3936:3937 proof <> ix var
R3941:3945 proof <> curix var
R3871:3877 Coq.Lists.List <> In def
R3887:3903 proof <> singletonWriteSet def
R3908:3909 proof <> tp var
R3905:3906 proof <> ix var
R3912:3916 proof <> curix var
R3879:3883 proof <> curtp var
R3974:3990 proof <> singletonWriteSet def
R4007:4019 proof <> addToWriteSet def
R4047:4050 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R4042:4044 Coq.Init.Logic <> :type_scope:x_'='_x not
R4056:4059 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R4047:4050 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R4042:4044 Coq.Init.Logic <> :type_scope:x_'='_x not
R4056:4059 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R4122:4131 Coq.Arith.PeanoNat Nat eqb_eq thm
R4122:4131 Coq.Arith.PeanoNat Nat eqb_eq thm
R4122:4131 Coq.Arith.PeanoNat Nat eqb_eq thm
R4199:4208 Coq.Arith.PeanoNat Nat eqb_eq thm
R4199:4208 Coq.Arith.PeanoNat Nat eqb_eq thm
R4199:4208 Coq.Arith.PeanoNat Nat eqb_eq thm
R4272:4282 Coq.Arith.PeanoNat Nat eqb_neq thm
R4272:4282 Coq.Arith.PeanoNat Nat eqb_neq thm
R4272:4282 Coq.Arith.PeanoNat Nat eqb_neq thm
def 4342:4355 <> mergeWriteSets
R4366:4373 proof <> writeset def
R4378:4385 proof <> writeset def
R4407:4410 Coq.Init.Datatypes <> :list_scope:x_'++'_x not
R4402:4403 proof <> ws var
R4405:4406 proof <> ix var
R4411:4413 proof <> ws' var
R4415:4416 proof <> ix var
def 4448:4462 <> writeToWriteset
R4468:4472 proof <> write ind
R4480:4488 proof <> timepoint syndef
R4493:4500 proof <> writeset def
R4513:4513 proof <> w var
R4524:4528 proof <> Write constr
R4542:4558 proof <> singletonWriteSet def
R4563:4564 proof <> tp var
prf 4580:4605 <> destructInWriteToWriteSet'
R4621:4623 Coq.Init.Datatypes <> nat ind
R4635:4643 proof <> timepoint syndef
R4657:4661 proof <> memix syndef
R4670:4677 proof <> memvalue syndef
R4739:4742 Coq.Init.Logic <> :type_scope:x_'->'_x not
R4752:4755 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R4748:4750 Coq.Init.Logic <> :type_scope:x_'='_x not
R4743:4747 proof <> curtp var
R4751:4751 proof <> n var
R4761:4763 Coq.Init.Logic <> :type_scope:x_'='_x not
R4756:4760 proof <> curix var
R4764:4765 proof <> ix var
R4685:4691 Coq.Lists.List <> In def
R4700:4714 proof <> writeToWriteset def
R4733:4737 proof <> curix var
R4731:4731 proof <> n var
R4717:4721 proof <> Write constr
R4726:4728 proof <> val var
R4723:4724 proof <> ix var
R4693:4697 proof <> curtp var
R4794:4808 proof <> writeToWriteset def
R4824:4850 proof <> destructInSingletonWriteSet thm
R4824:4850 proof <> destructInSingletonWriteSet thm
def 4885:4894 <> dependence
R4908:4910 Coq.Init.Datatypes <> :type_scope:x_'*'_x not
R4905:4907 Coq.Init.Datatypes <> nat ind
R4911:4913 Coq.Init.Datatypes <> nat ind
def 4927:4939 <> dependenceset
R4950:4953 Coq.Init.Datatypes <> list ind
R4955:4964 proof <> dependence def
def 4978:4995 <> emptyDependenceSet
R4999:5011 proof <> dependenceset def
R5016:5023 Coq.Lists.List <> nil syndef
def 5039:5059 <> dependenceLexPositive
R5065:5074 proof <> dependence def
R5094:5096 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R5089:5091 Coq.Init.Datatypes <> fst def
R5093:5093 proof <> d var
R5097:5099 Coq.Init.Datatypes <> snd def
R5101:5101 proof <> d var
def 5116:5131 <> commandIxInRange
R5138:5140 proof <> com ind
R5147:5149 Coq.Init.Datatypes <> nat ind
R5177:5180 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R5165:5168 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R5164:5164 proof <> i var
R5169:5174 proof <> comlen def
R5176:5176 proof <> c var
R5182:5185 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R5181:5181 proof <> i var
prf 5196:5225 <> commandIxInRangeDestructOnCSeq
R5239:5241 proof <> com ind
R5248:5252 proof <> write ind
R5259:5261 Coq.Init.Datatypes <> nat ind
R5294:5298 Coq.Init.Logic <> :type_scope:x_'->'_x not
R5316:5320 Coq.Init.Logic <> :type_scope:x_'->'_x not
R5321:5336 proof <> commandIxInRange def
R5340:5340 proof <> i var
R5338:5338 proof <> c var
R5300:5303 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R5299:5299 proof <> i var
R5312:5314 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R5304:5309 proof <> comlen def
R5311:5311 proof <> c var
R5265:5280 proof <> commandIxInRange def
R5293:5293 proof <> i var
R5283:5286 proof <> CSeq constr
R5290:5290 proof <> w var
R5288:5288 proof <> c var
R5369:5384 proof <> commandIxInRange def
R5401:5416 proof <> commandIxInRange def
prf 5452:5476 <> commandIxInRangeInclusive
R5490:5492 proof <> com ind
R5499:5503 proof <> write ind
R5510:5512 Coq.Init.Datatypes <> nat ind
R5536:5539 Coq.Init.Logic <> :type_scope:x_'->'_x not
R5540:5555 proof <> commandIxInRange def
R5568:5568 proof <> i var
R5558:5561 proof <> CSeq constr
R5565:5565 proof <> w var
R5563:5563 proof <> c var
R5516:5531 proof <> commandIxInRange def
R5535:5535 proof <> i var
R5533:5533 proof <> c var
R5587:5602 proof <> commandIxInRange def
R5612:5617 proof <> comlen def
R5625:5630 proof <> comlen def
R5625:5630 proof <> comlen def
def 5671:5687 <> dependenceInRange
R5693:5702 proof <> dependence def
R5709:5711 proof <> com ind
R5752:5755 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R5726:5741 proof <> commandIxInRange def
R5746:5748 Coq.Init.Datatypes <> fst def
R5750:5750 proof <> d var
R5743:5743 proof <> c var
R5756:5771 proof <> commandIxInRange def
R5776:5778 Coq.Init.Datatypes <> snd def
R5780:5780 proof <> d var
R5773:5773 proof <> c var
prf 5791:5816 <> dependenceInRangeSymmetric
R5840:5848 proof <> timepoint syndef
R5855:5857 proof <> com ind
R5899:5903 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R5865:5881 proof <> dependenceInRange def
R5898:5898 proof <> c var
R5883:5883 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5890:5891 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5896:5896 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5884:5889 proof <> tbegin var
R5892:5895 proof <> tend var
R5904:5920 proof <> dependenceInRange def
R5937:5937 proof <> c var
R5922:5922 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5927:5928 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5935:5935 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R5923:5926 proof <> tend var
R5929:5934 proof <> tbegin var
R5988:5996 proof <> timepoint syndef
R6047:6063 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6064:6080 proof <> dependenceInRange def
R6082:6082 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6087:6088 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6095:6095 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6083:6086 proof <> tend var
R6089:6094 proof <> tbegin var
R6013:6029 proof <> dependenceInRange def
R6031:6031 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6038:6039 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6044:6044 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6032:6037 proof <> tbegin var
R6040:6043 proof <> tend var
R5988:5996 proof <> timepoint syndef
R6047:6063 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6064:6080 proof <> dependenceInRange def
R6082:6082 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6087:6088 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6095:6095 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6083:6086 proof <> tend var
R6089:6094 proof <> tbegin var
R6013:6029 proof <> dependenceInRange def
R6031:6031 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6038:6039 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6044:6044 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6032:6037 proof <> tbegin var
R6040:6043 proof <> tend var
R6110:6126 proof <> dependenceInRange def
R6139:6154 proof <> commandIxInRange def
def 6233:6239 <> writeIx
R6245:6249 proof <> write ind
R6254:6258 proof <> memix syndef
R6271:6271 proof <> w var
R6282:6286 proof <> Write constr
def 6360:6370 <> getWriteAt'
R6376:6378 proof <> com ind
R6385:6387 Coq.Init.Datatypes <> nat ind
R6392:6397 Coq.Init.Datatypes <> option ind
R6399:6403 proof <> write ind
R6416:6416 proof <> c var
R6427:6432 proof <> CBegin constr
R6437:6440 Coq.Init.Datatypes <> None constr
R6446:6449 proof <> CSeq constr
R6463:6467 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R6476:6476 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R6462:6462 proof <> i var
R6468:6473 proof <> comlen def
R6475:6475 proof <> c var
R6495:6505 proof <> getWriteAt' def
R6510:6510 proof <> i var
R6483:6486 Coq.Init.Datatypes <> Some constr
def 6540:6557 <> dependenceAliases'
R6563:6572 proof <> dependence def
R6579:6581 proof <> com ind
R6607:6609 Coq.Init.Datatypes <> fst def
R6611:6611 proof <> d var
R6629:6631 Coq.Init.Datatypes <> snd def
R6633:6633 proof <> d var
R6650:6660 proof <> getWriteAt' def
R6664:6666 proof <> ix1 var
R6662:6662 proof <> c var
R6683:6693 proof <> getWriteAt' def
R6697:6699 proof <> ix2 var
R6695:6695 proof <> c var
R6727:6729 Coq.Init.Logic <> :type_scope:x_'='_x not
R6706:6715 Coq.Init.Datatypes <> option_map def
R6725:6726 proof <> w1 var
R6717:6723 proof <> writeIx def
R6730:6739 Coq.Init.Datatypes <> option_map def
R6749:6750 proof <> w2 var
R6741:6747 proof <> writeIx def
prf 6760:6786 <> dependenceAliases'Symmetric
R6810:6818 proof <> timepoint syndef
R6825:6827 proof <> com ind
R6870:6874 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R6835:6852 proof <> dependenceAliases' def
R6869:6869 proof <> c var
R6854:6854 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6861:6862 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6867:6867 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6855:6860 proof <> tbegin var
R6863:6866 proof <> tend var
R6875:6892 proof <> dependenceAliases' def
R6909:6909 proof <> c var
R6894:6894 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6899:6900 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6907:6907 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6895:6898 proof <> tend var
R6901:6906 proof <> tbegin var
R6952:6960 proof <> timepoint syndef
R6991:6994 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6995:7012 proof <> dependenceAliases' def
R7014:7014 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7016:7017 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7019:7019 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7015:7015 proof <> y var
R7018:7018 proof <> x var
R6964:6981 proof <> dependenceAliases' def
R6983:6983 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6985:6986 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6988:6988 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6984:6984 proof <> x var
R6987:6987 proof <> y var
R6952:6960 proof <> timepoint syndef
R6991:6994 Coq.Init.Logic <> :type_scope:x_'->'_x not
R6995:7012 proof <> dependenceAliases' def
R7014:7014 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7016:7017 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7019:7019 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7015:7015 proof <> y var
R7018:7018 proof <> x var
R6964:6981 proof <> dependenceAliases' def
R6983:6983 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6985:6986 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6988:6988 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R6984:6984 proof <> x var
R6987:6987 proof <> y var
R7034:7051 proof <> dependenceAliases' def
def 7125:7139 <> computeWriteSet
R7145:7147 proof <> com ind
R7152:7159 proof <> writeset def
R7172:7172 proof <> c var
R7183:7186 proof <> CSeq constr
R7197:7210 proof <> mergeWriteSets def
R7234:7248 proof <> writeToWriteset def
R7253:7258 proof <> comlen def
R7260:7260 proof <> c var
R7213:7227 proof <> computeWriteSet def
R7268:7273 proof <> CBegin constr
R7278:7290 proof <> emptyWriteSet def
def 7314:7344 <> dependencesFromWriteSetAndWrite
R7350:7358 proof <> timepoint syndef
R7366:7373 proof <> writeset def
R7380:7384 proof <> write ind
R7389:7401 proof <> dependenceset def
R7414:7414 proof <> w var
R7425:7429 proof <> Write constr
R7474:7475 proof <> ws var
R7501:7508 Coq.Lists.List <> map def
R7533:7559 proof <> prev_write_timepoints_at_ix var
R7522:7522 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7526:7527 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7529:7529 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R7523:7525 proof <> pwt var
R7528:7528 proof <> t var
def 7583:7600 <> computeDependences
R7606:7608 proof <> com ind
R7613:7625 proof <> dependenceset def
R7638:7638 proof <> c var
R7649:7654 proof <> CBegin constr
R7659:7676 proof <> emptyDependenceSet def
R7682:7685 proof <> CSeq constr
R7715:7732 proof <> computeDependences def
R7765:7779 proof <> computeWriteSet def
R7791:7791 Coq.Init.Datatypes <> :list_scope:x_'++'_x not
R7849:7853 Coq.Init.Datatypes <> :list_scope:x_'++'_x not
R7792:7822 proof <> dependencesFromWriteSetAndWrite def
R7835:7846 proof <> prevwriteset var
R7825:7830 proof <> comlen def
R7832:7832 proof <> c var
R7854:7861 proof <> prevdeps var
prf 7954:7978 <> computeDependence0IsEmpty
R7992:7994 proof <> com ind
R8010:8013 Coq.Init.Logic <> :type_scope:x_'->'_x not
R8034:8036 Coq.Init.Logic <> :type_scope:x_'='_x not
R8014:8031 proof <> computeDependences def
R8033:8033 proof <> c var
R8037:8044 Coq.Lists.List <> nil syndef
R8006:8008 Coq.Init.Logic <> :type_scope:x_'='_x not
R7998:8003 proof <> comlen def
R8005:8005 proof <> c var
prf 8149:8171 <> computeWriteSetInBounds
R8185:8187 proof <> com ind
R8195:8199 proof <> memix syndef
R8206:8214 proof <> timepoint syndef
R8253:8256 Coq.Init.Logic <> :type_scope:x_'->'_x not
R8272:8275 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R8258:8262 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R8271:8271 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R8257:8257 proof <> t var
R8263:8268 proof <> comlen def
R8270:8270 proof <> c var
R8277:8280 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R8276:8276 proof <> t var
R8218:8224 Coq.Lists.List <> In def
R8230:8244 proof <> computeWriteSet def
R8247:8247 proof <> c var
R8250:8251 proof <> ix var
R8226:8226 proof <> t var
R8337:8351 proof <> computeWriteSet def
R8364:8378 proof <> computeWriteSet def
R8364:8378 proof <> computeWriteSet def
R8395:8408 proof <> mergeWriteSets def
R8426:8440 Coq.Lists.List <> in_app_iff thm
R8426:8440 Coq.Lists.List <> in_app_iff thm
R8426:8440 Coq.Lists.List <> in_app_iff thm
R8498:8503 proof <> comlen def
R8511:8516 proof <> comlen def
R8511:8516 proof <> comlen def
R8535:8540 proof <> comlen def
R8548:8553 proof <> comlen def
R8548:8553 proof <> comlen def
R8565:8579 proof <> writeToWriteset def
R8619:8645 proof <> destructInSingletonWriteSet thm
R8619:8645 proof <> destructInSingletonWriteSet thm
prf 8706:8734 <> computeDependencesLexPositive
R8748:8750 proof <> com ind
R8769:8778 proof <> dependence def
R8814:8817 Coq.Init.Logic <> :type_scope:x_'->'_x not
R8818:8838 proof <> dependenceLexPositive def
R8840:8840 proof <> d var
R8782:8788 Coq.Lists.List <> In def
R8793:8810 proof <> computeDependences def
R8812:8812 proof <> c var
R8790:8790 proof <> d var
R8920:8937 proof <> computeDependences def
R8966:8983 proof <> computeDependences def
R8966:8983 proof <> computeDependences def
R9013:9027 Coq.Lists.List <> in_app_iff thm
R9013:9027 Coq.Lists.List <> in_app_iff thm
R9013:9027 Coq.Lists.List <> in_app_iff thm
R9094:9124 proof <> dependencesFromWriteSetAndWrite def
R9140:9149 Coq.Lists.List <> in_map_iff thm
R9140:9149 Coq.Lists.List <> in_map_iff thm
R9193:9215 proof <> computeWriteSetInBounds thm
R9193:9215 proof <> computeWriteSetInBounds thm
R9233:9253 proof <> dependenceLexPositive def
R9340:9357 proof <> computeDependences def
prf 9412:9436 <> computeDependencesInRange
R9450:9452 proof <> com ind
R9471:9480 proof <> dependence def
R9516:9519 Coq.Init.Logic <> :type_scope:x_'->'_x not
R9520:9536 proof <> dependenceInRange def
R9540:9540 proof <> c var
R9538:9538 proof <> d var
R9484:9490 Coq.Lists.List <> In def
R9495:9512 proof <> computeDependences def
R9514:9514 proof <> c var
R9492:9492 proof <> d var
R9620:9637 proof <> computeDependences def
R9652:9669 proof <> computeDependences def
R9652:9669 proof <> computeDependences def
R9687:9701 Coq.Lists.List <> in_app_iff thm
R9687:9701 Coq.Lists.List <> in_app_iff thm
R9687:9701 Coq.Lists.List <> in_app_iff thm
R9732:9762 proof <> dependencesFromWriteSetAndWrite def
R9793:9809 proof <> dependenceInRange def
R9835:9850 proof <> commandIxInRange def
R9870:9879 Coq.Lists.List <> in_map_iff thm
R9870:9879 Coq.Lists.List <> in_map_iff thm
R9947:9969 proof <> computeWriteSetInBounds thm
R9947:9969 proof <> computeWriteSetInBounds thm
R10020:10036 proof <> dependenceInRange def
R10048:10064 proof <> dependenceInRange def
R10122:10137 proof <> commandIxInRange def
R10149:10164 proof <> commandIxInRange def
R10183:10188 proof <> comlen def
R10196:10201 proof <> comlen def
R10196:10201 proof <> comlen def
prf 10269:10294 <> getWriteAt'RangeConsistent
R10308:10310 proof <> com ind
R10317:10319 Coq.Init.Datatypes <> nat ind
R10326:10330 proof <> write ind
R10359:10362 Coq.Init.Logic <> :type_scope:x_'->'_x not
R10369:10372 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R10364:10367 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R10363:10363 proof <> i var
R10374:10377 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R10373:10373 proof <> i var
R10378:10383 proof <> comlen def
R10385:10385 proof <> c var
R10349:10352 Coq.Init.Logic <> :type_scope:x_'='_x not
R10334:10344 proof <> getWriteAt' def
R10348:10348 proof <> i var
R10346:10346 proof <> c var
R10353:10356 Coq.Init.Datatypes <> Some constr
R10358:10358 proof <> w var
R10441:10451 proof <> getWriteAt' def
R10466:10476 proof <> getWriteAt' def
R10466:10476 proof <> getWriteAt' def
R10507:10509 Coq.Init.Datatypes <> nat ind
R10518:10521 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10514:10516 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R10513:10513 proof <> x var
R10517:10517 proof <> y var
R10527:10530 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10523:10525 Coq.Init.Logic <> :type_scope:x_'='_x not
R10522:10522 proof <> x var
R10526:10526 proof <> y var
R10532:10534 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R10531:10531 proof <> x var
R10535:10535 proof <> y var
R10507:10509 Coq.Init.Datatypes <> nat ind
R10518:10521 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10514:10516 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R10513:10513 proof <> x var
R10517:10517 proof <> y var
R10527:10530 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R10523:10525 Coq.Init.Logic <> :type_scope:x_'='_x not
R10522:10522 proof <> x var
R10526:10526 proof <> y var
R10532:10534 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R10531:10531 proof <> x var
R10535:10535 proof <> y var
R10577:10582 proof <> comlen def
R10595:10600 proof <> comlen def
R10595:10600 proof <> comlen def
R10636:10636 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10645:10648 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10637:10642 proof <> comlen def
R10636:10636 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10645:10648 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10637:10642 proof <> comlen def
R10708:10711 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R10713:10716 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10725:10725 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10717:10722 proof <> comlen def
R10708:10711 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R10713:10716 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10725:10725 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R10717:10722 proof <> comlen def
R10745:10755 proof <> getWriteAt' def
R10745:10755 proof <> getWriteAt' def
R10778:10788 Coq.Arith.PeanoNat Nat eqb_neq thm
R10778:10788 Coq.Arith.PeanoNat Nat eqb_neq thm
R10778:10788 Coq.Arith.PeanoNat Nat eqb_neq thm
R10898:10903 proof <> comlen def
R10911:10916 proof <> comlen def
R10911:10916 proof <> comlen def
R10988:10993 proof <> comlen def
R11001:11006 proof <> comlen def
R11001:11006 proof <> comlen def
R11058:11061 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11063:11066 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11075:11075 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11067:11072 proof <> comlen def
R11058:11061 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11063:11066 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11075:11075 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11067:11072 proof <> comlen def
R11105:11115 Coq.Arith.PeanoNat Nat eqb_neq thm
R11105:11115 Coq.Arith.PeanoNat Nat eqb_neq thm
R11105:11115 Coq.Arith.PeanoNat Nat eqb_neq thm
R11282:11292 proof <> getWriteAt' def
prf 11329:11352 <> getWriteAt'RangeComplete
R11366:11368 proof <> com ind
R11375:11377 Coq.Init.Datatypes <> nat ind
R11406:11409 Coq.Init.Logic <> :type_scope:x_'->'_x not
R11410:11417 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R11426:11428 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R11421:11425 proof <> write ind
R11444:11446 Coq.Init.Logic <> :type_scope:x_'='_x not
R11429:11439 proof <> getWriteAt' def
R11443:11443 proof <> i var
R11441:11441 proof <> c var
R11447:11450 Coq.Init.Datatypes <> Some constr
R11452:11452 proof <> w var
R11387:11390 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R11382:11385 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R11381:11381 proof <> i var
R11392:11396 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11405:11405 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11391:11391 proof <> i var
R11397:11402 proof <> comlen def
R11404:11404 proof <> c var
R11508:11518 proof <> getWriteAt' def
R11526:11536 proof <> getWriteAt' def
R11526:11536 proof <> getWriteAt' def
R11551:11556 proof <> comlen def
R11551:11556 proof <> comlen def
R11585:11587 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11577:11579 Coq.Init.Logic <> :type_scope:x_'='_x not
R11581:11583 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11597:11600 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11589:11591 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R11593:11595 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11602:11604 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R11606:11608 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11585:11587 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11577:11579 Coq.Init.Logic <> :type_scope:x_'='_x not
R11581:11583 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11597:11600 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R11589:11591 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R11593:11595 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11602:11604 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R11606:11608 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11705:11714 Coq.Arith.PeanoNat Nat eqb_eq thm
R11705:11714 Coq.Arith.PeanoNat Nat eqb_eq thm
R11705:11714 Coq.Arith.PeanoNat Nat eqb_eq thm
R11733:11738 proof <> comlen def
R11746:11751 proof <> comlen def
R11746:11751 proof <> comlen def
R11884:11887 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R11879:11882 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R11889:11892 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11884:11887 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R11879:11882 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R11889:11892 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R11956:11959 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11961:11963 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11956:11959 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R11961:11963 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R11988:11998 Coq.Arith.PeanoNat Nat eqb_neq thm
R11988:11998 Coq.Arith.PeanoNat Nat eqb_neq thm
R11988:11998 Coq.Arith.PeanoNat Nat eqb_neq thm
R12016:12021 proof <> comlen def
R12029:12034 proof <> comlen def
R12029:12034 proof <> comlen def
R12110:12113 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12105:12108 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R12115:12118 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12110:12113 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12105:12108 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R12115:12118 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12130:12135 proof <> comlen def
R12148:12153 proof <> comlen def
R12148:12153 proof <> comlen def
R12212:12215 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12204:12206 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R12208:12210 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12217:12220 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12212:12215 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12204:12206 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R12208:12210 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12217:12220 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12261:12264 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R12266:12268 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12269:12274 proof <> comlen def
R12261:12264 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R12266:12268 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12269:12274 proof <> comlen def
R12300:12310 Coq.Arith.PeanoNat Nat eqb_neq thm
R12300:12310 Coq.Arith.PeanoNat Nat eqb_neq thm
R12300:12310 Coq.Arith.PeanoNat Nat eqb_neq thm
R12328:12333 proof <> comlen def
R12341:12346 proof <> comlen def
R12341:12346 proof <> comlen def
R12442:12447 proof <> comlen def
prf 12492:12508 <> getWriteAt'OnCSeq
R12522:12524 proof <> com ind
R12531:12535 proof <> write ind
R12576:12578 Coq.Init.Logic <> :type_scope:x_'='_x not
R12539:12549 proof <> getWriteAt' def
R12571:12573 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12563:12568 proof <> comlen def
R12570:12570 proof <> c var
R12552:12555 proof <> CSeq constr
R12559:12559 proof <> w var
R12557:12557 proof <> c var
R12579:12582 Coq.Init.Datatypes <> Some constr
R12584:12584 proof <> w var
R12689:12691 Coq.Init.Logic <> :type_scope:x_'='_x not
R12672:12676 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R12668:12670 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12660:12665 proof <> comlen def
R12677:12677 Coq.Init.Datatypes <> S constr
R12680:12685 proof <> comlen def
R12692:12695 Coq.Init.Datatypes <> true constr
R12689:12691 Coq.Init.Logic <> :type_scope:x_'='_x not
R12672:12676 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R12668:12670 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R12660:12665 proof <> comlen def
R12677:12677 Coq.Init.Datatypes <> S constr
R12680:12685 proof <> comlen def
R12692:12695 Coq.Init.Datatypes <> true constr
R12709:12718 Coq.Arith.PeanoNat Nat eqb_eq thm
R12709:12718 Coq.Arith.PeanoNat Nat eqb_eq thm
R12709:12718 Coq.Arith.PeanoNat Nat eqb_eq thm
R12737:12742 proof <> comlen def
R12750:12755 proof <> comlen def
R12750:12755 proof <> comlen def
prf 12832:12856 <> getWriteAt'DestructOnCSeq
R12870:12872 proof <> com ind
R12880:12882 Coq.Init.Datatypes <> nat ind
R12889:12893 proof <> write ind
R12924:12927 Coq.Init.Logic <> :type_scope:x_'->'_x not
R12952:12954 Coq.Init.Logic <> :type_scope:x_'='_x not
R12928:12938 proof <> getWriteAt' def
R12951:12951 proof <> i var
R12941:12944 proof <> CSeq constr
R12948:12948 proof <> w var
R12946:12946 proof <> c var
R12955:12965 proof <> getWriteAt' def
R12969:12969 proof <> i var
R12967:12967 proof <> c var
R12914:12917 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R12902:12905 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R12901:12901 proof <> i var
R12906:12911 proof <> comlen def
R12913:12913 proof <> c var
R12919:12922 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R12918:12918 proof <> i var
R13052:13055 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R13037:13039 Coq.Init.Logic <> :type_scope:x_'='_x not
R13048:13050 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13040:13045 proof <> comlen def
R13057:13059 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R13069:13071 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13060:13065 proof <> comlen def
R13052:13055 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R13037:13039 Coq.Init.Logic <> :type_scope:x_'='_x not
R13048:13050 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13040:13045 proof <> comlen def
R13057:13059 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R13069:13071 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13060:13065 proof <> comlen def
R13085:13090 proof <> comlen def
R13103:13108 proof <> comlen def
R13103:13108 proof <> comlen def
R13162:13178 proof <> getWriteAt'OnCSeq thm
R13162:13178 proof <> getWriteAt'OnCSeq thm
R13162:13178 proof <> getWriteAt'OnCSeq thm
R13232:13234 Coq.Init.Logic <> :type_scope:x_'='_x not
R13212:13215 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13208:13210 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13200:13205 proof <> comlen def
R13216:13216 Coq.Init.Datatypes <> S constr
R13219:13219 Coq.Init.Datatypes <> S constr
R13222:13227 proof <> comlen def
R13235:13239 Coq.Init.Datatypes <> false constr
R13232:13234 Coq.Init.Logic <> :type_scope:x_'='_x not
R13212:13215 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13208:13210 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13200:13205 proof <> comlen def
R13216:13216 Coq.Init.Datatypes <> S constr
R13219:13219 Coq.Init.Datatypes <> S constr
R13222:13227 proof <> comlen def
R13235:13239 Coq.Init.Datatypes <> false constr
R13253:13263 Coq.Arith.PeanoNat Nat eqb_neq thm
R13253:13263 Coq.Arith.PeanoNat Nat eqb_neq thm
R13253:13263 Coq.Arith.PeanoNat Nat eqb_neq thm
R13323:13325 Coq.Init.Logic <> :type_scope:x_'='_x not
R13308:13311 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13305:13306 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13297:13302 proof <> comlen def
R13312:13312 Coq.Init.Datatypes <> S constr
R13314:13319 proof <> comlen def
R13326:13329 Coq.Init.Datatypes <> true constr
R13323:13325 Coq.Init.Logic <> :type_scope:x_'='_x not
R13308:13311 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13305:13306 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R13297:13302 proof <> comlen def
R13312:13312 Coq.Init.Datatypes <> S constr
R13314:13319 proof <> comlen def
R13326:13329 Coq.Init.Datatypes <> true constr
R13341:13350 Coq.Arith.PeanoNat Nat eqb_eq thm
R13341:13350 Coq.Arith.PeanoNat Nat eqb_eq thm
R13341:13350 Coq.Arith.PeanoNat Nat eqb_eq thm
R13432:13434 Coq.Init.Logic <> :type_scope:x_'='_x not
R13409:13414 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13431:13431 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13415:13415 Coq.Init.Datatypes <> S constr
R13418:13418 Coq.Init.Datatypes <> S constr
R13421:13426 proof <> comlen def
R13435:13439 Coq.Init.Datatypes <> false constr
R13432:13434 Coq.Init.Logic <> :type_scope:x_'='_x not
R13409:13414 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13431:13431 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13415:13415 Coq.Init.Datatypes <> S constr
R13418:13418 Coq.Init.Datatypes <> S constr
R13421:13426 proof <> comlen def
R13435:13439 Coq.Init.Datatypes <> false constr
R13451:13461 Coq.Arith.PeanoNat Nat eqb_neq thm
R13451:13461 Coq.Arith.PeanoNat Nat eqb_neq thm
R13451:13461 Coq.Arith.PeanoNat Nat eqb_neq thm
R13498:13500 Coq.Init.Logic <> :type_scope:x_'='_x not
R13482:13485 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13486:13486 Coq.Init.Datatypes <> S constr
R13489:13494 proof <> comlen def
R13501:13505 Coq.Init.Datatypes <> false constr
R13498:13500 Coq.Init.Logic <> :type_scope:x_'='_x not
R13482:13485 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R13486:13486 Coq.Init.Datatypes <> S constr
R13489:13494 proof <> comlen def
R13501:13505 Coq.Init.Datatypes <> false constr
R13517:13527 Coq.Arith.PeanoNat Nat eqb_neq thm
R13517:13527 Coq.Arith.PeanoNat Nat eqb_neq thm
R13517:13527 Coq.Arith.PeanoNat Nat eqb_neq thm
R13606:13611 proof <> comlen def
R13624:13629 proof <> comlen def
R13624:13629 proof <> comlen def
prf 13658:13677 <> computeWriteSetRange
R13691:13693 proof <> com ind
R13702:13706 proof <> memix syndef
R13713:13715 Coq.Init.Datatypes <> nat ind
R13757:13760 Coq.Init.Logic <> :type_scope:x_'->'_x not
R13767:13770 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R13762:13765 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R13761:13761 proof <> i var
R13772:13775 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R13771:13771 proof <> i var
R13776:13781 proof <> comlen def
R13783:13783 proof <> c var
R13719:13725 Coq.Lists.List <> In def
R13732:13746 proof <> computeWriteSet def
R13749:13749 proof <> c var
R13753:13755 proof <> wix var
R13727:13727 proof <> i var
R13839:13853 proof <> computeWriteSet def
R13868:13882 proof <> computeWriteSet def
R13868:13882 proof <> computeWriteSet def
R13899:13912 proof <> mergeWriteSets def
R13930:13944 Coq.Lists.List <> in_app_iff thm
R13930:13944 Coq.Lists.List <> in_app_iff thm
R13930:13944 Coq.Lists.List <> in_app_iff thm
R14062:14067 proof <> comlen def
R14075:14080 proof <> comlen def
R14075:14080 proof <> comlen def
R14101:14115 proof <> writeToWriteset def
R14210:14226 proof <> singletonWriteSet def
R14243:14255 proof <> addToWriteSet def
R14280:14283 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R14276:14278 Coq.Init.Logic <> :type_scope:x_'='_x not
R14287:14290 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R14280:14283 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R14276:14278 Coq.Init.Logic <> :type_scope:x_'='_x not
R14287:14290 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R14348:14357 Coq.Arith.PeanoNat Nat eqb_eq thm
R14348:14357 Coq.Arith.PeanoNat Nat eqb_eq thm
R14348:14357 Coq.Arith.PeanoNat Nat eqb_eq thm
R14408:14413 proof <> comlen def
R14421:14426 proof <> comlen def
R14421:14426 proof <> comlen def
R14438:14443 proof <> comlen def
R14456:14461 proof <> comlen def
R14456:14461 proof <> comlen def
R14522:14532 Coq.Arith.PeanoNat Nat eqb_neq thm
R14522:14532 Coq.Arith.PeanoNat Nat eqb_neq thm
R14522:14532 Coq.Arith.PeanoNat Nat eqb_neq thm
prf 14675:14701 <> computeWriteSetCharacterBwd
R14717:14719 proof <> com ind
R14728:14732 proof <> memix syndef
R14742:14749 proof <> memvalue syndef
R14756:14758 Coq.Init.Datatypes <> nat ind
R14806:14809 Coq.Init.Logic <> :type_scope:x_'->'_x not
R14810:14816 Coq.Lists.List <> In def
R14822:14836 proof <> computeWriteSet def
R14838:14838 proof <> c var
R14841:14843 proof <> wix var
R14818:14818 proof <> i var
R14781:14784 Coq.Init.Logic <> :type_scope:x_'='_x not
R14766:14776 proof <> getWriteAt' def
R14780:14780 proof <> i var
R14778:14778 proof <> c var
R14785:14788 Coq.Init.Datatypes <> Some constr
R14791:14795 proof <> Write constr
R14801:14804 proof <> wval var
R14797:14799 proof <> wix var
R14991:15005 proof <> computeWriteSet def
R15015:15029 proof <> computeWriteSet def
R15015:15029 proof <> computeWriteSet def
R15041:15054 proof <> mergeWriteSets def
R15067:15081 Coq.Lists.List <> in_app_iff thm
R15067:15081 Coq.Lists.List <> in_app_iff thm
R15067:15081 Coq.Lists.List <> in_app_iff thm
R15157:15182 proof <> getWriteAt'RangeConsistent thm
R15157:15182 proof <> getWriteAt'RangeConsistent thm
R15199:15204 proof <> comlen def
R15217:15222 proof <> comlen def
R15217:15222 proof <> comlen def
R15256:15259 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R15241:15243 Coq.Init.Logic <> :type_scope:x_'='_x not
R15252:15254 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15244:15249 proof <> comlen def
R15261:15263 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R15272:15274 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15264:15269 proof <> comlen def
R15256:15259 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R15241:15243 Coq.Init.Logic <> :type_scope:x_'='_x not
R15252:15254 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15244:15249 proof <> comlen def
R15261:15263 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R15272:15274 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R15264:15269 proof <> comlen def
R15375:15389 proof <> writeToWriteset def
R15415:15431 proof <> singletonWriteSet def
R15443:15455 proof <> addToWriteSet def
R15515:15516 Coq.Init.Logic <> :type_scope:x_'='_x not
R15500:15503 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15504:15504 Coq.Init.Datatypes <> S constr
R15506:15511 proof <> comlen def
R15517:15520 Coq.Init.Datatypes <> true constr
R15515:15516 Coq.Init.Logic <> :type_scope:x_'='_x not
R15500:15503 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15504:15504 Coq.Init.Datatypes <> S constr
R15506:15511 proof <> comlen def
R15517:15520 Coq.Init.Datatypes <> true constr
R15532:15541 Coq.Arith.PeanoNat Nat eqb_eq thm
R15532:15541 Coq.Arith.PeanoNat Nat eqb_eq thm
R15532:15541 Coq.Arith.PeanoNat Nat eqb_eq thm
R15620:15622 Coq.Init.Logic <> :type_scope:x_'='_x not
R15613:15616 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15623:15626 Coq.Init.Datatypes <> true constr
R15620:15622 Coq.Init.Logic <> :type_scope:x_'='_x not
R15613:15616 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R15623:15626 Coq.Init.Datatypes <> true constr
R15637:15648 Coq.Arith.PeanoNat Nat eqb_refl thm
R15637:15648 Coq.Arith.PeanoNat Nat eqb_refl thm
R15680:15689 Coq.Arith.PeanoNat Nat eqb_eq thm
R15680:15689 Coq.Arith.PeanoNat Nat eqb_eq thm
R15680:15689 Coq.Arith.PeanoNat Nat eqb_eq thm
R15777:15780 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R15772:15775 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R15782:15785 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R15786:15791 proof <> comlen def
R15777:15780 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R15772:15775 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R15782:15785 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R15786:15791 proof <> comlen def
R15827:15834 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15843:15845 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15838:15842 proof <> write ind
R15862:15864 Coq.Init.Logic <> :type_scope:x_'='_x not
R15846:15856 proof <> getWriteAt' def
R15865:15868 Coq.Init.Datatypes <> Some constr
R15870:15870 proof <> w var
R15827:15834 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15843:15845 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R15838:15842 proof <> write ind
R15862:15864 Coq.Init.Logic <> :type_scope:x_'='_x not
R15846:15856 proof <> getWriteAt' def
R15865:15868 Coq.Init.Datatypes <> Some constr
R15870:15870 proof <> w var
R15901:15924 proof <> getWriteAt'RangeComplete thm
R15901:15924 proof <> getWriteAt'RangeComplete thm
R16064:16067 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R16068:16068 Coq.Init.Datatypes <> S constr
R16071:16076 proof <> comlen def
R16064:16067 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R16068:16068 Coq.Init.Datatypes <> S constr
R16071:16076 proof <> comlen def
R16106:16116 Coq.Arith.PeanoNat Nat eqb_neq thm
R16106:16116 Coq.Arith.PeanoNat Nat eqb_neq thm
R16106:16116 Coq.Arith.PeanoNat Nat eqb_neq thm
prf 16293:16317 <> destructInWriteToWriteSet
R16333:16337 proof <> write ind
R16344:16346 Coq.Init.Datatypes <> nat ind
R16358:16366 proof <> timepoint syndef
R16377:16381 proof <> memix syndef
R16430:16433 Coq.Init.Logic <> :type_scope:x_'->'_x not
R16439:16441 Coq.Init.Logic <> :type_scope:x_'='_x not
R16434:16438 proof <> curtp var
R16442:16442 proof <> n var
R16389:16395 Coq.Lists.List <> In def
R16404:16418 proof <> writeToWriteset def
R16424:16428 proof <> curix var
R16422:16422 proof <> n var
R16420:16420 proof <> w var
R16397:16401 proof <> curtp var
R16471:16485 proof <> writeToWriteset def
R16515:16541 proof <> destructInSingletonWriteSet thm
R16515:16541 proof <> destructInSingletonWriteSet thm
prf 16640:16666 <> computeWriteSetCharacterFwd
R16682:16684 proof <> com ind
R16693:16697 proof <> memix syndef
R16704:16706 Coq.Init.Datatypes <> nat ind
R16746:16749 Coq.Init.Logic <> :type_scope:x_'->'_x not
R16750:16757 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R16772:16774 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R16764:16771 proof <> memvalue syndef
R16791:16793 Coq.Init.Logic <> :type_scope:x_'='_x not
R16775:16785 proof <> getWriteAt' def
R16790:16790 proof <> i var
R16788:16788 proof <> c var
R16794:16797 Coq.Init.Datatypes <> Some constr
R16800:16804 proof <> Write constr
R16810:16813 proof <> wval var
R16806:16808 proof <> wix var
R16710:16716 Coq.Lists.List <> In def
R16722:16736 proof <> computeWriteSet def
R16739:16739 proof <> c var
R16742:16744 proof <> wix var
R16718:16718 proof <> i var
R16902:16905 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R16897:16900 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R16907:16910 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R16911:16911 Coq.Init.Datatypes <> S constr
R16914:16919 proof <> comlen def
R16902:16905 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R16897:16900 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R16907:16910 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R16911:16911 Coq.Init.Datatypes <> S constr
R16914:16919 proof <> comlen def
R16934:16956 proof <> computeWriteSetInBounds thm
R16934:16956 proof <> computeWriteSetInBounds thm
R16974:16979 proof <> comlen def
R16993:16998 proof <> comlen def
R16993:16998 proof <> comlen def
R17025:17039 proof <> computeWriteSet def
R17053:17067 proof <> computeWriteSet def
R17053:17067 proof <> computeWriteSet def
R17083:17096 proof <> mergeWriteSets def
R17116:17130 Coq.Lists.List <> in_app_iff thm
R17116:17130 Coq.Lists.List <> in_app_iff thm
R17116:17130 Coq.Lists.List <> in_app_iff thm
R17196:17199 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R17200:17205 proof <> comlen def
R17196:17199 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R17200:17205 proof <> comlen def
R17221:17243 proof <> computeWriteSetInBounds thm
R17221:17243 proof <> computeWriteSetInBounds thm
R17348:17372 proof <> getWriteAt'DestructOnCSeq thm
R17348:17372 proof <> getWriteAt'DestructOnCSeq thm
R17348:17372 proof <> getWriteAt'DestructOnCSeq thm
R17348:17372 proof <> getWriteAt'DestructOnCSeq thm
R17454:17456 Coq.Init.Logic <> :type_scope:x_'='_x not
R17465:17466 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R17457:17462 proof <> comlen def
R17454:17456 Coq.Init.Logic <> :type_scope:x_'='_x not
R17465:17466 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R17457:17462 proof <> comlen def
R17477:17501 proof <> destructInWriteToWriteSet thm
R17477:17501 proof <> destructInWriteToWriteSet thm
R17521:17526 proof <> comlen def
R17540:17545 proof <> comlen def
R17540:17545 proof <> comlen def
R17565:17570 proof <> comlen def
R17584:17589 proof <> comlen def
R17584:17589 proof <> comlen def
R17649:17674 proof <> destructInWriteToWriteSet' thm
R17649:17674 proof <> destructInWriteToWriteSet' thm
R17742:17758 proof <> getWriteAt'OnCSeq thm
R17742:17758 proof <> getWriteAt'OnCSeq thm
prf 18066:18096 <> destructDependenceAliasesInCSeq
R18110:18112 proof <> com ind
R18129:18137 proof <> timepoint syndef
R18147:18151 proof <> memix syndef
R18161:18168 proof <> memvalue syndef
R18212:18219 Coq.Init.Logic <> :type_scope:x_'->'_x not
R18279:18286 Coq.Init.Logic <> :type_scope:x_'->'_x not
R18347:18355 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R18287:18304 proof <> dependenceAliases' def
R18322:18325 proof <> CSeq constr
R18331:18335 proof <> Write constr
R18341:18344 proof <> wval var
R18337:18339 proof <> wix var
R18328:18328 proof <> c var
R18306:18306 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18313:18314 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18319:18319 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18307:18312 proof <> tbegin var
R18315:18318 proof <> tend var
R18356:18356 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18464:18473 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18534:18534 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18376:18379 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18361:18363 Coq.Init.Logic <> :type_scope:x_'='_x not
R18357:18360 proof <> tend var
R18372:18374 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18364:18369 proof <> comlen def
R18371:18371 proof <> c var
R18380:18387 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R18408:18410 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R18400:18407 proof <> memvalue syndef
R18411:18411 Coq.Init.Logic <> :type_scope:x_'='_x not
R18433:18436 Coq.Init.Logic <> :type_scope:x_'='_x not
R18412:18422 proof <> getWriteAt' def
R18427:18432 proof <> tbegin var
R18425:18425 proof <> c var
R18437:18440 Coq.Init.Datatypes <> Some constr
R18443:18447 proof <> Write constr
R18453:18462 proof <> wval_begin var
R18449:18451 proof <> wix var
R18494:18497 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18478:18481 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R18474:18477 proof <> tend var
R18490:18492 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18482:18487 proof <> comlen def
R18489:18489 proof <> c var
R18498:18515 proof <> dependenceAliases' def
R18533:18533 proof <> c var
R18517:18517 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18524:18525 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18530:18530 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18518:18523 proof <> tbegin var
R18526:18529 proof <> tend var
R18220:18236 proof <> dependenceInRange def
R18254:18257 proof <> CSeq constr
R18263:18267 proof <> Write constr
R18273:18276 proof <> wval var
R18269:18271 proof <> wix var
R18260:18260 proof <> c var
R18238:18238 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18245:18246 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18251:18251 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18239:18244 proof <> tbegin var
R18247:18250 proof <> tend var
R18176:18196 proof <> dependenceLexPositive def
R18198:18198 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18205:18206 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18211:18211 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R18199:18204 proof <> tbegin var
R18207:18210 proof <> tend var
R18596:18596 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18616:18621 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18654:18654 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18601:18603 Coq.Init.Logic <> :type_scope:x_'='_x not
R18612:18614 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18604:18609 proof <> comlen def
R18641:18644 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18626:18628 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R18637:18639 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18629:18634 proof <> comlen def
R18649:18652 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R18596:18596 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18616:18621 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18654:18654 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R18601:18603 Coq.Init.Logic <> :type_scope:x_'='_x not
R18612:18614 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18604:18609 proof <> comlen def
R18641:18644 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R18626:18628 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R18637:18639 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18629:18634 proof <> comlen def
R18649:18652 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R18667:18683 proof <> dependenceInRange def
R18701:18716 proof <> commandIxInRange def
R18802:18819 proof <> dependenceAliases' def
R18890:18892 Coq.Init.Logic <> :type_scope:x_'='_x not
R18874:18877 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18870:18872 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18862:18867 proof <> comlen def
R18878:18878 Coq.Init.Datatypes <> S constr
R18881:18886 proof <> comlen def
R18893:18896 Coq.Init.Datatypes <> true constr
R18890:18892 Coq.Init.Logic <> :type_scope:x_'='_x not
R18874:18877 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18870:18872 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R18862:18867 proof <> comlen def
R18878:18878 Coq.Init.Datatypes <> S constr
R18881:18886 proof <> comlen def
R18893:18896 Coq.Init.Datatypes <> true constr
R18908:18917 Coq.Arith.PeanoNat Nat eqb_eq thm
R18908:18917 Coq.Arith.PeanoNat Nat eqb_eq thm
R18908:18917 Coq.Arith.PeanoNat Nat eqb_eq thm
R18986:18988 Coq.Init.Logic <> :type_scope:x_'='_x not
R18970:18973 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18974:18974 Coq.Init.Datatypes <> S constr
R18977:18982 proof <> comlen def
R18989:18993 Coq.Init.Datatypes <> false constr
R18986:18988 Coq.Init.Logic <> :type_scope:x_'='_x not
R18970:18973 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R18974:18974 Coq.Init.Datatypes <> S constr
R18977:18982 proof <> comlen def
R18989:18993 Coq.Init.Datatypes <> false constr
R19006:19026 proof <> dependenceLexPositive def
R19058:19068 Coq.Arith.PeanoNat Nat eqb_neq thm
R19058:19068 Coq.Arith.PeanoNat Nat eqb_neq thm
R19058:19068 Coq.Arith.PeanoNat Nat eqb_neq thm
R19142:19152 proof <> getWriteAt' def
R19142:19152 proof <> getWriteAt' def
R19193:19200 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19209:19211 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19204:19208 proof <> write ind
R19232:19234 Coq.Init.Logic <> :type_scope:x_'='_x not
R19212:19222 proof <> getWriteAt' def
R19235:19238 Coq.Init.Datatypes <> Some constr
R19240:19240 proof <> w var
R19193:19200 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19209:19211 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R19204:19208 proof <> write ind
R19232:19234 Coq.Init.Logic <> :type_scope:x_'='_x not
R19212:19222 proof <> getWriteAt' def
R19235:19238 Coq.Init.Datatypes <> Some constr
R19240:19240 proof <> w var
R19252:19275 proof <> getWriteAt'RangeComplete thm
R19252:19275 proof <> getWriteAt'RangeComplete thm
R19287:19303 proof <> dependenceInRange def
R19319:19334 proof <> commandIxInRange def
R19365:19385 proof <> dependenceLexPositive def
R19495:19501 proof <> writeIx def
R19565:19567 Coq.Init.Logic <> :type_scope:x_'='_x not
R19565:19567 Coq.Init.Logic <> :type_scope:x_'='_x not
R19670:19687 proof <> dependenceAliases' def
R19765:19768 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R19750:19752 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R19761:19763 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R19753:19758 proof <> comlen def
R19775:19778 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R19765:19768 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R19750:19752 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R19761:19763 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R19753:19758 proof <> comlen def
R19775:19778 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R19792:19812 proof <> dependenceLexPositive def
R19841:19857 proof <> dependenceInRange def
R19875:19890 proof <> commandIxInRange def
R19931:19955 proof <> getWriteAt'DestructOnCSeq thm
R19931:19955 proof <> getWriteAt'DestructOnCSeq thm
R19931:19955 proof <> getWriteAt'DestructOnCSeq thm
R19931:19955 proof <> getWriteAt'DestructOnCSeq thm
R19974:19998 proof <> getWriteAt'DestructOnCSeq thm
R19974:19998 proof <> getWriteAt'DestructOnCSeq thm
R19974:19998 proof <> getWriteAt'DestructOnCSeq thm
R19974:19998 proof <> getWriteAt'DestructOnCSeq thm
R20016:20033 proof <> dependenceAliases' def
R20059:20062 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R20071:20073 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20063:20068 proof <> comlen def
R20059:20062 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R20071:20073 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20063:20068 proof <> comlen def
R20192:20209 proof <> dependenceAliases' def
R20258:20274 proof <> getWriteAt'OnCSeq thm
R20258:20274 proof <> getWriteAt'OnCSeq thm
R20258:20274 proof <> getWriteAt'OnCSeq thm
R20308:20311 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R20293:20295 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R20304:20306 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20296:20301 proof <> comlen def
R20318:20321 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R20308:20311 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R20293:20295 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R20304:20306 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R20296:20301 proof <> comlen def
R20318:20321 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R20335:20355 proof <> dependenceLexPositive def
R20370:20386 proof <> dependenceInRange def
R20402:20417 proof <> commandIxInRange def
R20515:20517 Coq.Init.Logic <> :type_scope:x_'='_x not
R20470:20480 proof <> getWriteAt' def
R20484:20487 proof <> CSeq constr
R20492:20496 proof <> Write constr
R20518:20528 proof <> getWriteAt' def
R20515:20517 Coq.Init.Logic <> :type_scope:x_'='_x not
R20470:20480 proof <> getWriteAt' def
R20484:20487 proof <> CSeq constr
R20492:20496 proof <> Write constr
R20518:20528 proof <> getWriteAt' def
R20549:20573 proof <> getWriteAt'DestructOnCSeq thm
R20549:20573 proof <> getWriteAt'DestructOnCSeq thm
R20864:20881 proof <> dependenceAliases' def
R20894:20918 proof <> getWriteAt'DestructOnCSeq thm
R20894:20918 proof <> getWriteAt'DestructOnCSeq thm
R20894:20918 proof <> getWriteAt'DestructOnCSeq thm
R20894:20918 proof <> getWriteAt'DestructOnCSeq thm
R20931:20955 proof <> getWriteAt'DestructOnCSeq thm
R20931:20955 proof <> getWriteAt'DestructOnCSeq thm
R20931:20955 proof <> getWriteAt'DestructOnCSeq thm
R20931:20955 proof <> getWriteAt'DestructOnCSeq thm
R20967:20984 proof <> dependenceAliases' def
R21023:21039 proof <> dependenceInRange def
R21055:21070 proof <> commandIxInRange def
R21119:21135 proof <> dependenceInRange def
R21151:21166 proof <> commandIxInRange def
R21197:21217 proof <> dependenceLexPositive def
prf 21258:21283 <> dependenceInRangeInclusive
R21297:21306 proof <> dependence def
R21313:21315 proof <> com ind
R21322:21326 proof <> write ind
R21352:21355 Coq.Init.Logic <> :type_scope:x_'->'_x not
R21356:21372 proof <> dependenceInRange def
R21378:21381 proof <> CSeq constr
R21385:21385 proof <> w var
R21383:21383 proof <> c var
R21374:21374 proof <> d var
R21331:21347 proof <> dependenceInRange def
R21351:21351 proof <> c var
R21349:21349 proof <> d var
R21405:21421 proof <> dependenceInRange def
R21431:21446 proof <> commandIxInRange def
prf 21504:21530 <> computeDependencesAlias'Fwd
R21544:21546 proof <> com ind
R21562:21571 proof <> dependence def
R21607:21611 Coq.Init.Logic <> :type_scope:x_'->'_x not
R21612:21629 proof <> dependenceAliases' def
R21634:21634 proof <> c var
R21631:21631 proof <> d var
R21575:21581 Coq.Lists.List <> In def
R21586:21603 proof <> computeDependences def
R21605:21605 proof <> c var
R21583:21583 proof <> d var
R21691:21708 proof <> computeDependences def
R21723:21740 proof <> computeDependences def
R21723:21740 proof <> computeDependences def
R21757:21787 proof <> dependencesFromWriteSetAndWrite def
R21829:21843 Coq.Lists.List <> in_app_iff thm
R21829:21843 Coq.Lists.List <> in_app_iff thm
R21829:21843 Coq.Lists.List <> in_app_iff thm
R21873:21887 Coq.Lists.List <> in_map_iff thm
R21873:21887 Coq.Lists.List <> in_map_iff thm
R21904:21909 proof <> comlen def
R21922:21927 proof <> comlen def
R21922:21927 proof <> comlen def
R22029:22046 proof <> dependenceAliases' def
R22073:22076 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R22068:22071 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R22079:22082 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R22083:22088 proof <> comlen def
R22073:22076 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R22068:22071 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R22079:22082 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R22083:22088 proof <> comlen def
R22102:22124 proof <> computeWriteSetInBounds thm
R22102:22124 proof <> computeWriteSetInBounds thm
R22170:22172 Coq.Init.Logic <> :type_scope:x_'='_x not
R22154:22157 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22158:22158 Coq.Init.Datatypes <> S constr
R22161:22166 proof <> comlen def
R22173:22177 Coq.Init.Datatypes <> false constr
R22170:22172 Coq.Init.Logic <> :type_scope:x_'='_x not
R22154:22157 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22158:22158 Coq.Init.Datatypes <> S constr
R22161:22166 proof <> comlen def
R22173:22177 Coq.Init.Datatypes <> false constr
R22191:22201 Coq.Arith.PeanoNat Nat eqb_neq thm
R22191:22201 Coq.Arith.PeanoNat Nat eqb_neq thm
R22191:22201 Coq.Arith.PeanoNat Nat eqb_neq thm
R22243:22245 Coq.Init.Logic <> :type_scope:x_'='_x not
R22231:22234 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22223:22228 proof <> comlen def
R22235:22240 proof <> comlen def
R22246:22249 Coq.Init.Datatypes <> true constr
R22243:22245 Coq.Init.Logic <> :type_scope:x_'='_x not
R22231:22234 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R22223:22228 proof <> comlen def
R22235:22240 proof <> comlen def
R22246:22249 Coq.Init.Datatypes <> true constr
R22263:22272 Coq.Arith.PeanoNat Nat eqb_eq thm
R22263:22272 Coq.Arith.PeanoNat Nat eqb_eq thm
R22263:22272 Coq.Arith.PeanoNat Nat eqb_eq thm
R22325:22351 proof <> computeWriteSetCharacterFwd thm
R22325:22351 proof <> computeWriteSetCharacterFwd thm
R22480:22510 proof <> destructDependenceAliasesInCSeq thm
R22480:22510 proof <> destructDependenceAliasesInCSeq thm
R22523:22551 proof <> computeDependencesLexPositive thm
R22523:22551 proof <> computeDependencesLexPositive thm
R22578:22602 proof <> computeDependencesInRange thm
R22578:22602 proof <> computeDependencesInRange thm
R22620:22645 proof <> dependenceInRangeInclusive thm
R22620:22645 proof <> dependenceInRangeInclusive thm
R22686:22689 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R22671:22673 Coq.Init.Logic <> :type_scope:x_'='_x not
R22682:22684 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22674:22679 proof <> comlen def
R22692:22695 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R22704:22705 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22696:22701 proof <> comlen def
R22686:22689 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R22671:22673 Coq.Init.Logic <> :type_scope:x_'='_x not
R22682:22684 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22674:22679 proof <> comlen def
R22692:22695 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R22704:22705 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R22696:22701 proof <> comlen def
R22773:22797 proof <> computeDependencesInRange thm
R22773:22797 proof <> computeDependencesInRange thm
R22818:22834 proof <> dependenceInRange def
R22855:22870 proof <> commandIxInRange def
prf 23143:23173 <> dependenceInRangeDestructOnCSeq
R23187:23196 proof <> dependence def
R23203:23205 proof <> com ind
R23212:23216 proof <> write ind
R23250:23253 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23275:23278 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23302:23305 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23306:23322 proof <> dependenceInRange def
R23326:23326 proof <> c var
R23324:23324 proof <> d var
R23279:23299 proof <> dependenceLexPositive def
R23301:23301 proof <> d var
R23259:23262 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R23254:23256 Coq.Init.Datatypes <> snd def
R23258:23258 proof <> d var
R23271:23273 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R23263:23268 proof <> comlen def
R23270:23270 proof <> c var
R23220:23236 proof <> dependenceInRange def
R23241:23244 proof <> CSeq constr
R23248:23248 proof <> w var
R23246:23246 proof <> c var
R23238:23238 proof <> d var
R23345:23361 proof <> dependenceInRange def
R23373:23388 proof <> commandIxInRange def
R23400:23420 proof <> dependenceLexPositive def
prf 23478:23503 <> computeDependenceAlias'Bwd
R23519:23521 proof <> com ind
R23536:23545 proof <> dependence def
R23571:23574 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23596:23599 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23623:23627 Coq.Init.Logic <> :type_scope:x_'->'_x not
R23628:23634 Coq.Lists.List <> In def
R23639:23656 proof <> computeDependences def
R23658:23658 proof <> c var
R23636:23636 proof <> d var
R23600:23620 proof <> dependenceLexPositive def
R23622:23622 proof <> d var
R23575:23591 proof <> dependenceInRange def
R23595:23595 proof <> c var
R23593:23593 proof <> d var
R23549:23566 proof <> dependenceAliases' def
R23570:23570 proof <> c var
R23568:23568 proof <> d var
R23812:23842 proof <> destructDependenceAliasesInCSeq thm
R23812:23842 proof <> destructDependenceAliasesInCSeq thm
R23950:23967 proof <> computeDependences def
R23975:23992 proof <> computeDependences def
R23975:23992 proof <> computeDependences def
R24006:24036 proof <> dependencesFromWriteSetAndWrite def
R24051:24065 Coq.Lists.List <> in_app_iff thm
R24051:24065 Coq.Lists.List <> in_app_iff thm
R24051:24065 Coq.Lists.List <> in_app_iff thm
R24137:24151 Coq.Lists.List <> in_map_iff thm
R24137:24151 Coq.Lists.List <> in_map_iff thm
R24137:24151 Coq.Lists.List <> in_map_iff thm
R24190:24195 proof <> comlen def
R24203:24208 proof <> comlen def
R24203:24208 proof <> comlen def
R24234:24245 Coq.Arith.PeanoNat Nat add_comm thm
R24234:24245 Coq.Arith.PeanoNat Nat add_comm thm
R24234:24245 Coq.Arith.PeanoNat Nat add_comm thm
R24272:24298 proof <> computeWriteSetCharacterBwd thm
R24272:24298 proof <> computeWriteSetCharacterBwd thm
R24386:24403 proof <> computeDependences def
R24415:24432 proof <> computeDependences def
R24415:24432 proof <> computeDependences def
R24446:24476 proof <> dependencesFromWriteSetAndWrite def
R24491:24505 Coq.Lists.List <> in_app_iff thm
R24491:24505 Coq.Lists.List <> in_app_iff thm
R24491:24505 Coq.Lists.List <> in_app_iff thm
R24587:24603 proof <> dependenceInRange def
R24605:24605 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24607:24608 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24611:24611 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24587:24603 proof <> dependenceInRange def
R24605:24605 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24607:24608 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24611:24611 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R24627:24657 proof <> dependenceInRangeDestructOnCSeq thm
R24627:24657 proof <> dependenceInRangeDestructOnCSeq thm
R24847:24863 proof <> dependenceInRange def
R24883:24898 proof <> commandIxInRange def
def 24955:24964 <> runProgram
R24971:24973 proof <> com ind
R24989:24994 proof <> memory def
R24999:25004 proof <> memory def
R25017:25017 proof <> p var
R25028:25033 proof <> CBegin constr
R25038:25047 proof <> initmemory var
R25053:25056 proof <> CSeq constr
R25066:25079 proof <> writeToMemory' def
R25085:25094 proof <> runProgram def
R25099:25108 proof <> initmemory var
def 25168:25170 <> ceq
R25180:25182 proof <> com ind
R25218:25223 proof <> memory def
R25227:25227 Coq.Init.Logic <> :type_scope:x_'='_x not
R25251:25255 Coq.Init.Logic <> :type_scope:x_'='_x not
R25280:25280 Coq.Init.Logic <> :type_scope:x_'='_x not
R25228:25237 proof <> runProgram def
R25241:25250 proof <> initmemory var
R25239:25239 proof <> c var
R25256:25265 proof <> runProgram def
R25270:25279 proof <> initmemory var
R25267:25268 proof <> c' var
R25309:25311 proof <> ceq def
not 25293:25293 <> ::x_'==='_x
prf 25342:25349 <> ceq_refl
R25363:25365 proof <> com ind
R25370:25374 proof <> ::x_'==='_x not
R25369:25369 proof <> c var
R25375:25375 proof <> c var
R25404:25406 proof <> ceq def
prf 25446:25458 <> ceq_symmetric
R25474:25476 proof <> com ind
R25488:25492 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R25481:25485 proof <> ::x_'==='_x not
R25480:25480 proof <> c var
R25486:25487 proof <> c' var
R25495:25499 proof <> ::x_'==='_x not
R25493:25494 proof <> c' var
R25500:25500 proof <> c var
R25529:25531 proof <> ceq def
def 25592:25601 <> com_append
R25610:25612 proof <> com ind
R25617:25619 proof <> com ind
R25632:25633 proof <> c' var
R25644:25649 proof <> CBegin constr
R25654:25654 proof <> c var
R25660:25663 proof <> CSeq constr
R25673:25676 proof <> CSeq constr
R25680:25689 proof <> com_append def
R25694:25695 proof <> c' var
R25692:25692 proof <> c var
R25735:25744 proof <> com_append def
not 25718:25718 <> ::x_'+++'_x
prf 25775:25786 <> ceq_add_cseq
R25806:25808 proof <> com ind
R25815:25819 proof <> write ind
R25833:25836 Coq.Init.Logic <> :type_scope:x_'->'_x not
R25837:25837 proof <> ::x_'==='_x not
R25847:25854 proof <> ::x_'==='_x not
R25865:25865 proof <> ::x_'==='_x not
R25838:25841 proof <> CSeq constr
R25846:25846 proof <> w var
R25843:25844 proof <> cn var
R25855:25858 proof <> CSeq constr
R25864:25864 proof <> w var
R25860:25862 proof <> cn' var
R25825:25829 proof <> ::x_'==='_x not
R25823:25824 proof <> cn var
R25830:25832 proof <> cn' var
R25894:25896 proof <> ceq def
R25908:25917 proof <> runProgram def
R25927:25936 proof <> runProgram def
R25927:25936 proof <> runProgram def
R25958:25960 proof <> ceq def
prf 26039:26066 <> runprogram_distribute_append
R26085:26087 proof <> com ind
R26108:26113 proof <> memory def
R26148:26150 Coq.Init.Logic <> :type_scope:x_'='_x not
R26117:26126 proof <> runProgram def
R26141:26147 proof <> initmem var
R26131:26135 proof <> ::x_'+++'_x not
R26129:26130 proof <> cn var
R26136:26138 proof <> cn' var
R26151:26160 proof <> runProgram def
R26167:26176 proof <> runProgram def
R26181:26187 proof <> initmem var
R26178:26179 proof <> cn var
R26162:26164 proof <> cn' var
R26274:26283 proof <> com_append def
R26291:26300 proof <> com_append def
R26291:26300 proof <> com_append def
R26312:26321 proof <> runProgram def
R26329:26338 proof <> runProgram def
R26329:26338 proof <> runProgram def
R26388:26397 proof <> com_append def
R26409:26418 proof <> runProgram def
R26426:26435 proof <> runProgram def
R26426:26435 proof <> runProgram def
prf 26584:26598 <> ceq_append_weak
R26619:26621 proof <> com ind
R26634:26636 Coq.Init.Logic <> :type_scope:x_'->'_x not
R26645:26649 proof <> ::x_'==='_x not
R26639:26643 proof <> ::x_'+++'_x not
R26637:26638 proof <> cl var
R26644:26644 proof <> c var
R26652:26656 proof <> ::x_'+++'_x not
R26650:26651 proof <> cr var
R26657:26657 proof <> c var
R26627:26631 proof <> ::x_'==='_x not
R26625:26626 proof <> cl var
R26632:26633 proof <> cr var
R26712:26721 proof <> com_append def
R26729:26738 proof <> com_append def
R26729:26738 proof <> com_append def
R26749:26760 proof <> ceq_add_cseq thm
R26749:26760 proof <> ceq_add_cseq thm
R26804:26813 proof <> com_append def
prf 26839:26855 <> ceq_append_strong
R26881:26883 proof <> com ind
R26896:26899 Coq.Init.Logic <> :type_scope:x_'->'_x not
R26911:26914 Coq.Init.Logic <> :type_scope:x_'->'_x not
R26925:26929 proof <> ::x_'==='_x not
R26917:26921 proof <> ::x_'+++'_x not
R26915:26916 proof <> cl var
R26922:26924 proof <> cl' var
R26932:26936 proof <> ::x_'+++'_x not
R26930:26931 proof <> cr var
R26937:26939 proof <> cr' var
R26903:26907 proof <> ::x_'==='_x not
R26900:26902 proof <> cl' var
R26908:26910 proof <> cr' var
R26889:26893 proof <> ::x_'==='_x not
R26887:26888 proof <> cl var
R26894:26895 proof <> cr var
R26968:26970 proof <> ceq def
R26987:26989 proof <> ceq def
R27007:27009 proof <> ceq def
R27032:27059 proof <> runprogram_distribute_append thm
R27032:27059 proof <> runprogram_distribute_append thm
R27032:27059 proof <> runprogram_distribute_append thm
R27072:27099 proof <> runprogram_distribute_append thm
R27072:27099 proof <> runprogram_distribute_append thm
R27072:27099 proof <> runprogram_distribute_append thm
prf 27158:27176 <> ceq_switch_no_alias
R27198:27202 proof <> memix syndef
R27219:27226 proof <> memvalue syndef
R27246:27253 Coq.Init.Logic <> :type_scope:x_'->'_x not
R27310:27323 proof <> ::x_'==='_x not
R27254:27257 proof <> CSeq constr
R27293:27297 proof <> Write constr
R27304:27308 proof <> wval2 var
R27299:27302 proof <> wix2 var
R27260:27263 proof <> CSeq constr
R27273:27277 proof <> Write constr
R27284:27288 proof <> wval1 var
R27279:27282 proof <> wix1 var
R27265:27270 proof <> CBegin constr
R27324:27327 proof <> CSeq constr
R27363:27367 proof <> Write constr
R27374:27378 proof <> wval1 var
R27369:27372 proof <> wix1 var
R27330:27333 proof <> CSeq constr
R27343:27347 proof <> Write constr
R27354:27358 proof <> wval2 var
R27349:27352 proof <> wix2 var
R27335:27340 proof <> CBegin constr
R27238:27241 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R27234:27237 proof <> wix1 var
R27242:27245 proof <> wix2 var
R27409:27411 proof <> ceq def
R27433:27442 proof <> runProgram def
R27454:27467 proof <> writeToMemory' def
R27478:27502 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R27478:27502 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R27533:27536 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R27526:27528 Coq.Init.Logic <> :type_scope:x_'='_x not
R27538:27541 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R27533:27536 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R27526:27528 Coq.Init.Logic <> :type_scope:x_'='_x not
R27538:27541 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R27594:27606 proof <> writeToMemory def
R27631:27633 Coq.Init.Logic <> :type_scope:x_'='_x not
R27623:27626 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27634:27637 Coq.Init.Datatypes <> true constr
R27631:27633 Coq.Init.Logic <> :type_scope:x_'='_x not
R27623:27626 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27634:27637 Coq.Init.Datatypes <> true constr
R27649:27658 Coq.Arith.PeanoNat Nat eqb_eq thm
R27649:27658 Coq.Arith.PeanoNat Nat eqb_eq thm
R27649:27658 Coq.Arith.PeanoNat Nat eqb_eq thm
R27690:27692 Coq.Init.Logic <> :type_scope:x_'='_x not
R27682:27685 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27693:27697 Coq.Init.Datatypes <> false constr
R27690:27692 Coq.Init.Logic <> :type_scope:x_'='_x not
R27682:27685 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27693:27697 Coq.Init.Datatypes <> false constr
R27709:27719 Coq.Arith.PeanoNat Nat eqb_neq thm
R27709:27719 Coq.Arith.PeanoNat Nat eqb_neq thm
R27709:27719 Coq.Arith.PeanoNat Nat eqb_neq thm
R27778:27790 proof <> writeToMemory def
R27821:27823 Coq.Init.Logic <> :type_scope:x_'='_x not
R27813:27816 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27824:27828 Coq.Init.Datatypes <> false constr
R27821:27823 Coq.Init.Logic <> :type_scope:x_'='_x not
R27813:27816 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R27824:27828 Coq.Init.Datatypes <> false constr
R27840:27850 Coq.Arith.PeanoNat Nat eqb_neq thm
R27840:27850 Coq.Arith.PeanoNat Nat eqb_neq thm
R27840:27850 Coq.Arith.PeanoNat Nat eqb_neq thm
def 28399:28420 <> scheduleMappingWitness
R28434:28437 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28438:28440 Coq.Init.Datatypes <> nat ind
R28431:28433 Coq.Init.Datatypes <> nat ind
R28450:28452 proof <> com ind
R28487:28492 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28475:28477 Coq.Init.Logic <> :type_scope:x_'='_x not
R28467:28472 proof <> comlen def
R28474:28474 proof <> c var
R28478:28483 proof <> comlen def
R28485:28486 proof <> c' var
R28510:28515 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28493:28502 Coq.Logic.ExtensionalityFacts <> is_inverse def
R28506:28509 proof <> sinv var
R28504:28504 proof <> s var
R28527:28529 Coq.Init.Datatypes <> nat ind
R28556:28578 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28587:28590 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28582:28585 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R28579:28579 proof <> s var
R28581:28581 proof <> i var
R28606:28628 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28594:28597 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R28591:28591 proof <> s var
R28593:28593 proof <> i var
R28598:28603 proof <> comlen def
R28605:28605 proof <> c var
R28640:28643 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28635:28638 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R28629:28632 proof <> sinv var
R28634:28634 proof <> i var
R28663:28685 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28650:28653 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R28644:28647 proof <> sinv var
R28649:28649 proof <> i var
R28654:28659 proof <> comlen def
R28661:28662 proof <> c' var
R28724:28746 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28701:28703 Coq.Init.Logic <> :type_scope:x_'='_x not
R28686:28696 proof <> getWriteAt' def
R28700:28700 proof <> i var
R28698:28698 proof <> c var
R28704:28714 proof <> getWriteAt' def
R28720:28720 proof <> s var
R28722:28722 proof <> i var
R28716:28717 proof <> c' var
R28769:28771 Coq.Init.Logic <> :type_scope:x_'='_x not
R28747:28757 proof <> getWriteAt' def
R28762:28765 proof <> sinv var
R28767:28767 proof <> i var
R28759:28759 proof <> c var
R28772:28782 proof <> getWriteAt' def
R28787:28787 proof <> i var
R28784:28785 proof <> c' var
R28539:28542 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R28534:28537 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R28533:28533 proof <> i var
R28544:28547 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R28543:28543 proof <> i var
R28548:28553 proof <> comlen def
R28555:28555 proof <> c var
prf 28798:28828 <> scheduleMappingWitnessSymmetric
R28850:28853 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28854:28856 Coq.Init.Datatypes <> nat ind
R28847:28849 Coq.Init.Datatypes <> nat ind
R28866:28868 proof <> com ind
R28910:28913 Coq.Init.Logic <> :type_scope:x_'->'_x not
R28914:28935 proof <> scheduleMappingWitness def
R28947:28947 proof <> c var
R28944:28945 proof <> c' var
R28942:28942 proof <> s var
R28937:28940 proof <> sinv var
R28876:28897 proof <> scheduleMappingWitness def
R28908:28909 proof <> c' var
R28906:28906 proof <> c var
R28901:28904 proof <> sinv var
R28899:28899 proof <> s var
R28966:28987 proof <> scheduleMappingWitness def
R29065:29074 Coq.Logic.ExtensionalityFacts <> is_inverse def
R29084:29093 Coq.Logic.ExtensionalityFacts <> is_inverse def
def 29343:29367 <> applyScheduleToDependence
R29376:29379 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29380:29382 Coq.Init.Datatypes <> nat ind
R29373:29375 Coq.Init.Datatypes <> nat ind
R29389:29398 proof <> dependence def
R29403:29412 proof <> dependence def
R29425:29425 proof <> d var
R29436:29436 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29439:29440 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29443:29443 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29448:29448 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29453:29454 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29459:29459 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R29449:29449 proof <> s var
R29455:29455 proof <> s var
def 29480:29505 <> scheduleRespectsDependence
R29514:29517 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29518:29520 Coq.Init.Datatypes <> nat ind
R29511:29513 Coq.Init.Datatypes <> nat ind
R29527:29536 proof <> dependence def
R29551:29571 proof <> dependenceLexPositive def
R29574:29598 proof <> applyScheduleToDependence def
R29602:29602 proof <> d var
R29600:29600 proof <> s var
def 29618:29646 <> scheduleRespectsDependenceSet
R29655:29658 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29659:29661 Coq.Init.Datatypes <> nat ind
R29652:29654 Coq.Init.Datatypes <> nat ind
R29669:29681 proof <> dependenceset def
R29705:29714 proof <> dependence def
R29730:29733 Coq.Init.Logic <> :type_scope:x_'->'_x not
R29734:29759 proof <> scheduleRespectsDependence def
R29763:29763 proof <> d var
R29761:29761 proof <> s var
R29718:29724 Coq.Lists.List <> In def
R29728:29729 proof <> ds var
R29726:29726 proof <> d var
def 30138:30152 <> validDependence
R30158:30160 proof <> com ind
R30167:30176 proof <> dependence def
R30213:30216 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30191:30208 proof <> dependenceAliases' def
R30212:30212 proof <> c var
R30210:30210 proof <> d var
R30238:30241 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30217:30233 proof <> dependenceInRange def
R30237:30237 proof <> c var
R30235:30235 proof <> d var
R30242:30262 proof <> dependenceLexPositive def
R30264:30264 proof <> d var
R30279:30293 proof <> validDependence def
def 30308:30328 <> completeDependenceSet
R30334:30336 proof <> com ind
R30344:30356 proof <> dependenceset def
R30382:30391 proof <> dependence def
R30399:30399 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30435:30444 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30480:30480 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30419:30422 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30423:30429 Coq.Lists.List <> In def
R30433:30434 proof <> ds var
R30431:30431 proof <> d var
R30400:30414 proof <> validDependence def
R30418:30418 proof <> d var
R30416:30416 proof <> c var
R30457:30460 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30461:30475 proof <> validDependence def
R30479:30479 proof <> d var
R30477:30477 proof <> c var
R30445:30451 Coq.Lists.List <> In def
R30455:30456 proof <> ds var
R30453:30453 proof <> d var
prf 30585:30619 <> emptyDependenceSetImpliesNoAliasing
R30636:30638 Coq.Init.Datatypes <> nat ind
R30645:30647 proof <> com ind
R30688:30691 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30720:30723 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30750:30754 Coq.Init.Logic <> :type_scope:x_'->'_x not
R30755:30762 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30774:30776 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30769:30773 proof <> write ind
R30801:30804 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30792:30794 Coq.Init.Logic <> :type_scope:x_'='_x not
R30777:30787 proof <> getWriteAt' def
R30791:30791 proof <> i var
R30789:30789 proof <> c var
R30795:30798 Coq.Init.Datatypes <> Some constr
R30800:30800 proof <> w var
R30830:30833 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R30820:30822 Coq.Init.Logic <> :type_scope:x_'='_x not
R30805:30815 proof <> getWriteAt' def
R30819:30819 proof <> j var
R30817:30817 proof <> c var
R30823:30826 Coq.Init.Datatypes <> Some constr
R30828:30829 proof <> w' var
R30843:30846 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R30834:30840 proof <> writeIx def
R30842:30842 proof <> w var
R30847:30853 proof <> writeIx def
R30855:30856 proof <> w' var
R30724:30740 proof <> dependenceInRange def
R30749:30749 proof <> c var
R30742:30742 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30744:30745 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30747:30747 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30743:30743 proof <> i var
R30746:30746 proof <> j var
R30692:30712 proof <> dependenceLexPositive def
R30714:30714 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30716:30717 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30719:30719 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R30715:30715 proof <> i var
R30718:30718 proof <> j var
R30651:30671 proof <> completeDependenceSet def
R30675:30687 Coq.Init.Datatypes <> nil constr
R30673:30673 proof <> c var
R30886:30893 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30903:30905 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30898:30902 proof <> write ind
R30921:30923 Coq.Init.Logic <> :type_scope:x_'='_x not
R30906:30916 proof <> getWriteAt' def
R30924:30927 Coq.Init.Datatypes <> Some constr
R30929:30930 proof <> wi var
R30886:30893 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30903:30905 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R30898:30902 proof <> write ind
R30921:30923 Coq.Init.Logic <> :type_scope:x_'='_x not
R30906:30916 proof <> getWriteAt' def
R30924:30927 Coq.Init.Datatypes <> Some constr
R30929:30930 proof <> wi var
R30943:30959 proof <> dependenceInRange def
R31003:31018 proof <> commandIxInRange def
R31035:31058 proof <> getWriteAt'RangeComplete thm
R31035:31058 proof <> getWriteAt'RangeComplete thm
R31080:31087 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31097:31099 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31092:31096 proof <> write ind
R31115:31117 Coq.Init.Logic <> :type_scope:x_'='_x not
R31100:31110 proof <> getWriteAt' def
R31118:31121 Coq.Init.Datatypes <> Some constr
R31123:31124 proof <> wj var
R31080:31087 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31097:31099 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R31092:31096 proof <> write ind
R31115:31117 Coq.Init.Logic <> :type_scope:x_'='_x not
R31100:31110 proof <> getWriteAt' def
R31118:31121 Coq.Init.Datatypes <> Some constr
R31123:31124 proof <> wj var
R31137:31153 proof <> dependenceInRange def
R31197:31220 proof <> getWriteAt'RangeComplete thm
R31197:31220 proof <> getWriteAt'RangeComplete thm
R31232:31247 proof <> commandIxInRange def
R31394:31397 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R31381:31383 Coq.Init.Logic <> :type_scope:x_'='_x not
R31372:31378 proof <> writeIx def
R31384:31390 proof <> writeIx def
R31407:31410 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R31398:31404 proof <> writeIx def
R31411:31417 proof <> writeIx def
R31394:31397 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R31381:31383 Coq.Init.Logic <> :type_scope:x_'='_x not
R31372:31378 proof <> writeIx def
R31384:31390 proof <> writeIx def
R31407:31410 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R31398:31404 proof <> writeIx def
R31411:31417 proof <> writeIx def
R31507:31527 proof <> completeDependenceSet def
R31554:31554 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31556:31557 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31559:31559 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31554:31554 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31556:31557 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31559:31559 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R31617:31621 Coq.Init.Logic <> False ind
R31617:31621 Coq.Init.Logic <> False ind
R31668:31682 proof <> validDependence def
R31709:31726 proof <> dependenceAliases' def
prf 31953:31988 <> emptyDependenceSetImpliesNoAliasing'
R32005:32007 Coq.Init.Datatypes <> nat ind
R32014:32016 proof <> com ind
R32057:32060 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32067:32071 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32092:32095 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32116:32119 Coq.Init.Logic <> :type_scope:x_'->'_x not
R32120:32127 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32139:32141 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32134:32138 proof <> write ind
R32166:32169 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32157:32159 Coq.Init.Logic <> :type_scope:x_'='_x not
R32142:32152 proof <> getWriteAt' def
R32156:32156 proof <> i var
R32154:32154 proof <> c var
R32160:32163 Coq.Init.Datatypes <> Some constr
R32165:32165 proof <> w var
R32195:32198 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32185:32187 Coq.Init.Logic <> :type_scope:x_'='_x not
R32170:32180 proof <> getWriteAt' def
R32184:32184 proof <> j var
R32182:32182 proof <> c var
R32188:32191 Coq.Init.Datatypes <> Some constr
R32193:32194 proof <> w' var
R32208:32211 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32199:32205 proof <> writeIx def
R32207:32207 proof <> w var
R32212:32218 proof <> writeIx def
R32220:32221 proof <> w' var
R32096:32111 proof <> commandIxInRange def
R32115:32115 proof <> j var
R32113:32113 proof <> c var
R32072:32087 proof <> commandIxInRange def
R32091:32091 proof <> i var
R32089:32089 proof <> c var
R32062:32065 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32061:32061 proof <> i var
R32066:32066 proof <> j var
R32020:32040 proof <> completeDependenceSet def
R32044:32056 Coq.Init.Datatypes <> nil constr
R32042:32042 proof <> c var
R32256:32259 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R32252:32254 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R32261:32263 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R32256:32259 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R32252:32254 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R32261:32263 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R32355:32389 proof <> emptyDependenceSetImpliesNoAliasing thm
R32355:32389 proof <> emptyDependenceSetImpliesNoAliasing thm
R32416:32436 proof <> dependenceLexPositive def
R32469:32485 proof <> dependenceInRange def
R32534:32541 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32553:32555 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32548:32552 proof <> write ind
R32580:32583 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32571:32573 Coq.Init.Logic <> :type_scope:x_'='_x not
R32556:32566 proof <> getWriteAt' def
R32574:32577 Coq.Init.Datatypes <> Some constr
R32579:32579 proof <> w var
R32609:32612 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32599:32601 Coq.Init.Logic <> :type_scope:x_'='_x not
R32584:32594 proof <> getWriteAt' def
R32602:32605 Coq.Init.Datatypes <> Some constr
R32607:32608 proof <> w' var
R32622:32625 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32613:32619 proof <> writeIx def
R32621:32621 proof <> w var
R32626:32632 proof <> writeIx def
R32634:32635 proof <> w' var
R32534:32541 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32553:32555 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R32548:32552 proof <> write ind
R32580:32583 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32571:32573 Coq.Init.Logic <> :type_scope:x_'='_x not
R32556:32566 proof <> getWriteAt' def
R32574:32577 Coq.Init.Datatypes <> Some constr
R32579:32579 proof <> w var
R32609:32612 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R32599:32601 Coq.Init.Logic <> :type_scope:x_'='_x not
R32584:32594 proof <> getWriteAt' def
R32602:32605 Coq.Init.Datatypes <> Some constr
R32607:32608 proof <> w' var
R32622:32625 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R32613:32619 proof <> writeIx def
R32621:32621 proof <> w var
R32626:32632 proof <> writeIx def
R32634:32635 proof <> w' var
R32651:32685 proof <> emptyDependenceSetImpliesNoAliasing thm
R32651:32685 proof <> emptyDependenceSetImpliesNoAliasing thm
R32729:32745 proof <> dependenceInRange def
prf 32963:33003 <> scheduleMappingWitnessDestructOnCSeqEqual
R33023:33025 proof <> com ind
R33040:33043 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33044:33046 Coq.Init.Datatypes <> nat ind
R33037:33039 Coq.Init.Datatypes <> nat ind
R33053:33057 proof <> write ind
R33065:33077 proof <> dependenceset def
R33111:33118 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33171:33178 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33213:33220 Coq.Init.Logic <> :type_scope:x_'->'_x not
R33221:33242 proof <> scheduleMappingWitness def
R33253:33254 proof <> c' var
R33251:33251 proof <> c var
R33246:33249 proof <> sinv var
R33244:33244 proof <> s var
R33179:33207 proof <> scheduleRespectsDependenceSet def
R33211:33212 proof <> ds var
R33209:33209 proof <> s var
R33119:33140 proof <> scheduleMappingWitness def
R33161:33164 proof <> CSeq constr
R33169:33169 proof <> w var
R33166:33167 proof <> c' var
R33150:33153 proof <> CSeq constr
R33157:33157 proof <> w var
R33155:33155 proof <> c var
R33144:33147 proof <> sinv var
R33142:33142 proof <> s var
R33085:33105 proof <> completeDependenceSet def
R33109:33110 proof <> ds var
R33107:33107 proof <> c var
R33283:33304 proof <> scheduleMappingWitness def
R33316:33337 proof <> scheduleMappingWitness def
R33405:33410 proof <> comlen def
R33424:33429 proof <> comlen def
R33424:33429 proof <> comlen def
R33609:33614 proof <> comlen def
R33622:33627 proof <> comlen def
R33622:33627 proof <> comlen def
R33650:33655 proof <> comlen def
R33669:33674 proof <> comlen def
R33669:33674 proof <> comlen def
R33723:33728 proof <> comlen def
R33742:33747 proof <> comlen def
R33742:33747 proof <> comlen def
R33778:33780 Coq.Init.Logic <> :type_scope:x_'='_x not
R33770:33775 proof <> comlen def
R33781:33786 proof <> comlen def
R33778:33780 Coq.Init.Logic <> :type_scope:x_'='_x not
R33770:33775 proof <> comlen def
R33781:33786 proof <> comlen def
R33813:33841 proof <> scheduleRespectsDependenceSet def
prf 34061:34080 <> writesEqualDecidable
R34097:34101 proof <> write ind
R34111:34114 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R34106:34108 Coq.Init.Logic <> :type_scope:x_'='_x not
R34105:34105 proof <> w var
R34109:34110 proof <> w' var
R34116:34119 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34115:34115 proof <> w var
R34120:34121 proof <> w' var
R34186:34189 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R34181:34183 Coq.Init.Logic <> :type_scope:x_'='_x not
R34191:34194 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34186:34189 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R34181:34183 Coq.Init.Logic <> :type_scope:x_'='_x not
R34191:34194 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34223:34226 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R34218:34220 Coq.Init.Logic <> :type_scope:x_'='_x not
R34228:34231 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34223:34226 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R34218:34220 Coq.Init.Logic <> :type_scope:x_'='_x not
R34228:34231 Coq.Init.Logic <> :type_scope:x_'<>'_x not
def 34416:34450 <> NoAliasingBetweenSubprogramAndWrite
R34456:34458 proof <> com ind
R34467:34471 proof <> memix syndef
R34497:34499 Coq.Init.Datatypes <> nat ind
R34523:34545 Coq.Init.Logic <> :type_scope:x_'->'_x not
R34582:34585 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34546:34555 Coq.Init.Datatypes <> option_map def
R34566:34576 proof <> getWriteAt' def
R34580:34580 proof <> i var
R34578:34578 proof <> c var
R34557:34563 proof <> writeIx def
R34586:34589 Coq.Init.Datatypes <> Some constr
R34591:34593 proof <> wix var
R34503:34518 proof <> commandIxInRange def
R34522:34522 proof <> i var
R34520:34520 proof <> c var
prf 34672:34720 <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq
R34736:34738 proof <> com ind
R34756:34760 proof <> memix syndef
R34770:34777 proof <> memvalue syndef
R34855:34862 Coq.Init.Logic <> :type_scope:x_'->'_x not
R34909:34912 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R34863:34897 proof <> NoAliasingBetweenSubprogramAndWrite def
R34901:34908 proof <> wixalias var
R34899:34899 proof <> c var
R34916:34919 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R34913:34915 proof <> wix var
R34920:34927 proof <> wixalias var
R34785:34819 proof <> NoAliasingBetweenSubprogramAndWrite def
R34847:34854 proof <> wixalias var
R34822:34825 proof <> CSeq constr
R34830:34834 proof <> Write constr
R34840:34843 proof <> wval var
R34836:34838 proof <> wix var
R34827:34827 proof <> c var
R35012:35046 proof <> NoAliasingBetweenSubprogramAndWrite def
R35060:35094 proof <> NoAliasingBetweenSubprogramAndWrite def
R35182:35184 Coq.Init.Logic <> :type_scope:x_'='_x not
R35165:35168 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R35169:35169 Coq.Init.Datatypes <> S constr
R35172:35177 proof <> comlen def
R35185:35189 Coq.Init.Datatypes <> false constr
R35182:35184 Coq.Init.Logic <> :type_scope:x_'='_x not
R35165:35168 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R35169:35169 Coq.Init.Datatypes <> S constr
R35172:35177 proof <> comlen def
R35185:35189 Coq.Init.Datatypes <> false constr
R35205:35215 Coq.Arith.PeanoNat Nat eqb_neq thm
R35205:35215 Coq.Arith.PeanoNat Nat eqb_neq thm
R35205:35215 Coq.Arith.PeanoNat Nat eqb_neq thm
R35225:35240 proof <> commandIxInRange def
R35300:35324 proof <> commandIxInRangeInclusive thm
R35300:35324 proof <> commandIxInRangeInclusive thm
R35392:35426 proof <> NoAliasingBetweenSubprogramAndWrite def
R35461:35463 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35453:35458 proof <> comlen def
R35461:35463 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35453:35458 proof <> comlen def
R35525:35527 Coq.Init.Logic <> :type_scope:x_'='_x not
R35509:35512 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R35505:35507 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35497:35502 proof <> comlen def
R35513:35513 Coq.Init.Datatypes <> S constr
R35516:35521 proof <> comlen def
R35528:35531 Coq.Init.Datatypes <> true constr
R35525:35527 Coq.Init.Logic <> :type_scope:x_'='_x not
R35509:35512 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R35505:35507 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R35497:35502 proof <> comlen def
R35513:35513 Coq.Init.Datatypes <> S constr
R35516:35521 proof <> comlen def
R35528:35531 Coq.Init.Datatypes <> true constr
R35543:35552 Coq.Arith.PeanoNat Nat eqb_eq thm
R35543:35552 Coq.Arith.PeanoNat Nat eqb_eq thm
R35543:35552 Coq.Arith.PeanoNat Nat eqb_eq thm
R35636:35639 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35643:35646 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35619:35622 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35611:35614 Coq.Init.Datatypes <> Some constr
R35623:35626 Coq.Init.Datatypes <> Some constr
R35636:35639 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35643:35646 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35619:35622 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35611:35614 Coq.Init.Datatypes <> Some constr
R35623:35626 Coq.Init.Datatypes <> Some constr
R35698:35713 proof <> commandIxInRange def
R35727:35732 proof <> comlen def
R35740:35745 proof <> comlen def
R35740:35745 proof <> comlen def
def 35840:35867 <> NoAliasingBetweenSubprograms
R35877:35879 proof <> com ind
R35909:35911 Coq.Init.Datatypes <> nat ind
R35940:35946 Coq.Init.Logic <> :type_scope:x_'->'_x not
R35968:35975 Coq.Init.Logic <> :type_scope:x_'->'_x not
R36013:36016 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R35976:35985 Coq.Init.Datatypes <> option_map def
R35996:36006 proof <> getWriteAt' def
R36011:36011 proof <> i var
R36008:36009 proof <> c1 var
R35987:35993 proof <> writeIx def
R36017:36026 Coq.Init.Datatypes <> option_map def
R36037:36047 proof <> getWriteAt' def
R36052:36052 proof <> j var
R36049:36050 proof <> c2 var
R36028:36034 proof <> writeIx def
R35947:35962 proof <> commandIxInRange def
R35967:35967 proof <> j var
R35964:35965 proof <> c2 var
R35919:35934 proof <> commandIxInRange def
R35939:35939 proof <> i var
R35936:35937 proof <> c1 var
prf 36063:36104 <> NoAliasingBetweenSubprogramsDestructOnCSeq
R36122:36124 proof <> com ind
R36133:36137 proof <> memix syndef
R36147:36154 proof <> memvalue syndef
R36220:36227 Coq.Init.Logic <> :type_scope:x_'->'_x not
R36262:36269 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R36228:36255 proof <> NoAliasingBetweenSubprograms def
R36260:36261 proof <> c2 var
R36257:36258 proof <> c1 var
R36270:36304 proof <> NoAliasingBetweenSubprogramAndWrite def
R36309:36311 proof <> wix var
R36306:36307 proof <> c2 var
R36162:36189 proof <> NoAliasingBetweenSubprograms def
R36218:36219 proof <> c2 var
R36192:36195 proof <> CSeq constr
R36201:36205 proof <> Write constr
R36211:36214 proof <> wval var
R36207:36209 proof <> wix var
R36197:36198 proof <> c1 var
R36394:36421 proof <> NoAliasingBetweenSubprograms def
R36443:36470 proof <> NoAliasingBetweenSubprograms def
R36510:36525 proof <> commandIxInRange def
R36528:36531 proof <> CSeq constr
R36537:36541 proof <> Write constr
R36510:36525 proof <> commandIxInRange def
R36528:36531 proof <> CSeq constr
R36537:36541 proof <> Write constr
R36566:36590 proof <> commandIxInRangeInclusive thm
R36566:36590 proof <> commandIxInRangeInclusive thm
R36633:36657 proof <> getWriteAt'DestructOnCSeq thm
R36633:36657 proof <> getWriteAt'DestructOnCSeq thm
R36633:36657 proof <> getWriteAt'DestructOnCSeq thm
R36633:36657 proof <> getWriteAt'DestructOnCSeq thm
R36685:36700 proof <> commandIxInRange def
R36756:36790 proof <> NoAliasingBetweenSubprogramAndWrite def
R36802:36829 proof <> NoAliasingBetweenSubprograms def
R36863:36865 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36854:36859 proof <> comlen def
R36863:36865 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36854:36859 proof <> comlen def
R36881:36896 proof <> commandIxInRange def
R36935:36937 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36926:36931 proof <> comlen def
R36899:36902 proof <> CSeq constr
R36908:36912 proof <> Write constr
R36881:36896 proof <> commandIxInRange def
R36935:36937 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R36926:36931 proof <> comlen def
R36899:36902 proof <> CSeq constr
R36908:36912 proof <> Write constr
R36952:36967 proof <> commandIxInRange def
R36977:36982 proof <> comlen def
R36990:36995 proof <> comlen def
R36990:36995 proof <> comlen def
R37094:37096 Coq.Init.Logic <> :type_scope:x_'='_x not
R37078:37081 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R37074:37076 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37065:37070 proof <> comlen def
R37082:37082 Coq.Init.Datatypes <> S constr
R37084:37089 proof <> comlen def
R37097:37100 Coq.Init.Datatypes <> true constr
R37094:37096 Coq.Init.Logic <> :type_scope:x_'='_x not
R37078:37081 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R37074:37076 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37065:37070 proof <> comlen def
R37082:37082 Coq.Init.Datatypes <> S constr
R37084:37089 proof <> comlen def
R37097:37100 Coq.Init.Datatypes <> true constr
R37114:37123 Coq.Arith.PeanoNat Nat eqb_eq thm
R37114:37123 Coq.Arith.PeanoNat Nat eqb_eq thm
R37114:37123 Coq.Arith.PeanoNat Nat eqb_eq thm
prf 37304:37356 <> NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough
R37372:37374 proof <> com ind
R37383:37387 proof <> memix syndef
R37396:37401 proof <> memory def
R37450:37457 Coq.Init.Logic <> :type_scope:x_'->'_x not
R37480:37482 Coq.Init.Logic <> :type_scope:x_'='_x not
R37459:37468 proof <> runProgram def
R37472:37474 proof <> mem var
R37470:37470 proof <> c var
R37477:37479 proof <> wix var
R37483:37485 proof <> mem var
R37487:37489 proof <> wix var
R37409:37443 proof <> NoAliasingBetweenSubprogramAndWrite def
R37447:37449 proof <> wix var
R37445:37445 proof <> c var
R37533:37542 proof <> runProgram def
R37550:37559 proof <> runProgram def
R37550:37559 proof <> runProgram def
R37571:37584 proof <> writeToMemory' def
R37618:37630 proof <> writeToMemory def
R37650:37653 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R37646:37648 Coq.Init.Logic <> :type_scope:x_'='_x not
R37657:37660 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37650:37653 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R37646:37648 Coq.Init.Logic <> :type_scope:x_'='_x not
R37657:37660 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37796:37830 proof <> NoAliasingBetweenSubprogramAndWrite def
R37853:37856 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37853:37856 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R37920:37922 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37912:37917 proof <> comlen def
R37920:37922 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R37912:37917 proof <> comlen def
R37939:37954 proof <> commandIxInRange def
R37969:37974 proof <> comlen def
R37987:37992 proof <> comlen def
R37987:37992 proof <> comlen def
R38024:38027 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R38020:38022 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38012:38017 proof <> comlen def
R38029:38031 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38032:38037 proof <> comlen def
R38024:38027 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R38020:38022 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38012:38017 proof <> comlen def
R38029:38031 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38032:38037 proof <> comlen def
R38074:38077 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R38070:38072 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38062:38067 proof <> comlen def
R38074:38077 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R38070:38072 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38062:38067 proof <> comlen def
R38209:38211 Coq.Init.Logic <> :type_scope:x_'='_x not
R38193:38196 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R38189:38191 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38181:38186 proof <> comlen def
R38197:38197 Coq.Init.Datatypes <> S constr
R38200:38205 proof <> comlen def
R38212:38215 Coq.Init.Datatypes <> true constr
R38209:38211 Coq.Init.Logic <> :type_scope:x_'='_x not
R38193:38196 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R38189:38191 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R38181:38186 proof <> comlen def
R38197:38197 Coq.Init.Datatypes <> S constr
R38200:38205 proof <> comlen def
R38212:38215 Coq.Init.Datatypes <> true constr
R38228:38237 Coq.Arith.PeanoNat Nat eqb_eq thm
R38228:38237 Coq.Arith.PeanoNat Nat eqb_eq thm
R38228:38237 Coq.Arith.PeanoNat Nat eqb_eq thm
R38310:38313 Coq.Init.Logic <> :type_scope:x_'->'_x not
R38317:38320 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38298:38301 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38292:38295 Coq.Init.Datatypes <> Some constr
R38302:38305 Coq.Init.Datatypes <> Some constr
R38310:38313 Coq.Init.Logic <> :type_scope:x_'->'_x not
R38317:38320 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38298:38301 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R38292:38295 Coq.Init.Datatypes <> Some constr
R38302:38305 Coq.Init.Datatypes <> Some constr
R38471:38473 Coq.Init.Logic <> :type_scope:x_'='_x not
R38466:38469 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R38474:38478 Coq.Init.Datatypes <> false constr
R38471:38473 Coq.Init.Logic <> :type_scope:x_'='_x not
R38466:38469 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R38474:38478 Coq.Init.Datatypes <> false constr
R38490:38500 Coq.Arith.PeanoNat Nat eqb_neq thm
R38490:38500 Coq.Arith.PeanoNat Nat eqb_neq thm
R38490:38500 Coq.Arith.PeanoNat Nat eqb_neq thm
R38520:38568 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R38520:38568 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R38697:38706 proof <> runProgram def
R38714:38723 proof <> runProgram def
R38714:38723 proof <> runProgram def
prf 38749:38799 <> NoAliasingBetweenSubprogramAndWriteAllowsReordering
R38815:38817 proof <> com ind
R38826:38830 proof <> memix syndef
R38841:38848 proof <> memvalue syndef
R38857:38862 proof <> memory def
R38911:38918 Coq.Init.Logic <> :type_scope:x_'->'_x not
R38969:38975 Coq.Init.Logic <> :type_scope:x_'='_x not
R38919:38928 proof <> runProgram def
R38933:38946 proof <> writeToMemory' def
R38965:38967 proof <> mem var
R38949:38953 proof <> Write constr
R38959:38962 proof <> wval var
R38955:38957 proof <> wix var
R38930:38930 proof <> c var
R38976:38989 proof <> writeToMemory' def
R39009:39018 proof <> runProgram def
R39022:39024 proof <> mem var
R39020:39020 proof <> c var
R38992:38996 proof <> Write constr
R39002:39005 proof <> wval var
R38998:39000 proof <> wix var
R38870:38904 proof <> NoAliasingBetweenSubprogramAndWrite def
R38908:38910 proof <> wix var
R38906:38906 proof <> c var
R39053:39077 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R39053:39077 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R39107:39110 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R39101:39103 Coq.Init.Logic <> :type_scope:x_'='_x not
R39112:39115 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R39107:39110 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R39101:39103 Coq.Init.Logic <> :type_scope:x_'='_x not
R39112:39115 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R39185:39198 proof <> writeToMemory' def
R39210:39222 proof <> writeToMemory def
R39243:39245 Coq.Init.Logic <> :type_scope:x_'='_x not
R39236:39239 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39246:39249 Coq.Init.Datatypes <> true constr
R39243:39245 Coq.Init.Logic <> :type_scope:x_'='_x not
R39236:39239 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39246:39249 Coq.Init.Datatypes <> true constr
R39261:39270 Coq.Arith.PeanoNat Nat eqb_eq thm
R39261:39270 Coq.Arith.PeanoNat Nat eqb_eq thm
R39261:39270 Coq.Arith.PeanoNat Nat eqb_eq thm
R39299:39311 proof <> writeToMemory def
R39299:39311 proof <> writeToMemory def
R39335:39339 proof <> memix syndef
R39349:39352 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39347:39348 proof <> ix var
R39377:39378 proof <> ix var
R39335:39339 proof <> memix syndef
R39349:39352 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39347:39348 proof <> ix var
R39377:39378 proof <> ix var
R39423:39425 Coq.Init.Logic <> :type_scope:x_'='_x not
R39402:39411 proof <> runProgram def
R39423:39425 Coq.Init.Logic <> :type_scope:x_'='_x not
R39402:39411 proof <> runProgram def
R39445:39497 proof <> NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough thm
R39445:39497 proof <> NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough thm
R39612:39614 Coq.Init.Logic <> :type_scope:x_'='_x not
R39605:39608 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39615:39619 Coq.Init.Datatypes <> false constr
R39612:39614 Coq.Init.Logic <> :type_scope:x_'='_x not
R39605:39608 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R39615:39619 Coq.Init.Datatypes <> false constr
R39631:39641 Coq.Arith.PeanoNat Nat eqb_neq thm
R39631:39641 Coq.Arith.PeanoNat Nat eqb_neq thm
R39631:39641 Coq.Arith.PeanoNat Nat eqb_neq thm
R39814:39827 proof <> writeToMemory' def
R39840:39861 proof <> readFromWriteDifferent thm
R39840:39861 proof <> readFromWriteDifferent thm
R39840:39861 proof <> readFromWriteDifferent thm
R39840:39861 proof <> readFromWriteDifferent thm
R39873:39882 proof <> runProgram def
R39890:39899 proof <> runProgram def
R39890:39899 proof <> runProgram def
R40013:40016 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R39972:40006 proof <> NoAliasingBetweenSubprogramAndWrite def
R40018:40021 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R40013:40016 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R39972:40006 proof <> NoAliasingBetweenSubprogramAndWrite def
R40018:40021 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R40036:40084 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R40036:40084 proof <> NoAliasingBetweenSubprogramAndWriteDestructOnCSeq thm
R40159:40172 proof <> writeToMemory' def
R40191:40204 proof <> writeToMemory' def
R40222:40225 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R40218:40220 Coq.Init.Logic <> :type_scope:x_'='_x not
R40227:40230 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R40222:40225 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R40218:40220 Coq.Init.Logic <> :type_scope:x_'='_x not
R40227:40230 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R40300:40312 proof <> writeToMemory def
R40333:40335 Coq.Init.Logic <> :type_scope:x_'='_x not
R40328:40331 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40336:40339 Coq.Init.Datatypes <> true constr
R40333:40335 Coq.Init.Logic <> :type_scope:x_'='_x not
R40328:40331 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40336:40339 Coq.Init.Datatypes <> true constr
R40351:40360 Coq.Arith.PeanoNat Nat eqb_eq thm
R40351:40360 Coq.Arith.PeanoNat Nat eqb_eq thm
R40351:40360 Coq.Arith.PeanoNat Nat eqb_eq thm
R40483:40485 Coq.Init.Logic <> :type_scope:x_'='_x not
R40444:40456 proof <> writeToMemory def
R40463:40472 proof <> runProgram def
R40486:40495 proof <> runProgram def
R40483:40485 Coq.Init.Logic <> :type_scope:x_'='_x not
R40444:40456 proof <> writeToMemory def
R40463:40472 proof <> runProgram def
R40486:40495 proof <> runProgram def
R40519:40531 proof <> writeToMemory def
R40548:40550 Coq.Init.Logic <> :type_scope:x_'='_x not
R40543:40546 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40551:40555 Coq.Init.Datatypes <> false constr
R40548:40550 Coq.Init.Logic <> :type_scope:x_'='_x not
R40543:40546 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R40551:40555 Coq.Init.Datatypes <> false constr
R40567:40577 Coq.Arith.PeanoNat Nat eqb_neq thm
R40567:40577 Coq.Arith.PeanoNat Nat eqb_neq thm
R40567:40577 Coq.Arith.PeanoNat Nat eqb_neq thm
R40712:40714 Coq.Init.Logic <> :type_scope:x_'='_x not
R40648:40660 proof <> writeToMemory def
R40667:40676 proof <> runProgram def
R40681:40693 proof <> writeToMemory def
R40715:40724 proof <> runProgram def
R40712:40714 Coq.Init.Logic <> :type_scope:x_'='_x not
R40648:40660 proof <> writeToMemory def
R40667:40676 proof <> runProgram def
R40681:40693 proof <> writeToMemory def
R40715:40724 proof <> runProgram def
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40756:40777 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40816:40837 proof <> readFromWriteDifferent thm
R40977:40986 proof <> runProgram def
R40994:41003 proof <> runProgram def
R40994:41003 proof <> runProgram def
prf 41039:41082 <> NoAliasingBetweenSubprogramsAllowsReordering
R41100:41102 proof <> com ind
R41144:41147 Coq.Init.Logic <> :type_scope:x_'->'_x not
R41157:41161 proof <> ::x_'==='_x not
R41150:41154 proof <> ::x_'+++'_x not
R41148:41149 proof <> c1 var
R41155:41156 proof <> c2 var
R41164:41168 proof <> ::x_'+++'_x not
R41162:41163 proof <> c2 var
R41169:41170 proof <> c1 var
R41110:41137 proof <> NoAliasingBetweenSubprograms def
R41142:41143 proof <> c2 var
R41139:41140 proof <> c1 var
R41199:41201 proof <> ceq def
R41224:41251 proof <> runprogram_distribute_append thm
R41224:41251 proof <> runprogram_distribute_append thm
R41224:41251 proof <> runprogram_distribute_append thm
R41264:41291 proof <> runprogram_distribute_append thm
R41264:41291 proof <> runprogram_distribute_append thm
R41264:41291 proof <> runprogram_distribute_append thm
R41465:41474 proof <> runProgram def
R41482:41491 proof <> runProgram def
R41482:41491 proof <> runProgram def
R41565:41606 proof <> NoAliasingBetweenSubprogramsDestructOnCSeq thm
R41565:41606 proof <> NoAliasingBetweenSubprogramsDestructOnCSeq thm
R41704:41713 proof <> runProgram def
R41704:41713 proof <> runProgram def
R41757:41807 proof <> NoAliasingBetweenSubprogramAndWriteAllowsReordering thm
R41757:41807 proof <> NoAliasingBetweenSubprogramAndWriteAllowsReordering thm
R41866:41875 proof <> runProgram def
R41883:41892 proof <> runProgram def
R41883:41892 proof <> runProgram def
def 41930:41955 <> aliasingWriteTimepointsSet
R41961:41963 proof <> com ind
R41971:41975 proof <> memix syndef
R41982:41985 Coq.Init.Datatypes <> list ind
R41987:41995 proof <> timepoint syndef
R42022:42027 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R42010:42019 Coq.Lists.List <> NoDup ind
R42021:42021 proof <> l var
R42039:42047 proof <> timepoint syndef
R42066:42069 Coq.Init.Logic <> :type_scope:x_'->'_x not
R42090:42094 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R42158:42158 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R42070:42085 proof <> commandIxInRange def
R42089:42089 proof <> t var
R42087:42087 proof <> c var
R42095:42102 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R42117:42119 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R42109:42116 proof <> memvalue syndef
R42135:42137 Coq.Init.Logic <> :type_scope:x_'='_x not
R42120:42130 proof <> getWriteAt' def
R42134:42134 proof <> t var
R42132:42132 proof <> c var
R42138:42141 Coq.Init.Datatypes <> Some constr
R42144:42148 proof <> Write constr
R42153:42156 proof <> wval var
R42150:42151 proof <> ix var
R42055:42061 Coq.Lists.List <> In def
R42065:42065 proof <> l var
R42063:42063 proof <> t var
prf 44412:44442 <> list_length_1_implies_singleton
R44466:44469 Coq.Init.Datatypes <> list ind
R44471:44471 proof <> a var
R44487:44490 Coq.Init.Logic <> :type_scope:x_'->'_x not
R44491:44498 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44503:44505 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44502:44502 proof <> a var
R44507:44509 Coq.Init.Logic <> :type_scope:x_'='_x not
R44506:44506 proof <> l var
R44510:44518 Coq.Lists.List <> cons syndef
R44522:44529 Coq.Lists.List <> nil syndef
R44520:44520 proof <> x var
R44483:44485 Coq.Init.Logic <> :type_scope:x_'='_x not
R44475:44480 Coq.Init.Datatypes <> length def
R44482:44482 proof <> l var
R44625:44648 Coq.Lists.List <> length_zero_iff_nil thm
R44625:44648 Coq.Lists.List <> length_zero_iff_nil thm
R44625:44648 Coq.Lists.List <> length_zero_iff_nil thm
prf 44768:44796 <> list_length_2_implies_2_elems
R44820:44823 Coq.Init.Datatypes <> list ind
R44825:44825 proof <> a var
R44845:44848 Coq.Init.Logic <> :type_scope:x_'->'_x not
R44849:44856 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44864:44866 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R44863:44863 proof <> a var
R44868:44870 Coq.Init.Logic <> :type_scope:x_'='_x not
R44867:44867 proof <> l var
R44871:44879 Coq.Lists.List <> cons syndef
R44884:44892 Coq.Lists.List <> cons syndef
R44897:44904 Coq.Lists.List <> nil syndef
R44894:44895 proof <> x' var
R44881:44881 proof <> x var
R44841:44843 Coq.Init.Logic <> :type_scope:x_'='_x not
R44833:44838 Coq.Init.Datatypes <> length def
R44840:44840 proof <> l var
R44999:45029 proof <> list_length_1_implies_singleton thm
R44999:45029 proof <> list_length_1_implies_singleton thm
prf 45117:45157 <> list_length_gt_2_implies_at_least_2_elems
R45181:45184 Coq.Init.Datatypes <> list ind
R45186:45186 proof <> a var
R45207:45210 Coq.Init.Logic <> :type_scope:x_'->'_x not
R45211:45218 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45240:45242 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45226:45226 proof <> a var
R45234:45237 Coq.Init.Datatypes <> list ind
R45239:45239 proof <> a var
R45244:45246 Coq.Init.Logic <> :type_scope:x_'='_x not
R45243:45243 proof <> l var
R45247:45255 Coq.Lists.List <> cons syndef
R45260:45268 Coq.Lists.List <> cons syndef
R45273:45274 proof <> l' var
R45270:45271 proof <> x' var
R45257:45257 proof <> x var
R45202:45205 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R45194:45199 Coq.Init.Datatypes <> length def
R45201:45201 proof <> l var
def 45433:45473 <> getLatestAliasingWriteTimepointForProgram
R45479:45481 proof <> com ind
R45489:45493 proof <> memix syndef
R45498:45503 Coq.Init.Datatypes <> option ind
R45505:45513 proof <> timepoint syndef
R45526:45526 proof <> c var
R45537:45542 proof <> CBegin constr
R45547:45550 Coq.Init.Datatypes <> None constr
R45556:45559 proof <> CSeq constr
R45581:45584 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R45572:45578 proof <> writeIx def
R45585:45586 proof <> ix var
R45650:45690 proof <> getLatestAliasingWriteTimepointForProgram def
R45695:45696 proof <> ix var
R45610:45613 Coq.Init.Datatypes <> Some constr
R45616:45621 proof <> comlen def
R45623:45623 proof <> c var
def 45717:45748 <> latestAliasingWriteTimepointSpec
R45754:45756 proof <> com ind
R45764:45768 proof <> memix syndef
R45780:45785 Coq.Init.Datatypes <> option ind
R45787:45795 proof <> timepoint syndef
R45809:45809 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46094:46101 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46241:46241 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R45810:45817 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45830:45838 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45821:45829 proof <> timepoint syndef
R45839:45839 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45855:45865 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45846:45848 Coq.Init.Logic <> :type_scope:x_'='_x not
R45840:45845 proof <> latest var
R45849:45852 Coq.Init.Datatypes <> Some constr
R45854:45854 proof <> n var
R45886:45895 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45866:45881 proof <> commandIxInRange def
R45885:45885 proof <> n var
R45883:45883 proof <> c var
R45896:45896 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45960:45970 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R45897:45904 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45919:45921 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R45911:45918 proof <> memvalue syndef
R45937:45939 Coq.Init.Logic <> :type_scope:x_'='_x not
R45922:45932 proof <> getWriteAt' def
R45936:45936 proof <> n var
R45934:45934 proof <> c var
R45940:45943 Coq.Init.Datatypes <> Some constr
R45946:45950 proof <> Write constr
R45955:45958 proof <> wval var
R45952:45953 proof <> ix var
R45982:45990 proof <> timepoint syndef
R45999:46002 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46023:46031 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46032:46039 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46048:46050 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46043:46047 proof <> write ind
R46075:46078 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R46066:46068 Coq.Init.Logic <> :type_scope:x_'='_x not
R46051:46061 proof <> getWriteAt' def
R46065:46065 proof <> t var
R46063:46063 proof <> c var
R46069:46072 Coq.Init.Datatypes <> Some constr
R46074:46074 proof <> w var
R46088:46091 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R46079:46085 proof <> writeIx def
R46087:46087 proof <> w var
R46092:46093 proof <> ix var
R46003:46018 proof <> commandIxInRange def
R46022:46022 proof <> t var
R46020:46020 proof <> c var
R45995:45997 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R45994:45994 proof <> t var
R45998:45998 proof <> n var
R46115:46121 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R46108:46110 Coq.Init.Logic <> :type_scope:x_'='_x not
R46102:46107 proof <> latest var
R46111:46114 Coq.Init.Datatypes <> None constr
R46133:46141 proof <> timepoint syndef
R46170:46178 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46179:46186 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46195:46197 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46190:46194 proof <> write ind
R46222:46225 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R46213:46215 Coq.Init.Logic <> :type_scope:x_'='_x not
R46198:46208 proof <> getWriteAt' def
R46212:46212 proof <> t var
R46210:46210 proof <> c var
R46216:46219 Coq.Init.Datatypes <> Some constr
R46221:46221 proof <> w var
R46235:46238 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R46226:46232 proof <> writeIx def
R46234:46234 proof <> w var
R46239:46240 proof <> ix var
R46150:46165 proof <> commandIxInRange def
R46169:46169 proof <> t var
R46167:46167 proof <> c var
prf 46275:46319 <> emptyDependenceSetWillHaveSingleAliasingWrite
R46335:46337 proof <> com ind
R46345:46349 proof <> memix syndef
R46357:46360 Coq.Init.Datatypes <> list ind
R46362:46370 proof <> timepoint syndef
R46410:46417 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46452:46459 Coq.Init.Logic <> :type_scope:x_'->'_x not
R46460:46460 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46517:46521 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46461:46468 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46481:46491 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R46472:46480 proof <> timepoint syndef
R46494:46496 Coq.Init.Logic <> :type_scope:x_'='_x not
R46492:46493 proof <> lt var
R46497:46505 Coq.Lists.List <> cons syndef
R46509:46516 Coq.Lists.List <> nil syndef
R46507:46507 proof <> t var
R46524:46526 Coq.Init.Logic <> :type_scope:x_'='_x not
R46522:46523 proof <> lt var
R46527:46534 Coq.Lists.List <> nil syndef
R46418:46443 proof <> aliasingWriteTimepointsSet def
R46450:46451 proof <> lt var
R46447:46448 proof <> ix var
R46445:46445 proof <> c var
R46378:46398 proof <> completeDependenceSet def
R46402:46409 Coq.Lists.List <> nil syndef
R46400:46400 proof <> c var
R46563:46588 proof <> aliasingWriteTimepointsSet def
R46621:46624 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46616:46619 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R46607:46612 Coq.Init.Datatypes <> length def
R46634:46637 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R46625:46630 Coq.Init.Datatypes <> length def
R46621:46624 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46616:46619 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R46607:46612 Coq.Init.Datatypes <> length def
R46634:46637 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R46625:46630 Coq.Init.Datatypes <> length def
R46738:46741 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46734:46736 Coq.Init.Logic <> :type_scope:x_'='_x not
R46725:46730 Coq.Init.Datatypes <> length def
R46751:46753 Coq.Init.Logic <> :type_scope:x_'='_x not
R46742:46747 Coq.Init.Datatypes <> length def
R46738:46741 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R46734:46736 Coq.Init.Logic <> :type_scope:x_'='_x not
R46725:46730 Coq.Init.Datatypes <> length def
R46751:46753 Coq.Init.Logic <> :type_scope:x_'='_x not
R46742:46747 Coq.Init.Datatypes <> length def
R46844:46846 Coq.Init.Logic <> :type_scope:x_'='_x not
R46847:46854 Coq.Lists.List <> nil syndef
R46844:46846 Coq.Init.Logic <> :type_scope:x_'='_x not
R46847:46854 Coq.Lists.List <> nil syndef
R46875:46893 Coq.Lists.List <> length_zero_iff_nil thm
R46875:46893 Coq.Lists.List <> length_zero_iff_nil thm
R46875:46893 Coq.Lists.List <> length_zero_iff_nil thm
R46985:47015 proof <> list_length_1_implies_singleton thm
R46985:47015 proof <> list_length_1_implies_singleton thm
R47133:47173 proof <> list_length_gt_2_implies_at_least_2_elems thm
R47133:47173 proof <> list_length_gt_2_implies_at_least_2_elems thm
R47245:47251 Coq.Lists.List <> In def
R47245:47251 Coq.Lists.List <> In def
R47293:47297 Coq.Lists.List <> in_eq thm
R47293:47297 Coq.Lists.List <> in_eq thm
R47312:47318 Coq.Lists.List <> In def
R47312:47318 Coq.Lists.List <> In def
R47367:47373 Coq.Lists.List <> In def
R47424:47427 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R47419:47421 Coq.Init.Logic <> :type_scope:x_'='_x not
R47429:47432 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R47424:47427 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R47419:47421 Coq.Init.Logic <> :type_scope:x_'='_x not
R47429:47432 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R47615:47633 Coq.Lists.List <> NoDup_cons_iff thm
R47615:47633 Coq.Lists.List <> NoDup_cons_iff thm
R47615:47633 Coq.Lists.List <> NoDup_cons_iff thm
R47675:47681 Coq.Lists.List <> In def
R47689:47692 Coq.Init.Datatypes <> :list_scope:x_'::'_x not
R47675:47681 Coq.Lists.List <> In def
R47689:47692 Coq.Init.Datatypes <> :list_scope:x_'::'_x not
R47706:47712 Coq.Lists.List <> In def
R47904:47921 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R47884:47899 proof <> commandIxInRange def
R47922:47929 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47944:47946 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47936:47943 proof <> memvalue syndef
R47962:47964 Coq.Init.Logic <> :type_scope:x_'='_x not
R47947:47957 proof <> getWriteAt' def
R47965:47968 Coq.Init.Datatypes <> Some constr
R47971:47975 proof <> Write constr
R47980:47983 proof <> wval var
R47904:47921 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R47884:47899 proof <> commandIxInRange def
R47922:47929 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47944:47946 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R47936:47943 proof <> memvalue syndef
R47962:47964 Coq.Init.Logic <> :type_scope:x_'='_x not
R47947:47957 proof <> getWriteAt' def
R47965:47968 Coq.Init.Datatypes <> Some constr
R47971:47975 proof <> Write constr
R47980:47983 proof <> wval var
R48051:48068 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48030:48045 proof <> commandIxInRange def
R48069:48076 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48091:48093 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48083:48090 proof <> memvalue syndef
R48110:48112 Coq.Init.Logic <> :type_scope:x_'='_x not
R48094:48104 proof <> getWriteAt' def
R48113:48116 Coq.Init.Datatypes <> Some constr
R48119:48123 proof <> Write constr
R48128:48131 proof <> wval var
R48051:48068 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48030:48045 proof <> commandIxInRange def
R48069:48076 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48091:48093 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48083:48090 proof <> memvalue syndef
R48110:48112 Coq.Init.Logic <> :type_scope:x_'='_x not
R48094:48104 proof <> getWriteAt' def
R48113:48116 Coq.Init.Datatypes <> Some constr
R48119:48123 proof <> Write constr
R48128:48131 proof <> wval var
R48256:48263 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48275:48294 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48270:48274 proof <> write ind
R48319:48339 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48310:48312 Coq.Init.Logic <> :type_scope:x_'='_x not
R48295:48305 proof <> getWriteAt' def
R48313:48316 Coq.Init.Datatypes <> Some constr
R48318:48318 proof <> w var
R48366:48386 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48356:48358 Coq.Init.Logic <> :type_scope:x_'='_x not
R48340:48350 proof <> getWriteAt' def
R48359:48362 Coq.Init.Datatypes <> Some constr
R48364:48365 proof <> w' var
R48396:48399 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R48387:48393 proof <> writeIx def
R48395:48395 proof <> w var
R48400:48406 proof <> writeIx def
R48408:48409 proof <> w' var
R48256:48263 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48275:48294 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R48270:48274 proof <> write ind
R48319:48339 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48310:48312 Coq.Init.Logic <> :type_scope:x_'='_x not
R48295:48305 proof <> getWriteAt' def
R48313:48316 Coq.Init.Datatypes <> Some constr
R48318:48318 proof <> w var
R48366:48386 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R48356:48358 Coq.Init.Logic <> :type_scope:x_'='_x not
R48340:48350 proof <> getWriteAt' def
R48359:48362 Coq.Init.Datatypes <> Some constr
R48364:48365 proof <> w' var
R48396:48399 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R48387:48393 proof <> writeIx def
R48395:48395 proof <> w var
R48400:48406 proof <> writeIx def
R48408:48409 proof <> w' var
R48426:48461 proof <> emptyDependenceSetImpliesNoAliasing' thm
R48426:48461 proof <> emptyDependenceSetImpliesNoAliasing' thm
def 48868:48895 <> applyScheduleToDependenceSet
R48904:48907 Coq.Init.Logic <> :type_scope:x_'->'_x not
R48908:48910 Coq.Init.Datatypes <> nat ind
R48901:48903 Coq.Init.Datatypes <> nat ind
R48918:48930 proof <> dependenceset def
R48935:48947 proof <> dependenceset def
R48954:48961 Coq.Lists.List <> map def
R48993:48994 proof <> ds var
R48964:48988 proof <> applyScheduleToDependence def
R48990:48990 proof <> s var
prf 49098:49142 <> dependenceAliasesTransportAcrossValidSchedule
R49161:49163 proof <> com ind
R49178:49181 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49182:49184 Coq.Init.Datatypes <> nat ind
R49175:49177 Coq.Init.Datatypes <> nat ind
R49191:49200 proof <> dependence def
R49242:49249 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49272:49279 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49301:49309 Coq.Init.Logic <> :type_scope:x_'->'_x not
R49310:49327 proof <> dependenceAliases' def
R49361:49362 proof <> c' var
R49330:49354 proof <> applyScheduleToDependence def
R49358:49358 proof <> d var
R49356:49356 proof <> s var
R49280:49296 proof <> dependenceInRange def
R49300:49300 proof <> c var
R49298:49298 proof <> d var
R49250:49267 proof <> dependenceAliases' def
R49271:49271 proof <> c var
R49269:49269 proof <> d var
R49208:49229 proof <> scheduleMappingWitness def
R49240:49241 proof <> c' var
R49238:49238 proof <> c var
R49233:49236 proof <> sinv var
R49231:49231 proof <> s var
R49381:49398 proof <> dependenceAliases' def
R49466:49487 proof <> scheduleMappingWitness def
R49507:49517 proof <> getWriteAt' def
R49507:49517 proof <> getWriteAt' def
R49549:49559 proof <> getWriteAt' def
R49549:49559 proof <> getWriteAt' def
R49620:49630 proof <> getWriteAt' def
R49620:49630 proof <> getWriteAt' def
R49669:49679 proof <> getWriteAt' def
R49669:49679 proof <> getWriteAt' def
R49739:49741 Coq.Init.Logic <> :type_scope:x_'='_x not
R49719:49729 proof <> getWriteAt' def
R49742:49752 proof <> getWriteAt' def
R49739:49741 Coq.Init.Logic <> :type_scope:x_'='_x not
R49719:49729 proof <> getWriteAt' def
R49742:49752 proof <> getWriteAt' def
R49797:49800 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R49792:49795 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R49802:49805 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R49806:49811 proof <> comlen def
R49797:49800 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R49792:49795 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R49802:49805 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R49806:49811 proof <> comlen def
R49838:49854 proof <> dependenceInRange def
R49870:49885 proof <> commandIxInRange def
R50029:50031 Coq.Init.Logic <> :type_scope:x_'='_x not
R50008:50018 proof <> getWriteAt' def
R50032:50042 proof <> getWriteAt' def
R50029:50031 Coq.Init.Logic <> :type_scope:x_'='_x not
R50008:50018 proof <> getWriteAt' def
R50032:50042 proof <> getWriteAt' def
R50086:50089 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R50081:50084 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R50092:50095 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R50096:50101 proof <> comlen def
R50086:50089 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R50081:50084 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R50092:50095 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R50096:50101 proof <> comlen def
R50114:50130 proof <> dependenceInRange def
R50146:50161 proof <> commandIxInRange def
prf 50297:50341 <> dependenceInRangeTransportAcrossValidSchedule
R50360:50362 proof <> com ind
R50377:50380 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50381:50383 Coq.Init.Datatypes <> nat ind
R50374:50376 Coq.Init.Datatypes <> nat ind
R50390:50399 proof <> dependence def
R50441:50448 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50470:50478 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50479:50495 proof <> dependenceInRange def
R50529:50530 proof <> c' var
R50498:50522 proof <> applyScheduleToDependence def
R50526:50526 proof <> d var
R50524:50524 proof <> s var
R50449:50465 proof <> dependenceInRange def
R50469:50469 proof <> c var
R50467:50467 proof <> d var
R50407:50428 proof <> scheduleMappingWitness def
R50439:50440 proof <> c' var
R50437:50437 proof <> c var
R50432:50435 proof <> sinv var
R50430:50430 proof <> s var
R50549:50565 proof <> dependenceInRange def
R50577:50598 proof <> scheduleMappingWitness def
R50610:50634 proof <> applyScheduleToDependence def
R50646:50661 proof <> commandIxInRange def
R50748:50751 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R50744:50746 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R50753:50756 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R50757:50762 proof <> comlen def
R50748:50751 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R50744:50746 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R50753:50756 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R50757:50762 proof <> comlen def
prf 50909:50957 <> dependenceLexPositiveTransportAcrossValidSchedule
R50973:50975 proof <> com ind
R50985:50988 Coq.Init.Logic <> :type_scope:x_'->'_x not
R50989:50991 Coq.Init.Datatypes <> nat ind
R50982:50984 Coq.Init.Datatypes <> nat ind
R50998:51007 proof <> dependence def
R51015:51027 proof <> dependenceset def
R51061:51068 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51103:51110 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51134:51141 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51164:51171 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51193:51201 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51202:51222 proof <> dependenceLexPositive def
R51225:51249 proof <> applyScheduleToDependence def
R51253:51253 proof <> d var
R51251:51251 proof <> s var
R51172:51188 proof <> dependenceInRange def
R51192:51192 proof <> c var
R51190:51190 proof <> d var
R51142:51159 proof <> dependenceAliases' def
R51163:51163 proof <> c var
R51161:51161 proof <> d var
R51111:51131 proof <> dependenceLexPositive def
R51133:51133 proof <> d var
R51069:51097 proof <> scheduleRespectsDependenceSet def
R51101:51102 proof <> ds var
R51099:51099 proof <> s var
R51035:51055 proof <> completeDependenceSet def
R51059:51060 proof <> ds var
R51057:51057 proof <> c var
R51305:51305 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51307:51308 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51311:51311 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51305:51305 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51307:51308 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51311:51311 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51324:51344 proof <> completeDependenceSet def
R51361:51367 Coq.Lists.List <> In def
R51369:51369 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51371:51372 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51375:51375 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51361:51367 Coq.Lists.List <> In def
R51369:51369 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51371:51372 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51375:51375 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R51413:51438 proof <> scheduleRespectsDependence def
prf 51487:51537 <> dependenceLexPositiveTransportAcrossValidSchedule''
R51556:51558 proof <> com ind
R51573:51576 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51577:51579 Coq.Init.Datatypes <> nat ind
R51570:51572 Coq.Init.Datatypes <> nat ind
R51586:51595 proof <> dependence def
R51603:51615 proof <> dependenceset def
R51649:51657 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51692:51699 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51734:51741 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51764:51771 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51793:51800 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51824:51831 Coq.Init.Logic <> :type_scope:x_'->'_x not
R51832:51852 proof <> dependenceLexPositive def
R51855:51879 proof <> applyScheduleToDependence def
R51883:51883 proof <> d var
R51881:51881 proof <> s var
R51801:51821 proof <> dependenceLexPositive def
R51823:51823 proof <> d var
R51772:51788 proof <> dependenceInRange def
R51792:51792 proof <> c var
R51790:51790 proof <> d var
R51742:51759 proof <> dependenceAliases' def
R51763:51763 proof <> c var
R51761:51761 proof <> d var
R51700:51728 proof <> scheduleRespectsDependenceSet def
R51732:51733 proof <> ds var
R51730:51730 proof <> s var
R51658:51679 proof <> scheduleMappingWitness def
R51690:51691 proof <> c' var
R51688:51688 proof <> c var
R51683:51686 proof <> sinv var
R51681:51681 proof <> s var
R51623:51643 proof <> completeDependenceSet def
R51647:51648 proof <> ds var
R51645:51645 proof <> c var
R52102:52105 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R52093:52095 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R52123:52126 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R52114:52116 Coq.Init.Logic <> :type_scope:x_'='_x not
R52135:52137 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R52102:52105 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R52093:52095 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R52123:52126 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R52114:52116 Coq.Init.Logic <> :type_scope:x_'='_x not
R52135:52137 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R52506:52508 Coq.Init.Logic <> :type_scope:x_'='_x not
R52506:52508 Coq.Init.Logic <> :type_scope:x_'='_x not
R52565:52567 Coq.Init.Logic <> :type_scope:x_'='_x not
R52565:52567 Coq.Init.Logic <> :type_scope:x_'='_x not
R52593:52614 proof <> scheduleMappingWitness def
R52680:52689 Coq.Logic.ExtensionalityFacts <> is_inverse def
R52796:52816 proof <> dependenceLexPositive def
R52869:52872 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R52862:52864 Coq.Init.Logic <> :type_scope:x_'='_x not
R52879:52881 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R52869:52872 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R52862:52864 Coq.Init.Logic <> :type_scope:x_'='_x not
R52879:52881 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R53177:53205 proof <> scheduleRespectsDependenceSet def
R53233:53258 proof <> scheduleRespectsDependence def
R53262:53262 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53269:53270 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53275:53275 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53233:53258 proof <> scheduleRespectsDependence def
R53262:53262 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53269:53270 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53275:53275 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53353:53353 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53360:53361 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53366:53366 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53353:53353 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53360:53361 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53366:53366 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R53395:53415 proof <> completeDependenceSet def
R53457:53471 proof <> validDependence def
R53497:53522 proof <> scheduleRespectsDependence def
R53564:53584 proof <> dependenceLexPositive def
R53626:53650 proof <> applyScheduleToDependence def
R53749:53752 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R53740:53742 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R53761:53763 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R53749:53752 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R53740:53742 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R53761:53763 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R53889:53917 proof <> scheduleRespectsDependenceSet def
R53947:53963 proof <> dependenceInRange def
R53989:54004 proof <> commandIxInRange def
prf 54067:54086 <> is_inverse_injective
R54111:54114 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54115:54115 proof <> B var
R54110:54110 proof <> A var
R54123:54126 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54127:54127 proof <> A var
R54122:54122 proof <> B var
R54136:54136 proof <> A var
R54154:54157 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54167:54170 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54172:54174 Coq.Init.Logic <> :type_scope:x_'='_x not
R54171:54171 proof <> a var
R54175:54175 proof <> b var
R54161:54163 Coq.Init.Logic <> :type_scope:x_'='_x not
R54158:54158 proof <> f var
R54160:54160 proof <> a var
R54164:54164 proof <> f var
R54166:54166 proof <> b var
R54140:54149 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54153:54153 proof <> g var
R54151:54151 proof <> f var
R54212:54214 Coq.Init.Logic <> :type_scope:x_'='_x not
R54212:54214 Coq.Init.Logic <> :type_scope:x_'='_x not
R54270:54279 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54307:54309 Coq.Init.Logic <> :type_scope:x_'='_x not
R54307:54309 Coq.Init.Logic <> :type_scope:x_'='_x not
R54328:54330 Coq.Init.Logic <> :type_scope:x_'='_x not
R54328:54330 Coq.Init.Logic <> :type_scope:x_'='_x not
prf 54421:54440 <> is_inverse_symmetric
R54465:54468 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54469:54469 proof <> B var
R54464:54464 proof <> A var
R54477:54480 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54481:54481 proof <> A var
R54476:54476 proof <> B var
R54499:54502 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54503:54512 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54516:54516 proof <> f var
R54514:54514 proof <> g var
R54485:54494 Coq.Logic.ExtensionalityFacts <> is_inverse def
R54498:54498 proof <> g var
R54496:54496 proof <> f var
R54545:54554 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 54824:54864 <> dependenceSetTransportAcrossValidSchedule
R54883:54885 proof <> com ind
R54900:54903 Coq.Init.Logic <> :type_scope:x_'->'_x not
R54904:54906 Coq.Init.Datatypes <> nat ind
R54897:54899 Coq.Init.Datatypes <> nat ind
R54914:54926 proof <> dependenceset def
R54960:54967 Coq.Init.Logic <> :type_scope:x_'->'_x not
R55002:55009 Coq.Init.Logic <> :type_scope:x_'->'_x not
R55044:55051 Coq.Init.Logic <> :type_scope:x_'->'_x not
R55052:55072 proof <> completeDependenceSet def
R55078:55105 proof <> applyScheduleToDependenceSet def
R55109:55110 proof <> ds var
R55107:55107 proof <> s var
R55074:55075 proof <> c' var
R55010:55038 proof <> scheduleRespectsDependenceSet def
R55042:55043 proof <> ds var
R55040:55040 proof <> s var
R54968:54989 proof <> scheduleMappingWitness def
R55000:55001 proof <> c' var
R54998:54998 proof <> c var
R54993:54996 proof <> sinv var
R54991:54991 proof <> s var
R54934:54954 proof <> completeDependenceSet def
R54958:54959 proof <> ds var
R54956:54956 proof <> c var
R55143:55164 proof <> scheduleMappingWitness def
R55143:55164 proof <> scheduleMappingWitness def
R55201:55231 proof <> scheduleMappingWitnessSymmetric thm
R55201:55231 proof <> scheduleMappingWitnessSymmetric thm
R55255:55275 proof <> completeDependenceSet def
R55333:55347 proof <> validDependence def
R55440:55467 proof <> applyScheduleToDependenceSet def
R55477:55501 proof <> applyScheduleToDependence def
R55514:55528 Coq.Lists.List <> in_map_iff thm
R55514:55528 Coq.Lists.List <> in_map_iff thm
R55514:55528 Coq.Lists.List <> in_map_iff thm
R55541:55565 proof <> applyScheduleToDependence def
R55541:55565 proof <> applyScheduleToDependence def
R55611:55635 proof <> applyScheduleToDependence def
R55659:55661 Coq.Init.Datatypes <> nat ind
R55675:55677 Coq.Init.Logic <> :type_scope:x_'='_x not
R55673:55673 proof <> n var
R55678:55678 proof <> n var
R55659:55661 Coq.Init.Datatypes <> nat ind
R55675:55677 Coq.Init.Logic <> :type_scope:x_'='_x not
R55673:55673 proof <> n var
R55678:55678 proof <> n var
R55689:55710 proof <> scheduleMappingWitness def
R55737:55746 Coq.Logic.ExtensionalityFacts <> is_inverse def
R55800:55814 proof <> validDependence def
R55836:55880 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R55836:55880 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R55951:55995 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R55951:55995 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R56044:56061 proof <> dependenceAliases' def
R56064:56088 proof <> applyScheduleToDependence def
R56044:56061 proof <> dependenceAliases' def
R56064:56088 proof <> applyScheduleToDependence def
R56112:56156 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R56112:56156 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R56285:56288 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56273:56275 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56312:56315 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56300:56302 Coq.Init.Logic <> :type_scope:x_'='_x not
R56327:56329 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R56285:56288 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56273:56275 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56312:56315 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R56300:56302 Coq.Init.Logic <> :type_scope:x_'='_x not
R56327:56329 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R56415:56435 proof <> dependenceLexPositive def
R56438:56462 proof <> applyScheduleToDependence def
R56541:56543 Coq.Init.Logic <> :type_scope:x_'='_x not
R56541:56543 Coq.Init.Logic <> :type_scope:x_'='_x not
R56560:56579 proof <> is_inverse_injective thm
R56560:56579 proof <> is_inverse_injective thm
R56591:56612 proof <> scheduleMappingWitness def
R56703:56723 proof <> dependenceLexPositive def
R56762:56765 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R56755:56757 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56772:56774 Coq.Init.Logic <> :type_scope:x_'='_x not
R56762:56765 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R56755:56757 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R56772:56774 Coq.Init.Logic <> :type_scope:x_'='_x not
R56839:56845 Coq.Lists.List <> In def
R56848:56872 proof <> applyScheduleToDependence def
R56879:56879 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56884:56885 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56892:56892 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56839:56845 Coq.Lists.List <> In def
R56848:56872 proof <> applyScheduleToDependence def
R56879:56879 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56884:56885 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56892:56892 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R56922:56942 proof <> completeDependenceSet def
R57006:57020 proof <> validDependence def
R57039:57083 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R57039:57083 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R57117:57143 proof <> dependenceAliases'Symmetric thm
R57117:57143 proof <> dependenceAliases'Symmetric thm
R57117:57143 proof <> dependenceAliases'Symmetric thm
R57164:57189 proof <> dependenceInRangeSymmetric thm
R57164:57189 proof <> dependenceInRangeSymmetric thm
R57164:57189 proof <> dependenceInRangeSymmetric thm
R57216:57260 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R57216:57260 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R57294:57319 proof <> dependenceInRangeSymmetric thm
R57294:57319 proof <> dependenceInRangeSymmetric thm
R57294:57319 proof <> dependenceInRangeSymmetric thm
R57338:57358 proof <> dependenceLexPositive def
R57539:57541 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57539:57541 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R57562:57590 proof <> scheduleRespectsDependenceSet def
R57643:57668 proof <> scheduleRespectsDependence def
R57705:57725 proof <> dependenceLexPositive def
R57762:57783 proof <> scheduleMappingWitness def
R57853:57862 Coq.Logic.ExtensionalityFacts <> is_inverse def
R57932:57934 Coq.Init.Logic <> :type_scope:x_'='_x not
R57932:57934 Coq.Init.Logic <> :type_scope:x_'='_x not
R57966:57968 Coq.Init.Logic <> :type_scope:x_'='_x not
R57966:57968 Coq.Init.Logic <> :type_scope:x_'='_x not
R58124:58127 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R58115:58117 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R58134:58136 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R58124:58127 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R58115:58117 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R58134:58136 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R58165:58185 proof <> dependenceLexPositive def
R58399:58413 proof <> validDependence def
R58427:58454 proof <> applyScheduleToDependenceSet def
R58492:58506 Coq.Lists.List <> in_map_iff thm
R58492:58506 Coq.Lists.List <> in_map_iff thm
R58492:58506 Coq.Lists.List <> in_map_iff thm
R58662:58682 proof <> completeDependenceSet def
R58796:58810 proof <> validDependence def
R58877:58921 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R58877:58921 proof <> dependenceAliasesTransportAcrossValidSchedule thm
R59011:59055 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R59011:59055 proof <> dependenceInRangeTransportAcrossValidSchedule thm
R59095:59143 proof <> dependenceLexPositiveTransportAcrossValidSchedule thm
R59095:59143 proof <> dependenceLexPositiveTransportAcrossValidSchedule thm
prf 59214:59252 <> completeDependenceSetConsDestructOnCSeq
R59268:59270 proof <> com ind
R59279:59283 proof <> memix syndef
R59293:59300 proof <> memvalue syndef
R59326:59334 proof <> timepoint syndef
R59342:59354 proof <> dependenceset def
R59432:59439 Coq.Init.Logic <> :type_scope:x_'->'_x not
R59440:59440 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59542:59551 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59572:59572 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59460:59469 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R59541:59541 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R59445:59447 Coq.Init.Logic <> :type_scope:x_'='_x not
R59441:59444 proof <> tend var
R59456:59458 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59448:59453 proof <> comlen def
R59455:59455 proof <> c var
R59470:59477 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R59493:59495 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R59485:59492 proof <> memvalue syndef
R59516:59518 Coq.Init.Logic <> :type_scope:x_'='_x not
R59496:59506 proof <> getWriteAt' def
R59510:59515 proof <> tbegin var
R59508:59508 proof <> c var
R59519:59522 Coq.Init.Datatypes <> Some constr
R59525:59529 proof <> Write constr
R59535:59539 proof <> wval' var
R59531:59533 proof <> wix var
R59556:59559 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R59552:59555 proof <> tend var
R59568:59570 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59560:59565 proof <> comlen def
R59567:59567 proof <> c var
R59362:59382 proof <> completeDependenceSet def
R59425:59428 Coq.Init.Datatypes <> :list_scope:x_'::'_x not
R59411:59411 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59418:59419 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59424:59424 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59412:59417 proof <> tbegin var
R59420:59423 proof <> tend var
R59429:59430 proof <> ds var
R59385:59388 proof <> CSeq constr
R59393:59397 proof <> Write constr
R59403:59406 proof <> wval var
R59399:59401 proof <> wix var
R59390:59390 proof <> c var
R59662:59665 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59647:59649 Coq.Init.Logic <> :type_scope:x_'='_x not
R59658:59660 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59650:59655 proof <> comlen def
R59682:59685 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59670:59673 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R59674:59679 proof <> comlen def
R59690:59692 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R59701:59703 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59693:59698 proof <> comlen def
R59662:59665 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59647:59649 Coq.Init.Logic <> :type_scope:x_'='_x not
R59658:59660 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59650:59655 proof <> comlen def
R59682:59685 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R59670:59673 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R59674:59679 proof <> comlen def
R59690:59692 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R59701:59703 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R59693:59698 proof <> comlen def
R59861:59881 proof <> completeDependenceSet def
R59933:59933 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59940:59941 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59946:59946 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59933:59933 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59940:59941 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R59946:59946 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60010:60024 proof <> validDependence def
R60052:60052 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60059:60060 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60065:60065 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60027:60030 proof <> CSeq constr
R60035:60039 proof <> Write constr
R60010:60024 proof <> validDependence def
R60052:60052 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60059:60060 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60065:60065 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R60027:60030 proof <> CSeq constr
R60035:60039 proof <> Write constr
R60117:60123 Coq.Lists.List <> In def
R60156:60170 proof <> validDependence def
R60261:60268 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60276:60278 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60271:60275 proof <> write ind
R60299:60301 Coq.Init.Logic <> :type_scope:x_'='_x not
R60279:60289 proof <> getWriteAt' def
R60302:60305 Coq.Init.Datatypes <> Some constr
R60307:60307 proof <> w var
R60261:60268 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60276:60278 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R60271:60275 proof <> write ind
R60299:60301 Coq.Init.Logic <> :type_scope:x_'='_x not
R60279:60289 proof <> getWriteAt' def
R60302:60305 Coq.Init.Datatypes <> Some constr
R60307:60307 proof <> w var
R60340:60363 proof <> getWriteAt'RangeComplete thm
R60340:60363 proof <> getWriteAt'RangeComplete thm
R60377:60393 proof <> dependenceInRange def
R60395:60410 proof <> commandIxInRange def
R60413:60418 proof <> comlen def
R60444:60449 proof <> comlen def
R60444:60449 proof <> comlen def
R60556:60576 proof <> dependenceLexPositive def
R60773:60790 proof <> dependenceAliases' def
R60860:60862 Coq.Init.Logic <> :type_scope:x_'='_x not
R60845:60848 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60849:60849 Coq.Init.Datatypes <> S constr
R60851:60856 proof <> comlen def
R60863:60867 Coq.Init.Datatypes <> false constr
R60860:60862 Coq.Init.Logic <> :type_scope:x_'='_x not
R60845:60848 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60849:60849 Coq.Init.Datatypes <> S constr
R60851:60856 proof <> comlen def
R60863:60867 Coq.Init.Datatypes <> false constr
R60899:60901 Coq.Init.Logic <> :type_scope:x_'='_x not
R60884:60887 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60888:60888 Coq.Init.Datatypes <> S constr
R60890:60895 proof <> comlen def
R60902:60905 Coq.Init.Datatypes <> true constr
R60899:60901 Coq.Init.Logic <> :type_scope:x_'='_x not
R60884:60887 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R60888:60888 Coq.Init.Datatypes <> S constr
R60890:60895 proof <> comlen def
R60902:60905 Coq.Init.Datatypes <> true constr
R61179:61188 Coq.Arith.PeanoNat Nat eqb_eq thm
R61179:61188 Coq.Arith.PeanoNat Nat eqb_eq thm
R61179:61188 Coq.Arith.PeanoNat Nat eqb_eq thm
R61198:61214 proof <> dependenceInRange def
R61217:61232 proof <> commandIxInRange def
R61235:61255 proof <> dependenceLexPositive def
R61335:61345 Coq.Arith.PeanoNat Nat eqb_neq thm
R61335:61345 Coq.Arith.PeanoNat Nat eqb_neq thm
R61335:61345 Coq.Arith.PeanoNat Nat eqb_neq thm
R61355:61371 proof <> dependenceInRange def
R61374:61389 proof <> commandIxInRange def
R61392:61412 proof <> dependenceLexPositive def
prf 61516:61561 <> latestAliasingWriteTimepointSpecDestructOnCSeq
R61577:61579 proof <> com ind
R61592:61596 proof <> write ind
R61608:61612 proof <> memix syndef
R61634:61642 proof <> timepoint syndef
R61730:61737 Coq.Init.Logic <> :type_scope:x_'->'_x not
R61770:61777 Coq.Init.Logic <> :type_scope:x_'->'_x not
R61778:61809 proof <> latestAliasingWriteTimepointSpec def
R61821:61824 Coq.Init.Datatypes <> Some constr
R61826:61841 proof <> latest_aliasingt var
R61813:61818 proof <> readix var
R61811:61811 proof <> c var
R61754:61757 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R61738:61753 proof <> latest_aliasingt var
R61766:61768 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R61758:61763 proof <> comlen def
R61765:61765 proof <> c var
R61650:61681 proof <> latestAliasingWriteTimepointSpec def
R61708:61711 Coq.Init.Datatypes <> Some constr
R61713:61728 proof <> latest_aliasingt var
R61700:61705 proof <> readix var
R61684:61687 proof <> CSeq constr
R61691:61697 proof <> latestw var
R61689:61689 proof <> c var
R61871:61902 proof <> latestAliasingWriteTimepointSpec def
R61914:61945 proof <> latestAliasingWriteTimepointSpec def
R62143:62158 proof <> commandIxInRange def
R62177:62182 proof <> comlen def
R62195:62200 proof <> comlen def
R62195:62200 proof <> comlen def
R62318:62320 Coq.Init.Logic <> :type_scope:x_'='_x not
R62288:62298 proof <> getWriteAt' def
R62301:62304 proof <> CSeq constr
R62321:62331 proof <> getWriteAt' def
R62318:62320 Coq.Init.Logic <> :type_scope:x_'='_x not
R62288:62298 proof <> getWriteAt' def
R62301:62304 proof <> CSeq constr
R62321:62331 proof <> getWriteAt' def
R62440:62464 proof <> getWriteAt'DestructOnCSeq thm
R62440:62464 proof <> getWriteAt'DestructOnCSeq thm
R62440:62464 proof <> getWriteAt'DestructOnCSeq thm
R62440:62464 proof <> getWriteAt'DestructOnCSeq thm
R62499:62514 proof <> commandIxInRange def
R62530:62535 proof <> comlen def
R62549:62554 proof <> comlen def
R62549:62554 proof <> comlen def
R62619:62634 proof <> commandIxInRange def
R62637:62640 proof <> CSeq constr
R62619:62634 proof <> commandIxInRange def
R62637:62640 proof <> CSeq constr
R62880:62882 Coq.Init.Logic <> :type_scope:x_'='_x not
R62849:62859 proof <> getWriteAt' def
R62862:62865 proof <> CSeq constr
R62883:62893 proof <> getWriteAt' def
R62880:62882 Coq.Init.Logic <> :type_scope:x_'='_x not
R62849:62859 proof <> getWriteAt' def
R62862:62865 proof <> CSeq constr
R62883:62893 proof <> getWriteAt' def
R62912:62936 proof <> getWriteAt'DestructOnCSeq thm
R62912:62936 proof <> getWriteAt'DestructOnCSeq thm
R62950:62965 proof <> commandIxInRange def
R63045:63069 proof <> commandIxInRangeInclusive thm
R63045:63069 proof <> commandIxInRangeInclusive thm
prf 63143:63177 <> noLatestAliasingWriteDestructOnCSeq
R63193:63195 proof <> com ind
R63202:63206 proof <> write ind
R63218:63222 proof <> memix syndef
R63285:63292 Coq.Init.Logic <> :type_scope:x_'->'_x not
R63293:63324 proof <> latestAliasingWriteTimepointSpec def
R63335:63338 Coq.Init.Datatypes <> None constr
R63328:63333 proof <> readix var
R63326:63326 proof <> c var
R63230:63261 proof <> latestAliasingWriteTimepointSpec def
R63281:63284 Coq.Init.Datatypes <> None constr
R63274:63279 proof <> readix var
R63264:63267 proof <> CSeq constr
R63271:63271 proof <> w var
R63269:63269 proof <> c var
R63394:63425 proof <> latestAliasingWriteTimepointSpec def
R63505:63520 proof <> commandIxInRange def
R63523:63526 proof <> CSeq constr
R63505:63520 proof <> commandIxInRange def
R63523:63526 proof <> CSeq constr
R63570:63594 proof <> commandIxInRangeInclusive thm
R63570:63594 proof <> commandIxInRangeInclusive thm
R63649:63651 Coq.Init.Logic <> :type_scope:x_'='_x not
R63628:63638 proof <> getWriteAt' def
R63652:63662 proof <> getWriteAt' def
R63665:63668 proof <> CSeq constr
R63649:63651 Coq.Init.Logic <> :type_scope:x_'='_x not
R63628:63638 proof <> getWriteAt' def
R63652:63662 proof <> getWriteAt' def
R63665:63668 proof <> CSeq constr
R63724:63748 proof <> getWriteAt'DestructOnCSeq thm
R63724:63748 proof <> getWriteAt'DestructOnCSeq thm
R63758:63773 proof <> commandIxInRange def
R63812:63819 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63831:63833 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63826:63830 proof <> write ind
R63864:63866 Coq.Init.Logic <> :type_scope:x_'='_x not
R63834:63844 proof <> getWriteAt' def
R63847:63850 proof <> CSeq constr
R63867:63870 Coq.Init.Datatypes <> Some constr
R63872:63874 proof <> w_t var
R63812:63819 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63831:63833 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R63826:63830 proof <> write ind
R63864:63866 Coq.Init.Logic <> :type_scope:x_'='_x not
R63834:63844 proof <> getWriteAt' def
R63847:63850 proof <> CSeq constr
R63867:63870 Coq.Init.Datatypes <> Some constr
R63872:63874 proof <> w_t var
R63910:63933 proof <> getWriteAt'RangeComplete thm
R63936:63939 proof <> CSeq constr
R63910:63933 proof <> getWriteAt'RangeComplete thm
R63936:63939 proof <> CSeq constr
R64015:64030 proof <> commandIxInRange def
R64058:64063 proof <> comlen def
R64071:64076 proof <> comlen def
R64071:64076 proof <> comlen def
R64271:64302 proof <> latestAliasingWriteTimepointSpec def
R64478:64481 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R64459:64465 proof <> writeIx def
R64478:64481 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R64459:64465 proof <> writeIx def
R64613:64615 Coq.Init.Logic <> :type_scope:x_'='_x not
R64613:64615 Coq.Init.Logic <> :type_scope:x_'='_x not
prf 64753:64791 <> noLatestAliasingWriteAllowsPunchthrough
R64805:64807 proof <> com ind
R64819:64823 proof <> memix syndef
R64837:64842 proof <> memory def
R64896:64903 Coq.Init.Logic <> :type_scope:x_'->'_x not
R64931:64934 Coq.Init.Logic <> :type_scope:x_'='_x not
R64949:64949 Coq.Init.Logic <> :type_scope:x_'='_x not
R64904:64913 proof <> runProgram def
R64925:64930 proof <> readix var
R64917:64923 proof <> initmem var
R64915:64915 proof <> c var
R64935:64941 proof <> initmem var
R64943:64948 proof <> readix var
R64850:64881 proof <> latestAliasingWriteTimepointSpec def
R64892:64895 Coq.Init.Datatypes <> None constr
R64885:64890 proof <> readix var
R64883:64883 proof <> c var
R65034:65065 proof <> latestAliasingWriteTimepointSpec def
R65076:65079 Coq.Init.Datatypes <> None constr
R65034:65065 proof <> latestAliasingWriteTimepointSpec def
R65076:65079 Coq.Init.Datatypes <> None constr
R65106:65140 proof <> noLatestAliasingWriteDestructOnCSeq thm
R65106:65140 proof <> noLatestAliasingWriteDestructOnCSeq thm
R65217:65220 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R65208:65210 Coq.Init.Logic <> :type_scope:x_'='_x not
R65224:65227 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65217:65220 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R65208:65210 Coq.Init.Logic <> :type_scope:x_'='_x not
R65224:65227 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65418:65421 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65418:65421 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R65440:65471 proof <> latestAliasingWriteTimepointSpec def
R65631:65633 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65623:65628 proof <> comlen def
R65631:65633 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65623:65628 proof <> comlen def
R65651:65666 proof <> commandIxInRange def
R65703:65705 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65695:65700 proof <> comlen def
R65669:65672 proof <> CSeq constr
R65677:65681 proof <> Write constr
R65651:65666 proof <> commandIxInRange def
R65703:65705 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65695:65700 proof <> comlen def
R65669:65672 proof <> CSeq constr
R65677:65681 proof <> Write constr
R65733:65748 proof <> commandIxInRange def
R65751:65756 proof <> comlen def
R65764:65769 proof <> comlen def
R65764:65769 proof <> comlen def
R65899:65901 Coq.Init.Logic <> :type_scope:x_'='_x not
R65884:65887 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R65880:65882 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65872:65877 proof <> comlen def
R65888:65888 Coq.Init.Datatypes <> S constr
R65890:65895 proof <> comlen def
R65902:65905 Coq.Init.Datatypes <> true constr
R65899:65901 Coq.Init.Logic <> :type_scope:x_'='_x not
R65884:65887 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R65880:65882 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R65872:65877 proof <> comlen def
R65888:65888 Coq.Init.Datatypes <> S constr
R65890:65895 proof <> comlen def
R65902:65905 Coq.Init.Datatypes <> true constr
R65932:65941 Coq.Arith.PeanoNat Nat eqb_eq thm
R65932:65941 Coq.Arith.PeanoNat Nat eqb_eq thm
R65932:65941 Coq.Arith.PeanoNat Nat eqb_eq thm
R66097:66100 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R66088:66090 Coq.Init.Logic <> :type_scope:x_'='_x not
R66104:66107 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R66097:66100 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R66088:66090 Coq.Init.Logic <> :type_scope:x_'='_x not
R66104:66107 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R66191:66200 proof <> runProgram def
R66212:66221 proof <> runProgram def
R66212:66221 proof <> runProgram def
R66235:66248 proof <> writeToMemory' def
R66263:66284 proof <> readFromWriteDifferent thm
R66263:66284 proof <> readFromWriteDifferent thm
R66263:66284 proof <> readFromWriteDifferent thm
R66263:66284 proof <> readFromWriteDifferent thm
R66380:66389 proof <> runProgram def
prf 66438:66467 <> latestAliasingWriteWillBeValue
R66481:66483 proof <> com ind
R66495:66499 proof <> memix syndef
R66514:66522 proof <> timepoint syndef
R66532:66539 proof <> memvalue syndef
R66552:66557 proof <> memory def
R66623:66630 Coq.Init.Logic <> :type_scope:x_'->'_x not
R66631:66631 Coq.Init.Logic <> :type_scope:x_'->'_x not
R66683:66691 Coq.Init.Logic <> :type_scope:x_'->'_x not
R66719:66721 Coq.Init.Logic <> :type_scope:x_'='_x not
R66692:66701 proof <> runProgram def
R66713:66718 proof <> readix var
R66705:66711 proof <> initmem var
R66703:66703 proof <> c var
R66722:66725 proof <> wval var
R66656:66658 Coq.Init.Logic <> :type_scope:x_'='_x not
R66632:66642 proof <> getWriteAt' def
R66647:66655 proof <> aliasingt var
R66644:66644 proof <> c var
R66659:66662 Coq.Init.Datatypes <> Some constr
R66665:66669 proof <> Write constr
R66678:66681 proof <> wval var
R66671:66676 proof <> readix var
R66565:66596 proof <> latestAliasingWriteTimepointSpec def
R66608:66611 Coq.Init.Datatypes <> Some constr
R66613:66621 proof <> aliasingt var
R66600:66605 proof <> readix var
R66598:66598 proof <> c var
R66884:66887 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R66870:66872 Coq.Init.Logic <> :type_scope:x_'='_x not
R66873:66873 Coq.Init.Datatypes <> S constr
R66875:66880 proof <> comlen def
R66897:66899 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R66900:66900 Coq.Init.Datatypes <> S constr
R66903:66908 proof <> comlen def
R66884:66887 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R66870:66872 Coq.Init.Logic <> :type_scope:x_'='_x not
R66873:66873 Coq.Init.Datatypes <> S constr
R66875:66880 proof <> comlen def
R66897:66899 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R66900:66900 Coq.Init.Datatypes <> S constr
R66903:66908 proof <> comlen def
R66925:66950 proof <> getWriteAt'RangeConsistent thm
R66925:66950 proof <> getWriteAt'RangeConsistent thm
R66982:66987 proof <> comlen def
R67013:67018 proof <> comlen def
R67013:67018 proof <> comlen def
R67220:67222 Coq.Init.Logic <> :type_scope:x_'='_x not
R67223:67227 proof <> Write constr
R67220:67222 Coq.Init.Logic <> :type_scope:x_'='_x not
R67223:67227 proof <> Write constr
R67254:67264 proof <> getWriteAt' def
R67296:67301 proof <> comlen def
R67327:67332 proof <> comlen def
R67327:67332 proof <> comlen def
R67393:67395 Coq.Init.Logic <> :type_scope:x_'='_x not
R67377:67380 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R67365:67365 Coq.Init.Datatypes <> S constr
R67368:67373 proof <> comlen def
R67382:67384 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R67385:67390 proof <> comlen def
R67396:67399 Coq.Init.Datatypes <> true constr
R67393:67395 Coq.Init.Logic <> :type_scope:x_'='_x not
R67377:67380 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R67365:67365 Coq.Init.Datatypes <> S constr
R67368:67373 proof <> comlen def
R67382:67384 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R67385:67390 proof <> comlen def
R67396:67399 Coq.Init.Datatypes <> true constr
R67437:67446 Coq.Arith.PeanoNat Nat eqb_eq thm
R67437:67446 Coq.Arith.PeanoNat Nat eqb_eq thm
R67437:67446 Coq.Arith.PeanoNat Nat eqb_eq thm
R67579:67588 proof <> runProgram def
R67596:67605 proof <> runProgram def
R67596:67605 proof <> runProgram def
R67619:67632 proof <> writeToMemory' def
R67645:67666 proof <> readFromWriteIdentical thm
R67645:67666 proof <> readFromWriteIdentical thm
R67781:67784 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67781:67784 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67828:67831 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R67818:67821 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67840:67842 Coq.Init.Logic <> :type_scope:x_'='_x not
R67828:67831 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R67818:67821 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R67840:67842 Coq.Init.Logic <> :type_scope:x_'='_x not
R67977:68008 proof <> latestAliasingWriteTimepointSpec def
R68254:68254 Coq.Init.Datatypes <> S constr
R68257:68262 proof <> comlen def
R68254:68254 Coq.Init.Datatypes <> S constr
R68257:68262 proof <> comlen def
R68298:68300 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R68286:68286 Coq.Init.Datatypes <> S constr
R68289:68294 proof <> comlen def
R68298:68300 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R68286:68286 Coq.Init.Datatypes <> S constr
R68289:68294 proof <> comlen def
R68374:68389 proof <> commandIxInRange def
R68428:68428 Coq.Init.Datatypes <> S constr
R68431:68436 proof <> comlen def
R68392:68395 proof <> CSeq constr
R68400:68404 proof <> Write constr
R68374:68389 proof <> commandIxInRange def
R68428:68428 Coq.Init.Datatypes <> S constr
R68431:68436 proof <> comlen def
R68392:68395 proof <> CSeq constr
R68400:68404 proof <> Write constr
R68459:68474 proof <> commandIxInRange def
R68484:68489 proof <> comlen def
R68497:68502 proof <> comlen def
R68497:68502 proof <> comlen def
R68586:68596 proof <> getWriteAt' def
R68679:68681 Coq.Init.Logic <> :type_scope:x_'='_x not
R68633:68636 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R68621:68621 Coq.Init.Datatypes <> S constr
R68624:68629 proof <> comlen def
R68637:68642 proof <> comlen def
R68645:68648 proof <> CSeq constr
R68653:68657 proof <> Write constr
R68682:68685 Coq.Init.Datatypes <> true constr
R68679:68681 Coq.Init.Logic <> :type_scope:x_'='_x not
R68633:68636 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R68621:68621 Coq.Init.Datatypes <> S constr
R68624:68629 proof <> comlen def
R68637:68642 proof <> comlen def
R68645:68648 proof <> CSeq constr
R68653:68657 proof <> Write constr
R68682:68685 Coq.Init.Datatypes <> true constr
R68704:68709 proof <> comlen def
R68717:68722 proof <> comlen def
R68717:68722 proof <> comlen def
R68733:68742 Coq.Arith.PeanoNat Nat eqb_eq thm
R68733:68742 Coq.Arith.PeanoNat Nat eqb_eq thm
R68733:68742 Coq.Arith.PeanoNat Nat eqb_eq thm
R68976:68979 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R68966:68969 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R68988:68990 Coq.Init.Logic <> :type_scope:x_'='_x not
R68976:68979 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R68966:68969 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R68988:68990 Coq.Init.Logic <> :type_scope:x_'='_x not
R69214:69216 Coq.Init.Logic <> :type_scope:x_'='_x not
R69191:69201 proof <> getWriteAt' def
R69217:69220 Coq.Init.Datatypes <> Some constr
R69223:69227 proof <> Write constr
R69214:69216 Coq.Init.Logic <> :type_scope:x_'='_x not
R69191:69201 proof <> getWriteAt' def
R69217:69220 Coq.Init.Datatypes <> Some constr
R69223:69227 proof <> Write constr
R69312:69336 proof <> getWriteAt'DestructOnCSeq thm
R69312:69336 proof <> getWriteAt'DestructOnCSeq thm
R69353:69378 proof <> getWriteAt'RangeConsistent thm
R69353:69378 proof <> getWriteAt'RangeConsistent thm
R69430:69439 proof <> runProgram def
R69447:69456 proof <> runProgram def
R69447:69456 proof <> runProgram def
R69474:69487 proof <> writeToMemory' def
R69506:69527 proof <> readFromWriteDifferent thm
R69506:69527 proof <> readFromWriteDifferent thm
R69506:69527 proof <> readFromWriteDifferent thm
R69506:69527 proof <> readFromWriteDifferent thm
R69651:69696 proof <> latestAliasingWriteTimepointSpecDestructOnCSeq thm
R69651:69696 proof <> latestAliasingWriteTimepointSpecDestructOnCSeq thm
R69810:69820 proof <> getWriteAt' def
prf 69887:69944 <> noLatestAliasingWriteTimepointTransportAcrossValidSchedule
R69968:69971 Coq.Init.Logic <> :type_scope:x_'->'_x not
R69972:69974 Coq.Init.Datatypes <> nat ind
R69965:69967 Coq.Init.Datatypes <> nat ind
R69984:69986 proof <> com ind
R69998:70002 proof <> memix syndef
R70044:70051 Coq.Init.Logic <> :type_scope:x_'->'_x not
R70098:70106 Coq.Init.Logic <> :type_scope:x_'->'_x not
R70107:70138 proof <> latestAliasingWriteTimepointSpec def
R70150:70153 Coq.Init.Datatypes <> None constr
R70143:70148 proof <> readix var
R70140:70141 proof <> c' var
R70052:70083 proof <> latestAliasingWriteTimepointSpec def
R70094:70097 Coq.Init.Datatypes <> None constr
R70087:70092 proof <> readix var
R70085:70085 proof <> c var
R70010:70031 proof <> scheduleMappingWitness def
R70042:70043 proof <> c' var
R70040:70040 proof <> c var
R70035:70038 proof <> sinv var
R70033:70033 proof <> s var
R70224:70255 proof <> latestAliasingWriteTimepointSpec def
R70532:70547 proof <> commandIxInRange def
R70532:70547 proof <> commandIxInRange def
R70574:70589 proof <> commandIxInRange def
R70608:70629 proof <> scheduleMappingWitness def
R70754:70757 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R70749:70752 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R70760:70763 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R70764:70769 proof <> comlen def
R70754:70757 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R70749:70752 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R70760:70763 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R70764:70769 proof <> comlen def
R70989:70991 Coq.Init.Logic <> :type_scope:x_'='_x not
R70972:70982 proof <> getWriteAt' def
R70992:71002 proof <> getWriteAt' def
R70989:70991 Coq.Init.Logic <> :type_scope:x_'='_x not
R70972:70982 proof <> getWriteAt' def
R70992:71002 proof <> getWriteAt' def
R71029:71050 proof <> scheduleMappingWitness def
R71156:71159 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R71151:71154 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R71162:71165 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R71166:71171 proof <> comlen def
R71156:71159 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R71151:71154 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R71162:71165 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R71166:71171 proof <> comlen def
R71196:71211 proof <> commandIxInRange def
prf 71339:71381 <> commandIxInRangeTransportAlongValidSchedule
R71405:71408 Coq.Init.Logic <> :type_scope:x_'->'_x not
R71409:71411 Coq.Init.Datatypes <> nat ind
R71402:71404 Coq.Init.Datatypes <> nat ind
R71421:71423 proof <> com ind
R71431:71439 proof <> timepoint syndef
R71481:71489 Coq.Init.Logic <> :type_scope:x_'->'_x not
R71546:71546 Coq.Init.Logic <> :type_scope:x_'->'_x not
R71511:71519 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R71490:71505 proof <> commandIxInRange def
R71509:71510 proof <> tp var
R71507:71507 proof <> c var
R71520:71535 proof <> commandIxInRange def
R71541:71541 proof <> s var
R71543:71544 proof <> tp var
R71537:71538 proof <> c' var
R71447:71468 proof <> scheduleMappingWitness def
R71479:71480 proof <> c' var
R71477:71477 proof <> c var
R71472:71475 proof <> sinv var
R71470:71470 proof <> s var
R71639:71654 proof <> commandIxInRange def
R71671:71692 proof <> scheduleMappingWitness def
R71775:71778 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R71770:71773 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R71781:71784 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R71785:71790 proof <> comlen def
R71775:71778 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R71770:71773 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R71781:71784 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R71785:71790 proof <> comlen def
R71941:71956 proof <> commandIxInRange def
R71973:71994 proof <> scheduleMappingWitness def
R72090:72092 Coq.Init.Logic <> :type_scope:x_'='_x not
R72090:72092 Coq.Init.Logic <> :type_scope:x_'='_x not
R72107:72116 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 72196:72233 <> getWriteAt'TransportAlongValidSchedule
R72257:72260 Coq.Init.Logic <> :type_scope:x_'->'_x not
R72261:72263 Coq.Init.Datatypes <> nat ind
R72254:72256 Coq.Init.Datatypes <> nat ind
R72273:72275 proof <> com ind
R72283:72291 proof <> timepoint syndef
R72298:72302 proof <> write ind
R72344:72352 Coq.Init.Logic <> :type_scope:x_'->'_x not
R72417:72417 Coq.Init.Logic <> :type_scope:x_'->'_x not
R72378:72386 Coq.Init.Logic <> :type_scope:x_'<->'_x not
R72369:72371 Coq.Init.Logic <> :type_scope:x_'='_x not
R72353:72363 proof <> getWriteAt' def
R72367:72368 proof <> tp var
R72365:72365 proof <> c var
R72372:72375 Coq.Init.Datatypes <> Some constr
R72377:72377 proof <> w var
R72408:72410 Coq.Init.Logic <> :type_scope:x_'='_x not
R72387:72397 proof <> getWriteAt' def
R72403:72403 proof <> s var
R72405:72406 proof <> tp var
R72399:72400 proof <> c' var
R72411:72414 Coq.Init.Datatypes <> Some constr
R72416:72416 proof <> w var
R72310:72331 proof <> scheduleMappingWitness def
R72342:72343 proof <> c' var
R72340:72340 proof <> c var
R72335:72338 proof <> sinv var
R72333:72333 proof <> s var
R72466:72487 proof <> scheduleMappingWitness def
R72575:72578 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72570:72573 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72581:72584 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72585:72590 proof <> comlen def
R72575:72578 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72570:72573 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72581:72584 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72585:72590 proof <> comlen def
R72605:72630 proof <> getWriteAt'RangeConsistent thm
R72605:72630 proof <> getWriteAt'RangeConsistent thm
R72797:72818 proof <> scheduleMappingWitness def
R72919:72922 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72914:72917 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72927:72930 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72931:72936 proof <> comlen def
R72919:72922 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R72914:72917 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R72927:72930 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R72931:72936 proof <> comlen def
R72952:72977 proof <> getWriteAt'RangeConsistent thm
R72952:72977 proof <> getWriteAt'RangeConsistent thm
R73127:73129 Coq.Init.Logic <> :type_scope:x_'='_x not
R73111:73121 proof <> getWriteAt' def
R73130:73140 proof <> getWriteAt' def
R73127:73129 Coq.Init.Logic <> :type_scope:x_'='_x not
R73111:73121 proof <> getWriteAt' def
R73130:73140 proof <> getWriteAt' def
R73222:73231 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 73320:73342 <> is_inverse_cancellation
R73369:73372 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73373:73373 proof <> A var
R73368:73368 proof <> A var
R73380:73380 proof <> A var
R73403:73407 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73422:73422 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73408:73408 Coq.Init.Logic <> :type_scope:x_'='_x not
R73417:73420 Coq.Init.Logic <> :type_scope:x_'='_x not
R73409:73409 proof <> s var
R73412:73413 proof <> s' var
R73415:73415 proof <> a var
R73421:73421 proof <> a var
R73388:73397 Coq.Logic.ExtensionalityFacts <> is_inverse def
R73401:73402 proof <> s' var
R73399:73399 proof <> s var
R73451:73460 Coq.Logic.ExtensionalityFacts <> is_inverse def
prf 73568:73627 <> latestAliasingWriteTimepointSpecTransportAcrossValidSchedule
R73644:73656 proof <> dependenceset def
R73672:73675 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73676:73678 Coq.Init.Datatypes <> nat ind
R73669:73671 Coq.Init.Datatypes <> nat ind
R73688:73690 proof <> com ind
R73705:73713 proof <> timepoint syndef
R73725:73729 proof <> memix syndef
R73763:73771 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73806:73813 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73848:73855 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73914:73921 Coq.Init.Logic <> :type_scope:x_'->'_x not
R73922:73953 proof <> latestAliasingWriteTimepointSpec def
R73966:73969 Coq.Init.Datatypes <> Some constr
R73972:73972 proof <> s var
R73974:73982 proof <> latest_tp var
R73958:73963 proof <> readix var
R73955:73956 proof <> c' var
R73856:73887 proof <> latestAliasingWriteTimepointSpec def
R73899:73902 Coq.Init.Datatypes <> Some constr
R73904:73912 proof <> latest_tp var
R73891:73896 proof <> readix var
R73889:73889 proof <> c var
R73814:73842 proof <> scheduleRespectsDependenceSet def
R73846:73847 proof <> ds var
R73844:73844 proof <> s var
R73772:73793 proof <> scheduleMappingWitness def
R73804:73805 proof <> c' var
R73802:73802 proof <> c var
R73797:73800 proof <> sinv var
R73795:73795 proof <> s var
R73737:73757 proof <> completeDependenceSet def
R73761:73762 proof <> ds var
R73759:73759 proof <> c var
R74091:74122 proof <> latestAliasingWriteTimepointSpec def
R74189:74220 proof <> latestAliasingWriteTimepointSpec def
R74412:74433 proof <> scheduleMappingWitness def
R74412:74433 proof <> scheduleMappingWitness def
R74459:74489 proof <> scheduleMappingWitnessSymmetric thm
R74459:74489 proof <> scheduleMappingWitnessSymmetric thm
R74520:74529 Coq.Logic.ExtensionalityFacts <> is_inverse def
R74520:74529 Coq.Logic.ExtensionalityFacts <> is_inverse def
R74565:74586 proof <> scheduleMappingWitness def
R74631:74650 proof <> is_inverse_symmetric thm
R74631:74650 proof <> is_inverse_symmetric thm
R74805:74847 proof <> commandIxInRangeTransportAlongValidSchedule thm
R74805:74847 proof <> commandIxInRangeTransportAlongValidSchedule thm
R74885:74907 proof <> is_inverse_cancellation thm
R74885:74907 proof <> is_inverse_cancellation thm
R74885:74907 proof <> is_inverse_cancellation thm
R74885:74907 proof <> is_inverse_cancellation thm
R75051:75088 proof <> getWriteAt'TransportAlongValidSchedule thm
R75051:75088 proof <> getWriteAt'TransportAlongValidSchedule thm
R75131:75153 proof <> is_inverse_cancellation thm
R75131:75153 proof <> is_inverse_cancellation thm
R75131:75153 proof <> is_inverse_cancellation thm
R75131:75153 proof <> is_inverse_cancellation thm
R75328:75335 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75344:75346 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75339:75343 proof <> write ind
R75364:75366 Coq.Init.Logic <> :type_scope:x_'='_x not
R75347:75357 proof <> getWriteAt' def
R75367:75370 Coq.Init.Datatypes <> Some constr
R75372:75372 proof <> w var
R75328:75335 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75344:75346 Coq.Init.Logic <> :type_scope:'exists'_x_'..'_x_','_x not
R75339:75343 proof <> write ind
R75364:75366 Coq.Init.Logic <> :type_scope:x_'='_x not
R75347:75357 proof <> getWriteAt' def
R75367:75370 Coq.Init.Datatypes <> Some constr
R75372:75372 proof <> w var
R75422:75445 proof <> getWriteAt'RangeComplete thm
R75422:75445 proof <> getWriteAt'RangeComplete thm
R75467:75482 proof <> commandIxInRange def
R75757:75760 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R75748:75750 Coq.Init.Logic <> :type_scope:x_'='_x not
R75733:75739 proof <> writeIx def
R75776:75779 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R75761:75767 proof <> writeIx def
R75757:75760 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R75748:75750 Coq.Init.Logic <> :type_scope:x_'='_x not
R75733:75739 proof <> writeIx def
R75776:75779 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R75761:75767 proof <> writeIx def
R76210:76230 proof <> dependenceLexPositive def
R76232:76232 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76244:76245 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76248:76248 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76210:76230 proof <> dependenceLexPositive def
R76232:76232 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76244:76245 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76248:76248 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76287:76307 proof <> dependenceLexPositive def
R76352:76369 proof <> dependenceAliases' def
R76371:76371 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76383:76384 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76387:76387 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76352:76369 proof <> dependenceAliases' def
R76371:76371 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76383:76384 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76387:76387 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R76430:76447 proof <> dependenceAliases' def
R76543:76552 Coq.Init.Datatypes <> option_map def
R76715:76717 Coq.Init.Logic <> :type_scope:x_'='_x not
R76687:76697 proof <> getWriteAt' def
R76718:76721 Coq.Init.Datatypes <> Some constr
R76724:76728 proof <> Write constr
R76715:76717 Coq.Init.Logic <> :type_scope:x_'='_x not
R76687:76697 proof <> getWriteAt' def
R76718:76721 Coq.Init.Datatypes <> Some constr
R76724:76728 proof <> Write constr
R76777:76814 proof <> getWriteAt'TransportAlongValidSchedule thm
R76777:76814 proof <> getWriteAt'TransportAlongValidSchedule thm
R76871:76893 proof <> is_inverse_cancellation thm
R76871:76893 proof <> is_inverse_cancellation thm
R76871:76893 proof <> is_inverse_cancellation thm
R76871:76893 proof <> is_inverse_cancellation thm
R77073:77089 proof <> dependenceInRange def
R77091:77091 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77103:77104 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77107:77107 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77073:77089 proof <> dependenceInRange def
R77091:77091 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77103:77104 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77107:77107 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77139:77155 proof <> dependenceInRange def
R77233:77275 proof <> commandIxInRangeTransportAlongValidSchedule thm
R77233:77275 proof <> commandIxInRangeTransportAlongValidSchedule thm
R77332:77354 proof <> is_inverse_cancellation thm
R77332:77354 proof <> is_inverse_cancellation thm
R77332:77354 proof <> is_inverse_cancellation thm
R77332:77354 proof <> is_inverse_cancellation thm
R77445:77470 proof <> getWriteAt'RangeConsistent thm
R77445:77470 proof <> getWriteAt'RangeConsistent thm
R77517:77532 proof <> commandIxInRange def
R77570:77590 proof <> completeDependenceSet def
R77596:77623 proof <> applyScheduleToDependenceSet def
R77570:77590 proof <> completeDependenceSet def
R77596:77623 proof <> applyScheduleToDependenceSet def
R77675:77715 proof <> dependenceSetTransportAcrossValidSchedule thm
R77675:77715 proof <> dependenceSetTransportAcrossValidSchedule thm
R77926:77932 Coq.Lists.List <> In def
R77953:77980 proof <> applyScheduleToDependenceSet def
R77934:77934 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77946:77947 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77950:77950 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77926:77932 Coq.Lists.List <> In def
R77953:77980 proof <> applyScheduleToDependenceSet def
R77934:77934 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77946:77947 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R77950:77950 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78028:78048 proof <> completeDependenceSet def
R78108:78108 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78120:78121 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78124:78124 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78108:78108 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78120:78121 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78124:78124 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R78181:78195 proof <> validDependence def
R78253:78280 proof <> applyScheduleToDependenceSet def
R78322:78336 Coq.Lists.List <> in_map_iff thm
R78322:78336 Coq.Lists.List <> in_map_iff thm
R78322:78336 Coq.Lists.List <> in_map_iff thm
R78752:78754 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R78752:78754 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R78836:78851 proof <> commandIxInRange def
R78836:78851 proof <> commandIxInRange def
R79111:79113 Coq.Init.Logic <> :type_scope:x_'='_x not
R79090:79093 Coq.Init.Datatypes <> Some constr
R79114:79117 Coq.Init.Datatypes <> Some constr
R79111:79113 Coq.Init.Logic <> :type_scope:x_'='_x not
R79090:79093 Coq.Init.Datatypes <> Some constr
R79114:79117 Coq.Init.Datatypes <> Some constr
R79187:79224 proof <> getWriteAt'TransportAlongValidSchedule thm
R79187:79224 proof <> getWriteAt'TransportAlongValidSchedule thm
R79281:79303 proof <> is_inverse_cancellation thm
R79281:79303 proof <> is_inverse_cancellation thm
R79281:79303 proof <> is_inverse_cancellation thm
R79281:79303 proof <> is_inverse_cancellation thm
R79360:79379 proof <> is_inverse_symmetric thm
R79360:79379 proof <> is_inverse_symmetric thm
R79515:79557 proof <> commandIxInRangeTransportAlongValidSchedule thm
R79515:79557 proof <> commandIxInRangeTransportAlongValidSchedule thm
R79614:79636 proof <> is_inverse_cancellation thm
R79614:79636 proof <> is_inverse_cancellation thm
R79614:79636 proof <> is_inverse_cancellation thm
R79614:79636 proof <> is_inverse_cancellation thm
R79693:79712 proof <> is_inverse_symmetric thm
R79693:79712 proof <> is_inverse_symmetric thm
R79760:79762 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R79760:79762 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R79812:79814 Coq.Init.Logic <> :type_scope:x_'='_x not
R79812:79814 Coq.Init.Logic <> :type_scope:x_'='_x not
R79852:79871 proof <> is_inverse_injective thm
R79852:79871 proof <> is_inverse_injective thm
R79900:79909 Coq.Logic.ExtensionalityFacts <> is_inverse def
R79900:79909 Coq.Logic.ExtensionalityFacts <> is_inverse def
R79958:79977 proof <> is_inverse_symmetric thm
R79958:79977 proof <> is_inverse_symmetric thm
R80125:80127 Coq.Init.Logic <> :type_scope:x_'='_x not
R80125:80127 Coq.Init.Logic <> :type_scope:x_'='_x not
R80199:80221 proof <> is_inverse_cancellation thm
R80199:80221 proof <> is_inverse_cancellation thm
R80199:80221 proof <> is_inverse_cancellation thm
R80199:80221 proof <> is_inverse_cancellation thm
R80350:80370 proof <> dependenceLexPositive def
R80372:80372 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80384:80385 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80395:80395 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80350:80370 proof <> dependenceLexPositive def
R80372:80372 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80384:80385 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80395:80395 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80424:80444 proof <> completeDependenceSet def
R80484:80484 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80496:80497 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80507:80507 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80484:80484 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80496:80497 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80507:80507 Coq.Init.Datatypes <> :core_scope:'('_x_','_x_','_'..'_','_x_')' not
R80666:80686 proof <> dependenceLexPositive def
prf 80993:81040 <> getLatestAliasingWriteTimepointForProgramCorrect
R81054:81056 proof <> com ind
R81069:81073 proof <> memix syndef
R81081:81112 proof <> latestAliasingWriteTimepointSpec def
R81125:81165 proof <> getLatestAliasingWriteTimepointForProgram def
R81169:81175 proof <> aliasix var
R81167:81167 proof <> c var
R81116:81122 proof <> aliasix var
R81114:81114 proof <> c var
R81220:81251 proof <> latestAliasingWriteTimepointSpec def
R81287:81318 proof <> latestAliasingWriteTimepointSpec def
R81372:81375 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R81362:81364 Coq.Init.Logic <> :type_scope:x_'='_x not
R81379:81382 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R81372:81375 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R81362:81364 Coq.Init.Logic <> :type_scope:x_'='_x not
R81379:81382 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R81505:81507 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81497:81502 proof <> comlen def
R81505:81507 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81497:81502 proof <> comlen def
R81523:81563 proof <> getLatestAliasingWriteTimepointForProgram def
R81575:81615 proof <> getLatestAliasingWriteTimepointForProgram def
R81575:81615 proof <> getLatestAliasingWriteTimepointForProgram def
R81657:81659 Coq.Init.Logic <> :type_scope:x_'='_x not
R81646:81649 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R81660:81663 Coq.Init.Datatypes <> true constr
R81657:81659 Coq.Init.Logic <> :type_scope:x_'='_x not
R81646:81649 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R81660:81663 Coq.Init.Datatypes <> true constr
R81698:81707 Coq.Arith.PeanoNat Nat eqb_eq thm
R81698:81707 Coq.Arith.PeanoNat Nat eqb_eq thm
R81698:81707 Coq.Arith.PeanoNat Nat eqb_eq thm
R81806:81808 Coq.Init.Logic <> :type_scope:x_'='_x not
R81794:81794 Coq.Init.Datatypes <> S constr
R81797:81802 proof <> comlen def
R81817:81819 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81809:81814 proof <> comlen def
R81806:81808 Coq.Init.Logic <> :type_scope:x_'='_x not
R81794:81794 Coq.Init.Datatypes <> S constr
R81797:81802 proof <> comlen def
R81817:81819 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R81809:81814 proof <> comlen def
R81912:81927 proof <> commandIxInRange def
R81937:81942 proof <> comlen def
R81950:81955 proof <> comlen def
R81950:81955 proof <> comlen def
R82035:82037 Coq.Init.Logic <> :type_scope:x_'='_x not
R82019:82022 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R82015:82017 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R82007:82012 proof <> comlen def
R82023:82023 Coq.Init.Datatypes <> S constr
R82026:82031 proof <> comlen def
R82038:82041 Coq.Init.Datatypes <> true constr
R82035:82037 Coq.Init.Logic <> :type_scope:x_'='_x not
R82019:82022 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R82015:82017 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R82007:82012 proof <> comlen def
R82023:82023 Coq.Init.Datatypes <> S constr
R82026:82031 proof <> comlen def
R82038:82041 Coq.Init.Datatypes <> true constr
R82064:82073 Coq.Arith.PeanoNat Nat eqb_eq thm
R82064:82073 Coq.Arith.PeanoNat Nat eqb_eq thm
R82064:82073 Coq.Arith.PeanoNat Nat eqb_eq thm
R82238:82253 proof <> commandIxInRange def
R82281:82286 proof <> comlen def
R82312:82317 proof <> comlen def
R82312:82317 proof <> comlen def
R82417:82419 Coq.Init.Logic <> :type_scope:x_'='_x not
R82406:82409 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R82420:82424 Coq.Init.Datatypes <> false constr
R82417:82419 Coq.Init.Logic <> :type_scope:x_'='_x not
R82406:82409 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R82420:82424 Coq.Init.Datatypes <> false constr
R82436:82446 Coq.Arith.PeanoNat Nat eqb_neq thm
R82436:82446 Coq.Arith.PeanoNat Nat eqb_neq thm
R82436:82446 Coq.Arith.PeanoNat Nat eqb_neq thm
R82467:82507 proof <> getLatestAliasingWriteTimepointForProgram def
R82530:82570 proof <> getLatestAliasingWriteTimepointForProgram def
R82530:82570 proof <> getLatestAliasingWriteTimepointForProgram def
R82803:82827 proof <> commandIxInRangeInclusive thm
R82803:82827 proof <> commandIxInRangeInclusive thm
R83003:83006 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R82988:82990 Coq.Init.Logic <> :type_scope:x_'='_x not
R82991:82991 Coq.Init.Datatypes <> S constr
R82994:82999 proof <> comlen def
R83017:83020 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R83021:83021 Coq.Init.Datatypes <> S constr
R83024:83029 proof <> comlen def
R83003:83006 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R82988:82990 Coq.Init.Logic <> :type_scope:x_'='_x not
R82991:82991 Coq.Init.Datatypes <> S constr
R82994:82999 proof <> comlen def
R83017:83020 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R83021:83021 Coq.Init.Datatypes <> S constr
R83024:83029 proof <> comlen def
R83130:83155 proof <> getWriteAt'RangeConsistent thm
R83130:83155 proof <> getWriteAt'RangeConsistent thm
R83285:83288 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R83273:83273 Coq.Init.Datatypes <> S constr
R83276:83281 proof <> comlen def
R83289:83294 proof <> comlen def
R83285:83288 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R83273:83273 Coq.Init.Datatypes <> S constr
R83276:83281 proof <> comlen def
R83289:83294 proof <> comlen def
R83396:83398 Coq.Init.Logic <> :type_scope:x_'='_x not
R83380:83383 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R83384:83384 Coq.Init.Datatypes <> S constr
R83387:83392 proof <> comlen def
R83399:83403 Coq.Init.Datatypes <> false constr
R83396:83398 Coq.Init.Logic <> :type_scope:x_'='_x not
R83380:83383 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R83384:83384 Coq.Init.Datatypes <> S constr
R83387:83392 proof <> comlen def
R83399:83403 Coq.Init.Datatypes <> false constr
R83446:83456 Coq.Arith.PeanoNat Nat eqb_neq thm
R83446:83456 Coq.Arith.PeanoNat Nat eqb_neq thm
R83446:83456 Coq.Arith.PeanoNat Nat eqb_neq thm
R83845:83865 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R83830:83832 Coq.Init.Logic <> :type_scope:x_'='_x not
R83833:83833 Coq.Init.Datatypes <> S constr
R83836:83841 proof <> comlen def
R83882:83884 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R83885:83885 Coq.Init.Datatypes <> S constr
R83888:83893 proof <> comlen def
R83845:83865 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R83830:83832 Coq.Init.Logic <> :type_scope:x_'='_x not
R83833:83833 Coq.Init.Datatypes <> S constr
R83836:83841 proof <> comlen def
R83882:83884 Coq.Init.Peano <> :nat_scope:x_'<'_x not
R83885:83885 Coq.Init.Datatypes <> S constr
R83888:83893 proof <> comlen def
R83916:83931 proof <> commandIxInRange def
R83955:83960 proof <> comlen def
R83973:83978 proof <> comlen def
R83973:83978 proof <> comlen def
R84156:84158 Coq.Init.Logic <> :type_scope:x_'='_x not
R84141:84144 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84145:84145 Coq.Init.Datatypes <> S constr
R84147:84152 proof <> comlen def
R84159:84162 Coq.Init.Datatypes <> true constr
R84156:84158 Coq.Init.Logic <> :type_scope:x_'='_x not
R84141:84144 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84145:84145 Coq.Init.Datatypes <> S constr
R84147:84152 proof <> comlen def
R84159:84162 Coq.Init.Datatypes <> true constr
R84183:84192 Coq.Arith.PeanoNat Nat eqb_eq thm
R84183:84192 Coq.Arith.PeanoNat Nat eqb_eq thm
R84183:84192 Coq.Arith.PeanoNat Nat eqb_eq thm
R84250:84254 proof <> Write constr
R84250:84254 proof <> Write constr
R84384:84386 Coq.Init.Logic <> :type_scope:x_'='_x not
R84368:84371 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84372:84372 Coq.Init.Datatypes <> S constr
R84375:84380 proof <> comlen def
R84387:84391 Coq.Init.Datatypes <> false constr
R84384:84386 Coq.Init.Logic <> :type_scope:x_'='_x not
R84368:84371 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R84372:84372 Coq.Init.Datatypes <> S constr
R84375:84380 proof <> comlen def
R84387:84391 Coq.Init.Datatypes <> false constr
R84412:84422 Coq.Arith.PeanoNat Nat eqb_neq thm
R84412:84422 Coq.Arith.PeanoNat Nat eqb_neq thm
R84412:84422 Coq.Arith.PeanoNat Nat eqb_neq thm
R84472:84487 proof <> commandIxInRange def
R84472:84487 proof <> commandIxInRange def
R84566:84581 proof <> commandIxInRange def
R84605:84610 proof <> comlen def
R84623:84628 proof <> comlen def
R84623:84628 proof <> comlen def
R84737:84768 proof <> latestAliasingWriteTimepointSpec def
R84826:84829 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R84816:84818 Coq.Init.Logic <> :type_scope:x_'='_x not
R84833:84836 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R84826:84829 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R84816:84818 Coq.Init.Logic <> :type_scope:x_'='_x not
R84833:84836 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R84930:84970 proof <> getLatestAliasingWriteTimepointForProgram def
R85010:85012 Coq.Init.Logic <> :type_scope:x_'='_x not
R84999:85002 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85013:85016 Coq.Init.Datatypes <> true constr
R85010:85012 Coq.Init.Logic <> :type_scope:x_'='_x not
R84999:85002 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85013:85016 Coq.Init.Datatypes <> true constr
R85028:85037 Coq.Arith.PeanoNat Nat eqb_eq thm
R85028:85037 Coq.Arith.PeanoNat Nat eqb_eq thm
R85028:85037 Coq.Arith.PeanoNat Nat eqb_eq thm
R85085:85085 Coq.Init.Datatypes <> S constr
R85088:85093 proof <> comlen def
R85085:85085 Coq.Init.Datatypes <> S constr
R85088:85093 proof <> comlen def
R85172:85187 proof <> commandIxInRange def
R85197:85202 proof <> comlen def
R85210:85215 proof <> comlen def
R85210:85215 proof <> comlen def
R85329:85331 Coq.Init.Logic <> :type_scope:x_'='_x not
R85317:85320 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85309:85314 proof <> comlen def
R85321:85326 proof <> comlen def
R85332:85335 Coq.Init.Datatypes <> true constr
R85329:85331 Coq.Init.Logic <> :type_scope:x_'='_x not
R85317:85320 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85309:85314 proof <> comlen def
R85321:85326 proof <> comlen def
R85332:85335 Coq.Init.Datatypes <> true constr
R85358:85367 Coq.Arith.PeanoNat Nat eqb_eq thm
R85358:85367 Coq.Arith.PeanoNat Nat eqb_eq thm
R85358:85367 Coq.Arith.PeanoNat Nat eqb_eq thm
R85502:85517 proof <> commandIxInRange def
R85533:85538 proof <> comlen def
R85552:85557 proof <> comlen def
R85552:85557 proof <> comlen def
R85603:85606 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R85587:85590 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R85592:85594 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R85595:85600 proof <> comlen def
R85609:85611 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R85612:85612 Coq.Init.Datatypes <> S constr
R85615:85620 proof <> comlen def
R85603:85606 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R85587:85590 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R85592:85594 Coq.Init.Peano <> :nat_scope:x_'+'_x not
R85595:85600 proof <> comlen def
R85609:85611 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R85612:85612 Coq.Init.Datatypes <> S constr
R85615:85620 proof <> comlen def
R85725:85727 Coq.Init.Logic <> :type_scope:x_'='_x not
R85714:85717 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85728:85732 Coq.Init.Datatypes <> false constr
R85725:85727 Coq.Init.Logic <> :type_scope:x_'='_x not
R85714:85717 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R85728:85732 Coq.Init.Datatypes <> false constr
R85769:85779 Coq.Arith.PeanoNat Nat eqb_neq thm
R85769:85779 Coq.Arith.PeanoNat Nat eqb_neq thm
R85769:85779 Coq.Arith.PeanoNat Nat eqb_neq thm
R85801:85841 proof <> getLatestAliasingWriteTimepointForProgram def
R85866:85906 proof <> getLatestAliasingWriteTimepointForProgram def
R85866:85906 proof <> getLatestAliasingWriteTimepointForProgram def
R86028:86031 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86013:86015 Coq.Init.Logic <> :type_scope:x_'='_x not
R86016:86016 Coq.Init.Datatypes <> S constr
R86019:86024 proof <> comlen def
R86034:86037 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R86038:86038 Coq.Init.Datatypes <> S constr
R86041:86046 proof <> comlen def
R86028:86031 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R86013:86015 Coq.Init.Logic <> :type_scope:x_'='_x not
R86016:86016 Coq.Init.Datatypes <> S constr
R86019:86024 proof <> comlen def
R86034:86037 Coq.Init.Logic <> :type_scope:x_'<>'_x not
R86038:86038 Coq.Init.Datatypes <> S constr
R86041:86046 proof <> comlen def
R86145:86147 Coq.Init.Logic <> :type_scope:x_'='_x not
R86129:86132 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R86133:86133 Coq.Init.Datatypes <> S constr
R86136:86141 proof <> comlen def
R86148:86151 Coq.Init.Datatypes <> true constr
R86145:86147 Coq.Init.Logic <> :type_scope:x_'='_x not
R86129:86132 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R86133:86133 Coq.Init.Datatypes <> S constr
R86136:86141 proof <> comlen def
R86148:86151 Coq.Init.Datatypes <> true constr
R86174:86183 Coq.Arith.PeanoNat Nat eqb_eq thm
R86174:86183 Coq.Arith.PeanoNat Nat eqb_eq thm
R86174:86183 Coq.Arith.PeanoNat Nat eqb_eq thm
R86245:86249 proof <> Write constr
R86245:86249 proof <> Write constr
R86317:86319 Coq.Init.Logic <> :type_scope:x_'='_x not
R86301:86304 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R86305:86305 Coq.Init.Datatypes <> S constr
R86308:86313 proof <> comlen def
R86320:86324 Coq.Init.Datatypes <> false constr
R86317:86319 Coq.Init.Logic <> :type_scope:x_'='_x not
R86301:86304 Coq.Arith.PeanoNat <> :nat_scope:x_'=?'_x not
R86305:86305 Coq.Init.Datatypes <> S constr
R86308:86313 proof <> comlen def
R86320:86324 Coq.Init.Datatypes <> false constr
R86347:86357 Coq.Arith.PeanoNat Nat eqb_neq thm
R86347:86357 Coq.Arith.PeanoNat Nat eqb_neq thm
R86347:86357 Coq.Arith.PeanoNat Nat eqb_neq thm
R86442:86457 proof <> commandIxInRange def
R86442:86457 proof <> commandIxInRange def
R86501:86516 proof <> commandIxInRange def
R86542:86547 proof <> comlen def
R86571:86576 proof <> comlen def
R86571:86576 proof <> comlen def
R86690:86730 proof <> getLatestAliasingWriteTimepointForProgram def
R86744:86775 proof <> latestAliasingWriteTimepointSpec def
prf 86895:86933 <> getWriteAt'TransportAlongValidSchedule'
R86957:86960 Coq.Init.Logic <> :type_scope:x_'->'_x not
R86961:86963 Coq.Init.Datatypes <> nat ind
R86954:86956 Coq.Init.Datatypes <> nat ind
R86973:86975 proof <> com ind
R86983:86991 proof <> timepoint syndef
R86998:87002 proof <> write ind
R87044:87052 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87069:87071 Coq.Init.Logic <> :type_scope:x_'='_x not
R87053:87063 proof <> getWriteAt' def
R87067:87068 proof <> tp var
R87065:87065 proof <> c var
R87072:87082 proof <> getWriteAt' def
R87088:87088 proof <> s var
R87090:87091 proof <> tp var
R87084:87085 proof <> c' var
R87010:87031 proof <> scheduleMappingWitness def
R87042:87043 proof <> c' var
R87040:87040 proof <> c var
R87035:87038 proof <> sinv var
R87033:87033 proof <> s var
R87122:87122 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R87148:87152 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R87130:87133 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R87125:87128 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R87136:87139 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R87140:87145 proof <> comlen def
R87159:87162 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R87155:87157 Coq.Init.Logic <> :type_scope:x_'='_x not
R87165:87167 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R87168:87173 proof <> comlen def
R87122:87122 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R87148:87152 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R87130:87133 Coq.Init.Logic <> :type_scope:x_'/\'_x not
R87125:87128 Coq.Init.Peano <> :nat_scope:x_'>='_x not
R87136:87139 Coq.Init.Peano <> :nat_scope:x_'<='_x not
R87140:87145 proof <> comlen def
R87159:87162 Coq.Init.Logic <> :type_scope:x_'\/'_x not
R87155:87157 Coq.Init.Logic <> :type_scope:x_'='_x not
R87165:87167 Coq.Init.Peano <> :nat_scope:x_'>'_x not
R87168:87173 proof <> comlen def
prf 87452:87479 <> reschedulePreservesSemantics
R87496:87498 proof <> com ind
R87506:87518 proof <> dependenceset def
R87533:87536 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87537:87539 Coq.Init.Datatypes <> nat ind
R87530:87532 Coq.Init.Datatypes <> nat ind
R87573:87576 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87611:87618 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87653:87656 Coq.Init.Logic <> :type_scope:x_'->'_x not
R87658:87662 proof <> ::x_'==='_x not
R87657:87657 proof <> c var
R87663:87664 proof <> c' var
R87619:87647 proof <> scheduleRespectsDependenceSet def
R87651:87652 proof <> ds var
R87649:87649 proof <> s var
R87577:87598 proof <> scheduleMappingWitness def
R87609:87610 proof <> c' var
R87607:87607 proof <> c var
R87602:87605 proof <> sinv var
R87600:87600 proof <> s var
R87547:87567 proof <> completeDependenceSet def
R87571:87572 proof <> ds var
R87569:87569 proof <> c var
R87760:87762 proof <> ceq def
R87794:87818 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R87794:87818 Coq.Logic.FunctionalExtensionality <> functional_extensionality thm
R87863:87903 proof <> getLatestAliasingWriteTimepointForProgram def
R87863:87903 proof <> getLatestAliasingWriteTimepointForProgram def
R87926:87957 proof <> latestAliasingWriteTimepointSpec def
R87969:88009 proof <> getLatestAliasingWriteTimepointForProgram def
R87926:87957 proof <> latestAliasingWriteTimepointSpec def
R87969:88009 proof <> getLatestAliasingWriteTimepointForProgram def
R88047:88094 proof <> getLatestAliasingWriteTimepointForProgramCorrect thm
R88047:88094 proof <> getLatestAliasingWriteTimepointForProgramCorrect thm
R88174:88205 proof <> latestAliasingWriteTimepointSpec def
R88594:88596 Coq.Init.Logic <> :type_scope:x_'='_x not
R88564:88573 proof <> runProgram def
R88594:88596 Coq.Init.Logic <> :type_scope:x_'='_x not
R88564:88573 proof <> runProgram def
R88623:88652 proof <> latestAliasingWriteWillBeValue thm
R88623:88652 proof <> latestAliasingWriteWillBeValue thm
R88811:88813 Coq.Init.Logic <> :type_scope:x_'='_x not
R88780:88789 proof <> runProgram def
R88811:88813 Coq.Init.Logic <> :type_scope:x_'='_x not
R88780:88789 proof <> runProgram def
R88841:88872 proof <> latestAliasingWriteTimepointSpec def
R88885:88888 Coq.Init.Datatypes <> Some constr
R88841:88872 proof <> latestAliasingWriteTimepointSpec def
R88885:88888 Coq.Init.Datatypes <> Some constr
R88936:88995 proof <> latestAliasingWriteTimepointSpecTransportAcrossValidSchedule thm
R88936:88995 proof <> latestAliasingWriteTimepointSpecTransportAcrossValidSchedule thm
R89137:89166 proof <> latestAliasingWriteWillBeValue thm
R89137:89166 proof <> latestAliasingWriteWillBeValue thm
R89233:89235 Coq.Init.Logic <> :type_scope:x_'='_x not
R89202:89212 proof <> getWriteAt' def
R89236:89239 Coq.Init.Datatypes <> Some constr
R89241:89245 proof <> Write constr
R89233:89235 Coq.Init.Logic <> :type_scope:x_'='_x not
R89202:89212 proof <> getWriteAt' def
R89236:89239 Coq.Init.Datatypes <> Some constr
R89241:89245 proof <> Write constr
R89281:89318 proof <> getWriteAt'TransportAlongValidSchedule thm
R89281:89318 proof <> getWriteAt'TransportAlongValidSchedule thm
R89329:89359 proof <> scheduleMappingWitnessSymmetric thm
R89329:89359 proof <> scheduleMappingWitnessSymmetric thm
R89389:89411 proof <> is_inverse_cancellation thm
R89389:89411 proof <> is_inverse_cancellation thm
R89389:89411 proof <> is_inverse_cancellation thm
R89389:89411 proof <> is_inverse_cancellation thm
R89455:89476 proof <> scheduleMappingWitness def
R89531:89550 proof <> is_inverse_symmetric thm
R89531:89550 proof <> is_inverse_symmetric thm
R89626:89629 Coq.Init.Logic <> :type_scope:x_'='_x not
R89647:89647 Coq.Init.Logic <> :type_scope:x_'='_x not
R89596:89605 proof <> runProgram def
R89626:89629 Coq.Init.Logic <> :type_scope:x_'='_x not
R89647:89647 Coq.Init.Logic <> :type_scope:x_'='_x not
R89596:89605 proof <> runProgram def
R89668:89706 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89668:89706 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89828:89831 Coq.Init.Logic <> :type_scope:x_'='_x not
R89849:89849 Coq.Init.Logic <> :type_scope:x_'='_x not
R89797:89806 proof <> runProgram def
R89828:89831 Coq.Init.Logic <> :type_scope:x_'='_x not
R89849:89849 Coq.Init.Logic <> :type_scope:x_'='_x not
R89797:89806 proof <> runProgram def
R89871:89909 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89871:89909 proof <> noLatestAliasingWriteAllowsPunchthrough thm
R89975:90006 proof <> latestAliasingWriteTimepointSpec def
R90018:90021 Coq.Init.Datatypes <> None constr
R89975:90006 proof <> latestAliasingWriteTimepointSpec def
R90018:90021 Coq.Init.Datatypes <> None constr
R90062:90119 proof <> noLatestAliasingWriteTimepointTransportAcrossValidSchedule thm
R90062:90119 proof <> noLatestAliasingWriteTimepointTransportAcrossValidSchedule thm
