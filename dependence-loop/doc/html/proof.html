<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module proof</title>
<meta name="description" content="Documentation of Coq module proof" />
<link href="coq2html.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="coq2html.js"> </script>
</head>

<body onload="hideAll('proofscript')">
<h1 class="title">Module proof</h1>
<div class="coq">
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Lists.List</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FunInd</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Lists.ListSet</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.ZArith.BinInt</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.ZArith.BinIntDef</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Numbers.BinNums</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Lists.List</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.ZArith.Zbool</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.ZArith.Int</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Sorting.Permutation</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Logic.FunctionalExtensionality</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Logic.ExtensionalityFacts</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Omega</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Bool.Sumbool</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.ZArith.Zhints</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Classes.EquivDec</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Structures.Equalities</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.FSets.FMapInterface</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FMapAVL</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FMapFacts</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Logic.FinFun</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Nat</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">VectorDef</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">MSetWeakList</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FSetInterface</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">FSetList</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">Coq.Program.Equality</span>.<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span> <span class="id">CoLoR.Util.FSet.FSetUtil</span>.<br/>
<span class="kwd">Import</span> <span class="id">EqNotations</span>.<br/>
<span class="kwd">Import</span> <span class="id">EqdepFacts</span>.<br/>
<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span><br/>
&nbsp;&nbsp;<span class="id">Coq.FSets.FMapList</span><br/>
&nbsp;&nbsp;<span class="id">Coq.Structures.OrderedTypeEx</span>.<br/>
<br/>
<span class="kwd">Module</span> <span class="kwd">Import</span> <span class="id">M</span> := <span class="id">FMapList.Make</span>(<span class="id">Z_as_OT</span>).<br/>
<span class="kwd">Module</span> <span class="kwd">Import</span> <span class="id">MFacts</span> := <span class="id">WFacts</span>(<span class="id">M</span>).<br/>
<br/>
<br/>
<br/>
<span class="kwd">Require</span> <span class="kwd">Import</span><br/>
&nbsp;&nbsp;<span class="id">Coq.FSets.FMapFacts</span>.<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Notation</span> <span class="id">memix</span> := <span class="id">nat</span>.<br/>
<br/>
<span class="kwd">Notation</span> <span class="id">memvalue</span> := <span class="id">Z</span>.<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">write</span> : <span class="kwd">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id">Write</span>: <span class="id">memix</span> -&gt; <span class="id">memvalue</span> -&gt; <span class="id">write</span>.<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">memory</span> :=  <span class="id">memix</span> -&gt; <span class="id">memvalue</span>.<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">ix</span> '::=' <span class="id">val</span>" := (<span class="id">memory</span> <span class="id">ix</span> <span class="id">val</span>) (<span class="tactic">at</span> <span class="id">level</span> 60).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">initMemory</span> : <span class="id">memory</span> := <span class="kwd">fun</span> <span class="id">ix</span> =&gt; <span class="id">Z0</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">initMemoryAlwaysZero</span> : <span class="kwd">forall</span> (<span class="id">wix</span>: <span class="id">memix</span>), (<span class="id">initMemory</span> <span class="id">wix</span>) = <span class="id">Z0</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof1')">Proof.</div>
<div class="proofscript" id="proof1">
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">writeToMemory</span> (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>) (<span class="id">mold</span>: <span class="id">memory</span>) : <span class="id">memory</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">ix</span> =&gt; <span class="kwd">if</span> (<span class="id">ix</span> =? <span class="id">wix</span>) <span class="kwd">then</span> <span class="id">wval</span> <span class="kwd">else</span> <span class="id">mold</span> <span class="id">ix</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">writeToMemory</span>' (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">mold</span>: <span class="id">memory</span>) : <span class="id">memory</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Write</span> <span class="id">ix</span> <span class="id">val</span> =&gt; <span class="id">writeToMemory</span> <span class="id">ix</span> <span class="id">val</span> <span class="id">mold</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">readFromWriteIdentical</span> : <span class="kwd">forall</span> (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>) (<span class="id">mem</span>: <span class="id">memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">writeToMemory</span> <span class="id">wix</span> <span class="id">wval</span> <span class="id">mem</span>) <span class="id">wix</span> = <span class="id">wval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof2')">Proof.</div>
<div class="proofscript" id="proof2">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">wix</span> <span class="id">wval</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_refl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">readFromWriteDifferent</span> : <span class="kwd">forall</span> (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">rix</span>: <span class="id">memix</span>) (<span class="id">wval</span> : <span class="id">memvalue</span>) (<span class="id">mem</span>: <span class="id">memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rix</span> &lt;&gt; <span class="id">wix</span> -&gt; (<span class="id">writeToMemory</span> <span class="id">wix</span> <span class="id">wval</span> <span class="id">mem</span>) <span class="id">rix</span> = <span class="id">mem</span> <span class="id">rix</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof3')">Proof.</div>
<div class="proofscript" id="proof3">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">wix</span> <span class="id">rix</span> <span class="id">wval</span> <span class="id">mem</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">rix_neq_wix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>((<span class="id">rix</span> =? <span class="id">wix</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">rix_neq_wix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">modelWriteSideEffect</span> (<span class="id">mold</span>: <span class="id">memory</span>) (<span class="id">w</span>: <span class="id">write</span>) : <span class="id">memory</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span> =&gt; (<span class="id">writeToMemory</span> <span class="id">wix</span> <span class="id">wval</span> <span class="id">mold</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<span class="kwd">Inductive</span> <span class="id">com</span>: <span class="kwd">Type</span> :=<br/>
| <span class="id">CSeq</span>: <span class="id">com</span> -&gt; <span class="id">write</span> -&gt; <span class="id">com</span><br/>
| <span class="id">CBegin</span>: <span class="id">com</span>.<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">comlen</span> (<span class="id">c</span>: <span class="id">com</span>) : <span class="id">nat</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; 0<br/>
&nbsp;&nbsp;| <span class="id">CSeq</span> <span class="id">c</span>' <span class="id">_</span> =&gt; 1 + <span class="id">comlen</span> <span class="id">c</span>'<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">n_minus_1_plus_1_eq_n_when_n_gt_0</span>: <span class="kwd">forall</span> (<span class="id">n</span>: <span class="id">nat</span>), <span class="id">n</span> &gt; 0 -&gt; <span class="id">n</span> - 1 + 1 = <span class="id">n</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof4')">Proof.</div>
<div class="proofscript" id="proof4">
 <span class="tactic">intros</span>. <span class="tactic">omega</span>. Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Example</span> <span class="id">c_example</span>' : <span class="id">com</span> := (<span class="id">CSeq</span> (<span class="id">CSeq</span> <span class="id">CBegin</span> (<span class="id">Write</span> 1 100%<span class="id">Z</span>)) (<span class="id">Write</span> 1 100%<span class="id">Z</span>)).<br/>
<br/>
<br/>
<span class="kwd">Notation</span> <span class="id">timepoint</span>  := <span class="id">nat</span>.<br/>
<span class="kwd">Definition</span> <span class="id">writeset</span>: <span class="kwd">Type</span> := <span class="id">memix</span> -&gt; <span class="id">list</span> <span class="id">timepoint</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">emptyWriteSet</span> : <span class="id">writeset</span> := <span class="kwd">fun</span> <span class="id">ix</span> =&gt; <span class="id">List.nil</span>.<br/>
<span class="kwd">Definition</span> <span class="id">addToWriteSet</span> (<span class="id">ws</span>: <span class="id">writeset</span>) (<span class="id">ix</span>: <span class="id">memix</span>) (<span class="id">tp</span>: <span class="id">timepoint</span>) : <span class="id">writeset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">ix</span>' =&gt; <span class="kwd">if</span> <span class="id">ix</span>' =? <span class="id">ix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">List.cons</span> <span class="id">tp</span> (<span class="id">ws</span> <span class="id">ix</span>')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span> <span class="id">ws</span> <span class="id">ix</span>'.<br/>
<span class="kwd">Definition</span> <span class="id">singletonWriteSet</span> (<span class="id">ix</span>: <span class="id">memix</span>) (<span class="id">tp</span>: <span class="id">timepoint</span>) : <span class="id">writeset</span> :=<br/>
&nbsp;&nbsp;<span class="id">addToWriteSet</span> <span class="id">emptyWriteSet</span> <span class="id">ix</span> <span class="id">tp</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">destructInSingletonWriteSet</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ix</span> <span class="id">curix</span>: <span class="id">memix</span>) (<span class="id">curtp</span> <span class="id">tp</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> <span class="id">curtp</span> ((<span class="id">singletonWriteSet</span> <span class="id">ix</span> <span class="id">tp</span>) <span class="id">curix</span>) -&gt; <span class="id">curtp</span> = <span class="id">tp</span> /\ <span class="id">ix</span> = <span class="id">curix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">singletonWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">addToWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">curix</span> = <span class="id">ix</span> \/ <span class="id">curix</span> &lt;&gt; <span class="id">ix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_eq</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">mergeWriteSets</span> (<span class="id">ws</span> <span class="id">ws</span>': <span class="id">writeset</span>) : <span class="id">writeset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">fun</span> <span class="id">ix</span> =&gt; <span class="id">ws</span> <span class="id">ix</span> ++ <span class="id">ws</span>' <span class="id">ix</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">writeToWriteset</span> (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">tp</span>: <span class="id">timepoint</span>) : <span class="id">writeset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Write</span> <span class="id">ix</span> <span class="id">value</span> =&gt; <span class="id">singletonWriteSet</span> <span class="id">ix</span> <span class="id">tp</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">destructInWriteToWriteSet</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">n</span>: <span class="id">nat</span>) (<span class="id">curtp</span> : <span class="id">timepoint</span>) (<span class="id">ix</span> <span class="id">curix</span>: <span class="id">memix</span>) (<span class="id">val</span>: <span class="id">memvalue</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> <span class="id">curtp</span> (<span class="id">writeToWriteset</span> (<span class="id">Write</span> <span class="id">ix</span> <span class="id">val</span>) <span class="id">n</span> <span class="id">curix</span>) -&gt; <span class="id">curtp</span> = <span class="id">n</span> /\ <span class="id">curix</span> = <span class="id">ix</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof5')">Proof.</div>
<div class="proofscript" id="proof5">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToWriteset</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">destructInSingletonWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">dependence</span>: <span class="kwd">Type</span> := <span class="id">nat</span> * <span class="id">nat</span>.<br/>
<span class="kwd">Definition</span> <span class="id">dependenceset</span>: <span class="kwd">Type</span> := <span class="id">list</span> <span class="id">dependence</span>.<br/>
<span class="kwd">Definition</span> <span class="id">emptyDependenceSet</span> : <span class="id">dependenceset</span> := <span class="id">List.nil</span>.<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">dependenceLexPositive</span> (<span class="id">d</span>: <span class="id">dependence</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">fst</span> <span class="id">d</span> &lt; <span class="id">snd</span> <span class="id">d</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">commandIxInRange</span>  (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">i</span>: <span class="id">nat</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span> /\ <span class="id">i</span> &gt;= 1.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">commandIxInRangeDestructOnCSeq</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">i</span>  -&gt; <span class="id">i</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span> + 1  -&gt; <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof6')">Proof.</div>
<div class="proofscript" id="proof6">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">commandIxInRangeInclusive</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">i</span> -&gt; <span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
&nbsp;<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">dependenceInRange</span> (<span class="id">d</span>: <span class="id">dependence</span>) (<span class="id">c</span>: <span class="id">com</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">commandIxInRange</span> <span class="id">c</span> (<span class="id">fst</span> <span class="id">d</span>) /\ <span class="id">commandIxInRange</span> <span class="id">c</span> (<span class="id">snd</span> <span class="id">d</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">dependenceInRangeSymmetric</span>: <span class="kwd">forall</span> (<span class="id">tbegin</span> <span class="id">tend</span>: <span class="id">timepoint</span>) (<span class="id">c</span>: <span class="id">com</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> (<span class="id">tbegin</span>, <span class="id">tend</span>) <span class="id">c</span> &lt;-&gt; <span class="id">dependenceInRange</span> (<span class="id">tend</span>, <span class="id">tbegin</span>) <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof7')">Proof.</div>
<div class="proofscript" id="proof7">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> (<span class="id">tbegin</span> <span class="id">tend</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> (<span class="id">tbegin</span>, <span class="id">tend</span>) <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> (<span class="id">tend</span>, <span class="id">tbegin</span>) <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span>  <span class="id">commandIxInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">writeIx</span> (<span class="id">w</span>: <span class="id">write</span>) : <span class="id">memix</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Write</span> <span class="id">ix</span> <span class="id">_</span> =&gt; <span class="id">ix</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Fixpoint</span> <span class="id">getWriteAt</span>' (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">i</span>: <span class="id">nat</span>) : <span class="id">option</span> <span class="id">write</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">CSeq</span> <span class="id">c</span>' <span class="id">w</span> =&gt; <span class="kwd">if</span> <span class="id">i</span> =? (<span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">then</span> <span class="id">Some</span> <span class="id">w</span> <span class="kwd">else</span> <span class="id">getWriteAt</span>' <span class="id">c</span>' <span class="id">i</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<span class="kwd">Program</span> <span class="kwd">Definition</span> <span class="id">dependenceAliases</span>' (<span class="id">d</span>: <span class="id">dependence</span>) (<span class="id">c</span>: <span class="id">com</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">ix1</span> := <span class="id">fst</span> <span class="id">d</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">ix2</span> := <span class="id">snd</span> <span class="id">d</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">w1</span> := <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">ix1</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">w2</span> := <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">ix2</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;<span class="id">option_map</span> <span class="id">writeIx</span> <span class="id">w1</span> = <span class="id">option_map</span> <span class="id">writeIx</span> <span class="id">w2</span>.<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">dependenceAliases</span>'<span class="id">Symmetric</span>: <span class="kwd">forall</span> (<span class="id">tbegin</span> <span class="id">tend</span>: <span class="id">timepoint</span>) (<span class="id">c</span>: <span class="id">com</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceAliases</span>' (<span class="id">tbegin</span>, <span class="id">tend</span>) <span class="id">c</span> &lt;-&gt; <span class="id">dependenceAliases</span>' (<span class="id">tend</span>, <span class="id">tbegin</span>) <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span>: <span class="id">timepoint</span>), <span class="id">dependenceAliases</span>' (<span class="id">x</span>, <span class="id">y</span>) <span class="id">c</span> -&gt; <span class="id">dependenceAliases</span>' (<span class="id">y</span>, <span class="id">x</span>) <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
Qed.</div>
&nbsp;&nbsp;<br/>
<span class="kwd">Fixpoint</span> <span class="id">computeWriteSet</span> (<span class="id">c</span>: <span class="id">com</span>) : <span class="id">writeset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CSeq</span>  <span class="id">cs</span> <span class="id">w</span> =&gt; <span class="id">mergeWriteSets</span> (<span class="id">computeWriteSet</span> <span class="id">cs</span>) (<span class="id">writeToWriteset</span> <span class="id">w</span> (<span class="id">comlen</span> <span class="id">c</span>))<br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; <span class="id">emptyWriteSet</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">dependencesFromWriteSetAndWrite</span> (<span class="id">t</span>: <span class="id">timepoint</span>) (<span class="id">ws</span>: <span class="id">writeset</span>) (<span class="id">w</span>: <span class="id">write</span>) : <span class="id">dependenceset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">w</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">Write</span> <span class="id">ix</span> <span class="id">_</span> =&gt; <span class="kwd">let</span> <span class="id">prev_write_timepoints_at_ix</span> := <span class="id">ws</span> <span class="id">ix</span> <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.map</span> (<span class="kwd">fun</span> <span class="id">pwt</span> =&gt; (<span class="id">pwt</span>, <span class="id">t</span>))  <span class="id">prev_write_timepoints_at_ix</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">computeDependences</span> (<span class="id">c</span>: <span class="id">com</span>) : <span class="id">dependenceset</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; <span class="id">emptyDependenceSet</span><br/>
&nbsp;&nbsp;| <span class="id">CSeq</span> <span class="id">c</span>' <span class="id">w</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">prevdeps</span> := <span class="id">computeDependences</span>  <span class="id">c</span>' <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">let</span> <span class="id">prevwriteset</span> := <span class="id">computeWriteSet</span> <span class="id">c</span>' <span class="kwd">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">dependencesFromWriteSetAndWrite</span> (<span class="id">comlen</span> <span class="id">c</span>) <span class="id">prevwriteset</span> <span class="id">w</span>) ++ <span class="id">prevdeps</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeDependence0IsEmpty</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>), <span class="id">comlen</span> <span class="id">c</span> = 0 -&gt; <span class="id">computeDependences</span> <span class="id">c</span> = <span class="id">List.nil</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof8')">Proof.</div>
<div class="proofscript" id="proof8">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeWriteSetInBounds</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">ix</span>: <span class="id">memix</span>) (<span class="id">t</span>: <span class="id">timepoint</span>), <span class="id">List.In</span> <span class="id">t</span> ((<span class="id">computeWriteSet</span>  <span class="id">c</span>) <span class="id">ix</span>) -&gt; <span class="id">t</span> &lt;= (<span class="id">comlen</span> <span class="id">c</span>) /\ <span class="id">t</span> &gt;= 1.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof9')">Proof.</div>
<div class="proofscript" id="proof9">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">computeWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mergeWriteSets</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span>  <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToWriteset</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">destructInSingletonWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<br/>
&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeDependencesLexPositive</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>), <span class="id">List.In</span> <span class="id">d</span> (<span class="id">computeDependences</span> <span class="id">c</span>) -&gt; <span class="id">dependenceLexPositive</span> <span class="id">d</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof10')">Proof.</div>
<div class="proofscript" id="proof10">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">d</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>. <span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;till&nbsp;here,&nbsp;shit&nbsp;makes&nbsp;sense&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependencesFromWriteSetAndWrite</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeWriteSetInBounds</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">d</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeDependencesInRange</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>), <span class="id">List.In</span> <span class="id">d</span> (<span class="id">computeDependences</span> <span class="id">c</span>) -&gt; <span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">d</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependencesFromWriteSetAndWrite</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">in_map_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeWriteSetInBounds</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">d</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">i</span>: <span class="id">nat</span>) (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span>  = <span class="id">Some</span> <span class="id">w</span> -&gt; <span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof11')">Proof.</div>
<div class="proofscript" id="proof11">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="kwd">forall</span> (<span class="id">x</span> <span class="id">y</span> : <span class="id">nat</span>), <span class="id">x</span> &lt; <span class="id">y</span> \/ <span class="id">x</span> = <span class="id">y</span> \/ <span class="id">x</span> &gt; <span class="id">y</span>) <span class="kwd">as</span> <span class="id">trichotomy</span>. <span class="tactic">intros</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span>( <span class="id">trichotomy</span> <span class="id">i</span> ((<span class="id">comlen</span> <span class="id">c</span>) + 1)).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">trichotomy</span>.<br/>
&nbsp;i&nbsp;&lt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt;&gt; 1 + (<span class="id">comlen</span> <span class="id">c</span>)). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">try</span> <span class="tactic">assumption</span>. <span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;i&nbsp;=&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;i&nbsp;&gt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt;&gt; 1 + (<span class="id">comlen</span> <span class="id">c</span>)). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;contradiction&nbsp;*)</span>CBegin&nbsp;case&nbsp;-&nbsp;contradiction&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">getWriteAt</span>'<span class="id">RangeComplete</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= (<span class="id">comlen</span> <span class="id">c</span>) -&gt; <span class="id">exists</span> (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">w</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof12')">Proof.</div>
<div class="proofscript" id="proof12">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getWriteAt</span>'. <span class="id">fold</span> <span class="id">getWriteAt</span>'.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">as</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">i</span> = 1 + <span class="id">n</span>\/ <span class="id">i</span> &lt; 1 + <span class="id">n</span> \/ <span class="id">i</span> &gt; 1 + <span class="id">n</span>) <span class="kwd">as</span> <span class="id">trichotomy</span>. <span class="tactic">omega</span>.<br/>
&nbsp;i&nbsp;=&nbsp;n&nbsp;&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">trichotomy</span> <span class="kwd">as</span> [<span class="id">tri</span> | <span class="id">tri</span>'].<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_eq</span> <span class="kwd">in</span> <span class="id">tri</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Heqn</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">tri</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tri</span>' <span class="kwd">as</span> [<span class="id">tri</span>' | <span class="id">tri</span>''].<br/>
&nbsp;i&nbsp;&lt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">n</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">H0</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt;&gt; 1 + <span class="id">n</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">Heqn</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">n</span>). <span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">i</span> <span class="id">H0</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &gt; 1 + <span class="id">n</span> /\ <span class="id">i</span> &lt;= <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt;&gt; 1 + <span class="id">comlen</span> <span class="id">c</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;i&nbsp;&gt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">getWriteAt</span>'<span class="id">OnCSeq</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) (<span class="id">comlen</span> <span class="id">c</span> + 1) = <span class="id">Some</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1  =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span> ) (<span class="id">i</span>: <span class="id">nat</span>) (<span class="id">w</span>: <span class="id">write</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span> /\ <span class="id">i</span> &gt;= 1 -&gt; <span class="id">getWriteAt</span>' (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">i</span> = <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof13')">Proof.</div>
<div class="proofscript" id="proof13">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> = <span class="id">comlen</span> <span class="id">c</span> + 1 \/ <span class="id">i</span> &lt; <span class="id">comlen</span>  <span class="id">c</span> + 1).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">OnCSeq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 =? <span class="id">S</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> +1 =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> =?  (<span class="id">S</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>))) = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">computeWriteSetRange</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">List.In</span> <span class="id">i</span> (((<span class="id">computeWriteSet</span>  <span class="id">c</span>)) <span class="id">wix</span>) -&gt; <span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">computeWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mergeWriteSets</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToWriteset</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">singletonWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">addToWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> = <span class="id">n</span> \/ <span class="id">wix</span> &lt;&gt; <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_eq</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">computeWriteSetCharacterBwd</span> :  <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>) (<span class="id">i</span>: <span class="id">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span>  = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>) -&gt; <span class="id">List.In</span> <span class="id">i</span> ((<span class="id">computeWriteSet</span> <span class="id">c</span>) <span class="id">wix</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof14')">Proof.</div>
<div class="proofscript" id="proof14">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">i</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">wix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">wval</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeWriteSet</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">computeWriteSet</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">mergeWriteSets</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> <span class="id">H</span> <span class="kwd">as</span> <span class="id">getWriteAt</span>'<span class="id">Invoke</span>.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">HeqgetWriteAt</span>'<span class="id">Invoke</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> = <span class="id">comlen</span> <span class="id">c</span> + 1 \/ <span class="id">i</span> &lt; <span class="id">comlen</span> <span class="id">c</span> + 1) <span class="kwd">as</span> <span class="id">icase</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">icase</span> <span class="kwd">as</span> [<span class="id">i_eq_sn</span> | <span class="id">i_lt_sn</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;i&nbsp;=&nbsp;n&nbsp;+&nbsp;1*)</span><br/>
&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToWriteset</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">singletonWriteSet</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">addToWriteSet</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">getWriteAt</span>'<span class="id">Invoke</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>)= <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> =? <span class="id">wix</span> = <span class="id">true</span>). <span class="tactic">exact</span> (<span class="id">Nat.eqb_refl</span> <span class="id">wix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;i&nbsp;&lt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;-  <span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">as</span> <span class="id">witness</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">exists</span> (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>'  <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">w</span>) <span class="kwd">as</span> <span class="id">writeExists</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">getWriteAt</span>'<span class="id">RangeComplete</span> <span class="id">_</span> <span class="id">_</span> <span class="id">witness</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">getWriteAt</span>'<span class="id">Invoke</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">writeExists</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt;&gt; <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">Nat.eqb_neq</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span> <span class="kwd">in</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;i&nbsp;&gt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span>&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">destructInWriteToWriteSet</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">n</span>: <span class="id">nat</span>) (<span class="id">curtp</span> : <span class="id">timepoint</span>) (<span class="id">curix</span>: <span class="id">memix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> <span class="id">curtp</span> (<span class="id">writeToWriteset</span> <span class="id">w</span> <span class="id">n</span> <span class="id">curix</span>) -&gt; <span class="id">curtp</span> = <span class="id">n</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof15')">Proof.</div>
<div class="proofscript" id="proof15">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToWriteset</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">destructInSingletonWriteSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeWriteSetCharacterFwd</span> :  <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">List.In</span> <span class="id">i</span> ((<span class="id">computeWriteSet</span>  <span class="id">c</span>) <span class="id">wix</span>) -&gt; <span class="id">exists</span> (<span class="id">wval</span>: <span class="id">memvalue</span>), <span class="id">getWriteAt</span>'  <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof16')">Proof.</div>
<div class="proofscript" id="proof16">
&nbsp;&nbsp;<span class="tactic">intros</span>  <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">dependent</span> <span class="tactic">induction</span> <span class="id">c</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeWriteSetInBounds</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeWriteSet</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">fold</span> <span class="id">computeWriteSet</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">mergeWriteSets</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;in&nbsp;write&nbsp;set&nbsp;till&nbsp;n*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeWriteSetInBounds</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;in&nbsp;new&nbsp;write&nbsp;set&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> = <span class="id">comlen</span> <span class="id">c</span>+ 1). <span class="tactic">apply</span> <span class="id">destructInWriteToWriteSet</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">destructInWriteToWriteSet</span>' <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">OnCSeq</span>.<br/>
<br/>
&nbsp;CBegin&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">destructDependenceAliasesInCSeq</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">tbegin</span> <span class="id">tend</span>: <span class="id">timepoint</span>)  (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceLexPositive</span> (<span class="id">tbegin</span>, <span class="id">tend</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> (<span class="id">tbegin</span>, <span class="id">tend</span>) (<span class="id">CSeq</span>  <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceAliases</span>' (<span class="id">tbegin</span>, <span class="id">tend</span>) (<span class="id">CSeq</span>  <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tend</span> = <span class="id">comlen</span> <span class="id">c</span> + 1 /\ <span class="id">exists</span> (<span class="id">wval_begin</span>: <span class="id">memvalue</span>), (<span class="id">getWriteAt</span>'  <span class="id">c</span> <span class="id">tbegin</span>) = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval_begin</span>)) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tend</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span> + 1 /\ <span class="id">dependenceAliases</span>' (<span class="id">tbegin</span>, <span class="id">tend</span>)  <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">tend</span> = <span class="id">comlen</span> <span class="id">c</span> + 1) \/ (<span class="id">tend</span> &lt; <span class="id">comlen</span> <span class="id">c</span> + 1 /\ <span class="id">tend</span> &gt;= 1)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>' <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tbegin</span>) <span class="kwd">as</span> <span class="id">write_at_begin</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tbegin</span> = <span class="id">Some</span> <span class="id">w</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeComplete</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span> <span class="id">eqn</span>:<span class="id">xSave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">z</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeIx</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n</span> = <span class="id">wix</span>). <span class="tactic">inversion</span> <span class="id">H1</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H5</span>. <span class="tactic">reflexivity</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>' <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="id">fst</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="id">snd</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> &lt; <span class="id">comlen</span> <span class="id">c</span> + 1 /\ <span class="id">tbegin</span> &gt;= 1).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tend</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span> + 1). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="id">fst</span>. <span class="tactic">simpl</span> <span class="id">snd</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">OnCSeq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> &lt; <span class="id">comlen</span> <span class="id">c</span> + 1 /\ <span class="id">tbegin</span> &gt;= 1).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>'  (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) <span class="id">tbegin</span> = <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tbegin</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>' <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">dependenceInRangeInclusive</span>: <span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>) (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>),  <span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> -&gt; <span class="id">dependenceInRange</span> <span class="id">d</span>  (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">destruct</span> <span class="id">d</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeDependencesAlias</span>'<span class="id">Fwd</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span> ), <span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>), <span class="id">List.In</span> <span class="id">d</span> (<span class="id">computeDependences</span> <span class="id">c</span>) -&gt;  <span class="id">dependenceAliases</span>' <span class="id">d</span>  <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof17')">Proof.</div>
<div class="proofscript" id="proof17">
&nbsp;&nbsp;<span class="tactic">intros</span>  <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">computeDependences</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependencesFromWriteSetAndWrite</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="id">eqn</span>:<span class="id">Wsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">List.in_map_iff</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span> <span class="id">eqn</span>:<span class="id">Dsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n0</span> &gt;= 1 /\ <span class="id">n0</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeWriteSetInBounds</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n0</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> =? <span class="id">comlen</span> <span class="id">c</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeWriteSetCharacterFwd</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-<br/>
&nbsp;inductive&nbsp;case?&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span> <span class="id">eqn</span>:<span class="id">Dsave</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span>  <span class="id">destructDependenceAliasesInCSeq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeDependencesLexPositive</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeDependencesInRange</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">dependenceInRangeInclusive</span>. <span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n1</span> = <span class="id">comlen</span> <span class="id">c</span> + 1 \/ <span class="id">n1</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span>+ 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n1&nbsp;=&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">computeDependencesInRange</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;n1&nbsp;&lt;&gt;&nbsp;n&nbsp;+&nbsp;1&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">_</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">dependenceInRangeDestructOnCSeq</span>: <span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>) (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>), <span class="id">dependenceInRange</span> <span class="id">d</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) -&gt; <span class="id">snd</span> <span class="id">d</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span> + 1 -&gt;<br/>
<span class="id">dependenceLexPositive</span> <span class="id">d</span> -&gt;<br/>
<span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof18')">Proof.</div>
<div class="proofscript" id="proof18">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>. <span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">computeDependenceAlias</span>'<span class="id">Bwd</span>:   <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>), <span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>), <span class="id">dependenceAliases</span>' <span class="id">d</span> <span class="id">c</span> -&gt; <span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> -&gt; <span class="id">dependenceLexPositive</span> <span class="id">d</span>  -&gt; <span class="id">List.In</span> <span class="id">d</span> (<span class="id">computeDependences</span> <span class="id">c</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof19')">Proof.</div>
<div class="proofscript" id="proof19">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span> <span class="id">eqn</span>:<span class="id">dsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="id">eqn</span>:<span class="id">wsave</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> <span class="id">H</span> <span class="kwd">as</span> <span class="id">depAliases</span>. <span class="tactic">clear</span> <span class="id">HeqdepAliases</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">destructDependenceAliasesInCSeq</span> <span class="id">c</span> <span class="id">n</span> <span class="id">n0</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H1</span> <span class="id">H0</span>) <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n0&nbsp;=&nbsp;comlen&nbsp;c&nbsp;+&nbsp;1&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeDependences</span>. <span class="id">fold</span> <span class="id">computeDependences</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependencesFromWriteSetAndWrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>. <span class="comment">(*&nbsp;Dependence&nbsp;will&nbsp;be&nbsp;part&nbsp;of&nbsp;new&nbsp;write&nbsp;set&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_map_iff</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">Nat.add_comm</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">computeWriteSetCharacterBwd</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H2</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;n0&nbsp;&lt;&gt;&nbsp;comlen&nbsp;c&nbsp;+&nbsp;1&nbsp;=&gt;&nbsp;n0&nbsp;&lt;=&nbsp;comlen&nbsp;c&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">computeDependences</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">computeDependences</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependencesFromWriteSetAndWrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_app_iff</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>. <span class="comment">(*&nbsp;This&nbsp;depenednece&nbsp;will&nbsp;be&nbsp;in&nbsp;the&nbsp;older&nbsp;set&nbsp;of&nbsp;deps&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">dependenceInRange</span> (<span class="id">n</span>, <span class="id">n0</span>) <span class="id">c</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">dependenceInRangeDestructOnCSeq</span> <span class="kwd">with</span> (<span class="id">w</span> := <span class="id">w</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>. <span class="tactic">simpl</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">exact</span> <span class="id">H</span>. <span class="tactic">exact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H2</span>. <span class="tactic">exact</span> <span class="id">H1</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;CBegin&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">runProgram</span>  (<span class="id">p</span>: <span class="id">com</span>) (<span class="id">initmemory</span>: <span class="id">memory</span>) : <span class="id">memory</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">p</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; <span class="id">initmemory</span><br/>
&nbsp;&nbsp;| <span class="id">CSeq</span> <span class="id">p</span>' <span class="id">w</span> =&gt; <span class="id">writeToMemory</span>' <span class="id">w</span>  (<span class="id">runProgram</span> <span class="id">p</span>' <span class="id">initmemory</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">ceq</span> (<span class="id">c</span> <span class="id">c</span>' : <span class="id">com</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">initmemory</span> : <span class="id">memory</span>), (<span class="id">runProgram</span> <span class="id">c</span> <span class="id">initmemory</span>) = (<span class="id">runProgram</span> <span class="id">c</span>' <span class="id">initmemory</span>).<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> '===' <span class="id">y</span>" := (<span class="id">ceq</span> <span class="id">x</span> <span class="id">y</span>) (<span class="tactic">at</span> <span class="id">level</span> 70).<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">ceq_refl</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>), <span class="id">c</span> === <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof20')">Proof.</div>
<div class="proofscript" id="proof20">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">ceq_symmetric</span>: <span class="kwd">forall</span>(<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>), <span class="id">c</span> === <span class="id">c</span>' &lt;-&gt; <span class="id">c</span>' === <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof21')">Proof.</div>
<div class="proofscript" id="proof21">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">com_append</span> (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) : <span class="id">com</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span>' <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; <span class="id">c</span><br/>
&nbsp;&nbsp;| <span class="id">CSeq</span> <span class="id">c</span>' <span class="id">w</span> =&gt; <span class="id">CSeq</span>  (<span class="id">com_append</span>  <span class="id">c</span> <span class="id">c</span>') <span class="id">w</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<br/>
<span class="kwd">Notation</span> "<span class="id">x</span> '+++' <span class="id">y</span>"  := (<span class="id">com_append</span>  <span class="id">x</span> <span class="id">y</span>) (<span class="tactic">at</span> <span class="id">level</span> 60).<br/>
<span class="kwd">Theorem</span> <span class="id">ceq_add_cseq</span>: <span class="kwd">forall</span> (<span class="id">cn</span> <span class="id">cn</span>' : <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>), <span class="id">cn</span> === <span class="id">cn</span>' -&gt; (<span class="id">CSeq</span> <span class="id">cn</span> <span class="id">w</span>) ===  (<span class="id">CSeq</span> <span class="id">cn</span>' <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof22')">Proof.</div>
<div class="proofscript" id="proof22">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;<span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> <span class="id">initmemory</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">runprogram_distribute_append</span>: <span class="kwd">forall</span> (<span class="id">cn</span> <span class="id">cn</span>': <span class="id">com</span>), <span class="kwd">forall</span> (<span class="id">initmem</span>: <span class="id">memory</span>), <span class="id">runProgram</span> (<span class="id">cn</span> +++ <span class="id">cn</span>') <span class="id">initmem</span> = <span class="id">runProgram</span> <span class="id">cn</span>' (<span class="id">runProgram</span> <span class="id">cn</span> <span class="id">initmem</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">cn</span> <span class="id">cn</span>'. <span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">cn</span>. <span class="tactic">induction</span> <span class="id">cn</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">com_append</span>. <span class="id">fold</span> <span class="id">com_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>. <span class="tactic">rewrite</span> <span class="id">IHcn</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">unfold</span> <span class="id">com_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">ceq_append_weak</span>: <span class="kwd">forall</span> (<span class="id">c</span> <span class="id">cl</span> <span class="id">cr</span> : <span class="id">com</span>), <span class="id">cl</span> === <span class="id">cr</span> -&gt;<span class="id">cl</span> +++ <span class="id">c</span> === <span class="id">cr</span> +++ <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof23')">Proof.</div>
<div class="proofscript" id="proof23">
&nbsp;&nbsp;<span class="tactic">intro</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">com_append</span>. <span class="id">fold</span> <span class="id">com_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">ceq_add_cseq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHc</span>. <span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">com_append</span>. <span class="tactic">exact</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">ceq_append_strong</span>: <span class="kwd">forall</span> (<span class="id">cl</span> <span class="id">cl</span>' <span class="id">cr</span> <span class="id">cr</span>': <span class="id">com</span>), <span class="id">cl</span> === <span class="id">cr</span> -&gt; <span class="id">cl</span>' === <span class="id">cr</span>' -&gt; <span class="id">cl</span> +++ <span class="id">cl</span>' === <span class="id">cr</span> +++ <span class="id">cr</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">runprogram_distribute_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">runprogram_distribute_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">ceq_switch_no_alias</span>: <span class="kwd">forall</span> (<span class="id">wix1</span> <span class="id">wix2</span>: <span class="id">memix</span>) (<span class="id">wval1</span> <span class="id">wval2</span>: <span class="id">memvalue</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">wix1</span> &lt;&gt; <span class="id">wix2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">CSeq</span> (<span class="id">CSeq</span> <span class="id">CBegin</span> (<span class="id">Write</span> <span class="id">wix1</span> <span class="id">wval1</span>)) (<span class="id">Write</span> <span class="id">wix2</span> <span class="id">wval2</span>) ===<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">CSeq</span> (<span class="id">CSeq</span> <span class="id">CBegin</span> (<span class="id">Write</span> <span class="id">wix2</span> <span class="id">wval2</span>)) (<span class="id">Write</span> <span class="id">wix1</span> <span class="id">wval1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> = <span class="id">wix2</span> \/ <span class="id">x</span> &lt;&gt; <span class="id">wix2</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix2</span> =? <span class="id">wix2</span> = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix2</span> =? <span class="id">wix1</span> = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">reflexivity</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> =? <span class="id">wix2</span> = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">scheduleMappingWitness</span> (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">comlen</span> <span class="id">c</span> = <span class="id">comlen</span> <span class="id">c</span>' /\<br/>
&nbsp;&nbsp;<span class="id">is_inverse</span> <span class="id">s</span> <span class="id">sinv</span> /\<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">i</span> &gt;= 1 /\ <span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s</span> <span class="id">i</span> &gt;= 1 /\ <span class="id">s</span> <span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sinv</span> <span class="id">i</span> &gt;= 1 /\ <span class="id">sinv</span> <span class="id">i</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span> = <span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">i</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span> (<span class="id">sinv</span> <span class="id">i</span>) = <span class="id">getWriteAt</span>' <span class="id">c</span>' <span class="id">i</span>.<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">scheduleMappingWitnessSymmetric</span>: <span class="kwd">forall</span> (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt; <span class="id">scheduleMappingWitness</span> <span class="id">sinv</span> <span class="id">s</span> <span class="id">c</span>' <span class="id">c</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof24')">Proof.</div>
<div class="proofscript" id="proof24">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">try</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span>. <span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">split</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>. <span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">H2</span>). <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H3</span>. <span class="tactic">destruct</span> <span class="id">H4</span>. <span class="tactic">destruct</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">split</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">applyScheduleToDependence</span> (<span class="id">s</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">d</span>: <span class="id">dependence</span>) : <span class="id">dependence</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">d</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| (<span class="id">x0</span>, <span class="id">x1</span>) =&gt; (<span class="id">s</span> <span class="id">x0</span>, <span class="id">s</span> <span class="id">x1</span>)<br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">scheduleRespectsDependence</span> (<span class="id">s</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">d</span>: <span class="id">dependence</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">dependenceLexPositive</span> (<span class="id">applyScheduleToDependence</span> <span class="id">s</span> <span class="id">d</span>).<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">scheduleRespectsDependenceSet</span> (<span class="id">s</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>) : <span class="kwd">Prop</span> := <span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>), <span class="id">List.In</span> <span class="id">d</span> <span class="id">ds</span> -&gt; <span class="id">scheduleRespectsDependence</span> <span class="id">s</span> <span class="id">d</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">validDependence</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">d</span>: <span class="id">dependence</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">dependenceAliases</span>' <span class="id">d</span> <span class="id">c</span> /\ <span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> /\ <span class="id">dependenceLexPositive</span> <span class="id">d</span>.<br/>
<span class="kwd">Hint</span> <span class="kwd">Unfold</span> <span class="id">validDependence</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">completeDependenceSet</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">d</span>: <span class="id">dependence</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">validDependence</span> <span class="id">c</span> <span class="id">d</span> -&gt; <span class="id">List.In</span> <span class="id">d</span> <span class="id">ds</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">List.In</span> <span class="id">d</span> <span class="id">ds</span> -&gt; <span class="id">validDependence</span> <span class="id">c</span> <span class="id">d</span>).<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">emptyDependenceSetImpliesNoAliasing</span>: <span class="kwd">forall</span> (<span class="id">i</span> <span class="id">j</span> : <span class="id">nat</span>) (<span class="id">c</span>: <span class="id">com</span>), <span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">Datatypes.nil</span> -&gt; <span class="id">dependenceLexPositive</span> (<span class="id">i</span>, <span class="id">j</span>) -&gt; <span class="id">dependenceInRange</span> (<span class="id">i</span>, <span class="id">j</span>) <span class="id">c</span> -&gt;  <span class="id">exists</span> (<span class="id">w</span> <span class="id">w</span>': <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">w</span> /\ <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">j</span> = <span class="id">Some</span> <span class="id">w</span>' /\ <span class="id">writeIx</span> <span class="id">w</span> &lt;&gt; <span class="id">writeIx</span> <span class="id">w</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof25')">Proof.</div>
<div class="proofscript" id="proof25">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">wi</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">wi</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeComplete</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">wj</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">j</span> = <span class="id">Some</span> <span class="id">wj</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H1</span>.  <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeComplete</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>. <span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>. <span class="id">exists</span> <span class="id">x0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">writeIx</span> <span class="id">x</span> = <span class="id">writeIx</span> <span class="id">x0</span> \/ <span class="id">writeIx</span> <span class="id">x</span> &lt;&gt; <span class="id">writeIx</span> <span class="id">x0</span>) <span class="kwd">as</span> <span class="id">aliasing_cases</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">aliasing_cases</span>.<br/>
&nbsp;have&nbsp;alias&nbsp;*)</span>&nbsp;&nbsp;-  <span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">i</span>, <span class="id">j</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">intoList</span> <span class="id">outOfList</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">False</span>) <span class="kwd">as</span> <span class="id">contra</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">intoList</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">H3</span>. <span class="tactic">simpl</span>. <span class="tactic">rewrite</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">assumption</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">contra</span>.<br/>
&nbsp;no&nbsp;alias&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;-  <span class="tactic">exact</span> <span class="id">H4</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">emptyDependenceSetImpliesNoAliasing</span>': <span class="kwd">forall</span> (<span class="id">i</span> <span class="id">j</span> : <span class="id">nat</span>) (<span class="id">c</span>: <span class="id">com</span>), <span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">Datatypes.nil</span> -&gt; <span class="id">i</span> &lt;&gt; <span class="id">j</span> -&gt;  <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">i</span> -&gt; <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">j</span> -&gt; <span class="id">exists</span> (<span class="id">w</span> <span class="id">w</span>': <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">w</span> /\ <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">j</span> = <span class="id">Some</span> <span class="id">w</span>' /\ <span class="id">writeIx</span> <span class="id">w</span> &lt;&gt; <span class="id">writeIx</span> <span class="id">w</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> &lt; <span class="id">j</span> \/ <span class="id">i</span> &gt; <span class="id">j</span>) <span class="kwd">as</span> <span class="id">ij_order</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">ij_order</span> <span class="kwd">as</span> [<span class="id">i_lt_j</span> | <span class="id">i_gt_j</span>].<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">emptyDependenceSetImpliesNoAliasing</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span>. <span class="tactic">simpl</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">w</span> <span class="id">w</span>': <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">j</span> = <span class="id">Some</span> <span class="id">w</span> /\ <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span> = <span class="id">Some</span> <span class="id">w</span>' /\ <span class="id">writeIx</span> <span class="id">w</span> &lt;&gt; <span class="id">writeIx</span> <span class="id">w</span>').<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">emptyDependenceSetImpliesNoAliasing</span> <span class="id">j</span> <span class="id">i</span> <span class="id">c</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>. <span class="tactic">destruct</span> <span class="id">H4</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.  <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>. <span class="tactic">destruct</span> <span class="id">H4</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">scheduleMappingWitnessDestructOnCSeqEqual</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span> <span class="id">c</span>' : <span class="id">com</span>) (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) (<span class="id">CSeq</span> <span class="id">c</span>' <span class="id">w</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependenceSet</span> <span class="id">s</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof26')">Proof.</div>
<div class="proofscript" id="proof26">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;lengths&nbsp;equal&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;bijective&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="comment">(*&nbsp;range&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>. <span class="id">specialize</span> (<span class="id">H4</span> <span class="id">i</span>). <span class="tactic">destruct</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H5</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">omega</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> = <span class="id">comlen</span> <span class="id">c</span>'). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependenceSet</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
Abort.</div>
<br/>
&nbsp;&nbsp;<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">writesEqualDecidable</span>: <span class="kwd">forall</span> (<span class="id">w</span> <span class="id">w</span>': <span class="id">write</span>), <span class="id">w</span> = <span class="id">w</span>' \/ <span class="id">w</span> &lt;&gt; <span class="id">w</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>( <span class="id">n</span> = <span class="id">n0</span> \/ <span class="id">n</span> &lt;&gt; <span class="id">n0</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">z</span> = <span class="id">z0</span> \/ <span class="id">z</span> &lt;&gt; <span class="id">z0</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="tactic">congruence</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">congruence</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">NoAliasingBetweenSubprogramAndWrite</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">i</span>: <span class="id">nat</span>), <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">i</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">option_map</span> <span class="id">writeIx</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">i</span>) &lt;&gt; <span class="id">Some</span> <span class="id">wix</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">NoAliasingBetweenSubprogramAndWriteDestructOnCSeq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span> <span class="id">wixalias</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprogramAndWrite</span> (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) <span class="id">wixalias</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="id">c</span> <span class="id">wixalias</span> /\ <span class="id">wix</span> &lt;&gt; <span class="id">wixalias</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof27')">Proof.</div>
<div class="proofscript" id="proof27">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;No&nbsp;aliasing&nbsp;between&nbsp;c&nbsp;and&nbsp;wixalias&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprogramAndWrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> <span class="id">i</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">i</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span> ) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">commandIxInRangeInclusive</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;wix&nbsp;&lt;&gt;&nbsp;wixalias&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">comlen</span> <span class="id">c</span> + 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Some</span> <span class="id">wix</span> &lt;&gt; <span class="id">Some</span> <span class="id">wixalias</span> -&gt; <span class="id">wix</span> &lt;&gt; <span class="id">wixalias</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H1</span>. <span class="tactic">apply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Definition</span> <span class="id">NoAliasingBetweenSubprograms</span> (<span class="id">c1</span> <span class="id">c2</span>: <span class="id">com</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">i</span> <span class="id">j</span>: <span class="id">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">commandIxInRange</span> <span class="id">c1</span> <span class="id">i</span>-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">commandIxInRange</span> <span class="id">c2</span> <span class="id">j</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">option_map</span> <span class="id">writeIx</span> (<span class="id">getWriteAt</span>' <span class="id">c1</span> <span class="id">i</span>) &lt;&gt; <span class="id">option_map</span> <span class="id">writeIx</span> (<span class="id">getWriteAt</span>' <span class="id">c2</span> <span class="id">j</span>).<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">NoAliasingBetweenSubprogramsDestructOnCSeq</span>: <span class="kwd">forall</span> (<span class="id">c1</span> <span class="id">c2</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprograms</span> (<span class="id">CSeq</span> <span class="id">c1</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) <span class="id">c2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprograms</span> <span class="id">c1</span> <span class="id">c2</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="id">c2</span> <span class="id">wix</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<div class="toggleproof" onclick="toggleDisplay('proof28')">Proof.</div>
<div class="proofscript" id="proof28">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;No&nbsp;aliasing&nbsp;between&nbsp;subprograms&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprograms</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprograms</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> <span class="id">i</span> <span class="id">j</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c1</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) <span class="id">i</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">commandIxInRangeInclusive</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> <span class="id">H2</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">omega</span>.<br/>
&nbsp;No&nbsp;aliasing&nbsp;with&nbsp;write&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprogramAndWrite</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprograms</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">comlen</span> <span class="id">c1</span> + 1)).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c1</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) (<span class="id">comlen</span> <span class="id">c1</span> + 1)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> <span class="id">i</span> <span class="id">H0</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c1</span> + 1 =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c1</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">mem</span>: <span class="id">memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="id">c</span> <span class="id">wix</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">runProgram</span> <span class="id">c</span> <span class="id">mem</span>) <span class="id">wix</span> = <span class="id">mem</span> <span class="id">wix</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof29')">Proof.</div>
<div class="proofscript" id="proof29">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'. <span class="tactic">destruct</span> <span class="id">w</span> <span class="id">eqn</span>:<span class="id">wsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> = <span class="id">n</span> \/ <span class="id">wix</span> &lt;&gt; <span class="id">n</span>) <span class="kwd">as</span> <span class="id">wixcases</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">wixcases</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;wix&nbsp;=&nbsp;m,&nbsp;but&nbsp;this&nbsp;cannot&nbsp;be&nbsp;possible&nbsp;since&nbsp;the&nbsp;program&nbsp;does&nbsp;not&nbsp;alias&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> &lt;&gt; <span class="id">n</span>).<br/>
&nbsp;pick&nbsp;last&nbsp;instruction&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">comlen</span> <span class="id">c</span> + 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 &lt;= 1 + <span class="id">comlen</span> <span class="id">c</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 &gt;= 1). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;TODO:&nbsp;why&nbsp;do&nbsp;I&nbsp;need&nbsp;to&nbsp;prove&nbsp;this?!&nbsp;PROOF&nbsp;AUTOMATION.&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>).  <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Some</span> <span class="id">n</span> &lt;&gt; <span class="id">Some</span> <span class="id">wix</span> -&gt; <span class="id">wix</span> &lt;&gt; <span class="id">n</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H4</span>. <span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;wix&nbsp;&lt;&gt;&nbsp;m.&nbsp;We&nbsp;automatically&nbsp;use&nbsp;the&nbsp;written&nbsp;value&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> =? <span class="id">n</span> = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NoAliasingBetweenSubprogramAndWriteDestructOnCSeq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;runprogram&nbsp;of&nbsp;cbegin&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">NoAliasingBetweenSubprogramAndWriteAllowsReordering</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>)  (<span class="id">wval</span>: <span class="id">memvalue</span>) (<span class="id">mem</span>: <span class="id">memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="id">c</span> <span class="id">wix</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">runProgram</span> <span class="id">c</span> (<span class="id">writeToMemory</span>' (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>) <span class="id">mem</span>) =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">writeToMemory</span>' (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>) (<span class="id">runProgram</span> <span class="id">c</span> <span class="id">mem</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof30')">Proof.</div>
<div class="proofscript" id="proof30">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> = <span class="id">wix</span> \/ <span class="id">x</span> &lt;&gt; <span class="id">wix</span>) <span class="kwd">as</span> <span class="id">xcases</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">xcases</span>.<br/>
&nbsp;x&nbsp;=&nbsp;wix.&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> =? <span class="id">wix</span> = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="id">fold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="kwd">fun</span> <span class="id">ix</span> : <span class="id">memix</span> =&gt; <span class="kwd">if</span> <span class="id">ix</span> =? <span class="id">wix</span> <span class="kwd">then</span> <span class="id">wval</span> <span class="kwd">else</span> <span class="id">mem0</span> <span class="id">ix</span>) <span class="kwd">as</span> <span class="id">oldmem</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">runProgram</span> <span class="id">c</span> <span class="id">oldmem</span> <span class="id">x</span> = <span class="id">oldmem</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NoAliasingBetweenSubprogramAndWriteAllowsPunchthrough</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H0</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Heqoldmem</span>. <span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> =? <span class="id">wix</span> = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;x&nbsp;&lt;&gt;&nbsp;wix&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">wix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">wval</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">mem0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">readFromWriteDifferent</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">mem0</span> <span class="id">x</span> <span class="id">wval</span> <span class="id">wix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="id">eqn</span>:<span class="id">wsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">NoAliasingBetweenSubprogramAndWrite</span> <span class="id">c</span> <span class="id">wix</span> /\ <span class="id">n</span> &lt;&gt; <span class="id">wix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NoAliasingBetweenSubprogramAndWriteDestructOnCSeq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc</span> <span class="id">H2</span> <span class="id">H0</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>' <span class="kwd">in</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n</span> = <span class="id">x</span> \/ <span class="id">n</span> &lt;&gt; <span class="id">x</span>) <span class="kwd">as</span> <span class="id">mcases</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mcases</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;m&nbsp;=&nbsp;x&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> =? <span class="id">n</span> = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;m&nbsp;&lt;&gt;&nbsp;x&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">writeToMemory</span> <span class="id">n</span> <span class="id">z</span> (<span class="id">runProgram</span> <span class="id">c</span> <span class="id">mem0</span>) <span class="id">x</span> = <span class="id">runProgram</span> <span class="id">c</span> <span class="id">mem0</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>. <span class="tactic">assert</span> (<span class="id">x</span> =? <span class="id">n</span> = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">writeToMemory</span> <span class="id">n</span> <span class="id">z</span> (<span class="id">runProgram</span> <span class="id">c</span> (<span class="id">writeToMemory</span> <span class="id">wix</span> <span class="id">wval</span> <span class="id">mem0</span>)) <span class="id">x</span> = <span class="id">runProgram</span> <span class="id">c</span> <span class="id">mem0</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">setoid_rewrite</span> <span class="id">readFromWriteDifferent</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">setoid_rewrite</span> <span class="id">readFromWriteDifferent</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>. <span class="tactic">omega</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;CBegin&nbsp;case&nbsp;*)</span>&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">NoAliasingBetweenSubprogramsAllowsReordering</span>: <span class="kwd">forall</span> (<span class="id">c1</span> <span class="id">c2</span>: <span class="id">com</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">NoAliasingBetweenSubprograms</span> <span class="id">c1</span> <span class="id">c2</span> -&gt; <span class="id">c1</span> +++ <span class="id">c2</span> === <span class="id">c2</span> +++ <span class="id">c1</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof31')">Proof.</div>
<div class="proofscript" id="proof31">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">runprogram_distribute_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">runprogram_distribute_append</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">H</span>. <span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">initmemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">generalize</span> <span class="tactic">dependent</span> <span class="id">c2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c1</span>.<br/>
<br/>
&nbsp;Induction&nbsp;over&nbsp;c1&nbsp;*)</span>&nbsp;&nbsp;- <span class="comment">(*&nbsp;c1&nbsp;=&nbsp;seq&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">remember</span> <span class="id">H</span> <span class="kwd">as</span> <span class="id">H</span>'. <span class="tactic">clear</span> <span class="id">HeqH</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="id">eqn</span>:<span class="id">wsave</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NoAliasingBetweenSubprogramsDestructOnCSeq</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">IHc1</span> <span class="id">c2</span> <span class="id">initmemory</span> <span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">IHc1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">runProgram</span> <span class="id">c1</span> <span class="id">initmemory</span>) <span class="kwd">as</span> <span class="id">c1finalstate</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">NoAliasingBetweenSubprogramAndWriteAllowsReordering</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;CBegin&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">aliasingWriteTimepointsSet</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">ix</span>: <span class="id">memix</span>) (<span class="id">l</span>: <span class="id">list</span> <span class="id">timepoint</span>) : <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.NoDup</span> <span class="id">l</span> /\<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">t</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">List.In</span> <span class="id">t</span> <span class="id">l</span> -&gt; <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">t</span> /\ (<span class="id">exists</span> (<span class="id">wval</span>: <span class="id">memvalue</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">t</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">ix</span> <span class="id">wval</span>)).<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">list_length_1_implies_singleton</span>: <span class="kwd">forall</span> (<span class="id">a</span>: <span class="kwd">Type</span>) (<span class="id">l</span>: <span class="id">list</span> <span class="id">a</span>), <span class="id">length</span> <span class="id">l</span> = 1 -&gt; <span class="id">exists</span> (<span class="id">x</span>: <span class="id">a</span>), <span class="id">l</span> = <span class="id">List.cons</span> <span class="id">x</span> <span class="id">List.nil</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">a</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.length_zero_iff_nil</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">a0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">list_length_2_implies_2_elems</span>: <span class="kwd">forall</span> (<span class="id">a</span>: <span class="kwd">Type</span>) (<span class="id">l</span>: <span class="id">list</span> <span class="id">a</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">length</span> <span class="id">l</span> = 2 -&gt; <span class="id">exists</span> (<span class="id">x</span> <span class="id">x</span>': <span class="id">a</span>), <span class="id">l</span> = <span class="id">List.cons</span> <span class="id">x</span> (<span class="id">List.cons</span> <span class="id">x</span>' <span class="id">List.nil</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">a</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_length_1_implies_singleton</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">a0</span>. <span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">list_length_gt_2_implies_at_least_2_elems</span>: <span class="kwd">forall</span> (<span class="id">a</span>: <span class="kwd">Type</span>) (<span class="id">l</span>: <span class="id">list</span> <span class="id">a</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">length</span> <span class="id">l</span> &gt;= 2 -&gt; <span class="id">exists</span> (<span class="id">x</span> <span class="id">x</span>' : <span class="id">a</span>) (<span class="id">l</span>': <span class="id">list</span> <span class="id">a</span>), <span class="id">l</span> = <span class="id">List.cons</span> <span class="id">x</span> (<span class="id">List.cons</span> <span class="id">x</span>' <span class="id">l</span>').<br/>
<div class="toggleproof" onclick="toggleDisplay('proof32')">Proof.</div>
<div class="proofscript" id="proof32">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">a0</span>. <span class="id">exists</span> <span class="id">a1</span>. <span class="id">exists</span> <span class="id">l</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Fixpoint</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">ix</span>: <span class="id">memix</span>) : <span class="id">option</span> <span class="id">timepoint</span> :=<br/>
&nbsp;&nbsp;<span class="kwd">match</span> <span class="id">c</span> <span class="kwd">with</span><br/>
&nbsp;&nbsp;| <span class="id">CBegin</span> =&gt; <span class="id">None</span><br/>
&nbsp;&nbsp;| <span class="id">CSeq</span> <span class="id">c</span>' <span class="id">w</span> =&gt; <span class="kwd">if</span> <span class="id">writeIx</span> <span class="id">w</span> =? <span class="id">ix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">then</span> <span class="id">Some</span> (<span class="id">comlen</span> <span class="id">c</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">else</span>  <span class="id">getLatestAliasingWriteTimepointForProgram</span> <span class="id">c</span>' <span class="id">ix</span><br/>
&nbsp;&nbsp;<span class="kwd">end</span>.<br/>
<br/>
<span class="kwd">Definition</span> <span class="id">latestAliasingWriteTimepointSpec</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">ix</span>: <span class="id">memix</span>) (<span class="id">latest</span>: <span class="id">option</span> <span class="id">timepoint</span>): <span class="kwd">Prop</span> :=<br/>
&nbsp;&nbsp;(<span class="id">exists</span> (<span class="id">n</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">latest</span> = <span class="id">Some</span> <span class="id">n</span>) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">n</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">exists</span> (<span class="id">wval</span>: <span class="id">memvalue</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">n</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">ix</span> <span class="id">wval</span>)) /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">t</span>: <span class="id">timepoint</span>), <span class="id">t</span> &gt; <span class="id">n</span> -&gt; <span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">t</span> = <span class="id">Some</span> <span class="id">w</span> /\ <span class="id">writeIx</span> <span class="id">w</span> &lt;&gt; <span class="id">ix</span>) \/<br/>
&nbsp;&nbsp;(<span class="id">latest</span> = <span class="id">None</span> /\<br/>
&nbsp;&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">t</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">t</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">t</span> = <span class="id">Some</span> <span class="id">w</span> /\ <span class="id">writeIx</span> <span class="id">w</span> &lt;&gt; <span class="id">ix</span>).<br/>
<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="kwd">Theorem</span> <span class="id">emptyDependenceSetWillHaveSingleAliasingWrite</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">ix</span>: <span class="id">memix</span>) (<span class="id">lt</span>: <span class="id">list</span> <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">List.nil</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">aliasingWriteTimepointsSet</span> <span class="id">c</span> <span class="id">ix</span> <span class="id">lt</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">exists</span> (<span class="id">t</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">lt</span> = <span class="id">List.cons</span> <span class="id">t</span> <span class="id">List.nil</span>) \/ <span class="id">lt</span> = <span class="id">List.nil</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">aliasingWriteTimepointsSet</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">length</span> <span class="id">lt</span> &lt;= 1 \/ <span class="id">length</span> <span class="id">lt</span> &gt;= 2) <span class="kwd">as</span> <span class="id">lt_destruct</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">lt_destruct</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">length</span> <span class="id">lt</span> = 0 \/ <span class="id">length</span> <span class="id">lt</span> = 1) <span class="kwd">as</span> <span class="id">lt_0_or_1</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">lt_0_or_1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">lt</span> = <span class="id">List.nil</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">length_zero_iff_nil</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_length_1_implies_singleton</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">list_length_gt_2_implies_at_least_2_elems</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">List.In</span> <span class="id">x</span> <span class="id">lt</span>) <span class="kwd">as</span> <span class="id">x_in_lt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">apply</span> <span class="id">in_eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">List.In</span> <span class="id">x0</span> <span class="id">lt</span>) <span class="kwd">as</span> <span class="id">x0_in_lt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">List.In</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>. <span class="id">left</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">x</span> = <span class="id">x0</span> \/ <span class="id">x</span> &lt;&gt; <span class="id">x0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.NoDup_cons_iff</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">List.In</span> <span class="id">x0</span> (<span class="id">x0</span> :: <span class="id">x1</span>)). <span class="tactic">unfold</span> <span class="id">List.In</span>. <span class="id">left</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">x</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">wval</span>: <span class="id">memvalue</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">x</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">ix</span> <span class="id">wval</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">H3</span> <span class="id">x</span> <span class="id">x_in_lt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">x0</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">wval</span>: <span class="id">memvalue</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">x0</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">ix</span> <span class="id">wval</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">H3</span> <span class="id">x0</span> <span class="id">x0_in_lt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">w</span> <span class="id">w</span>': <span class="id">write</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">x</span> = <span class="id">Some</span> <span class="id">w</span> /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">x0</span> = <span class="id">Some</span> <span class="id">w</span>' /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">writeIx</span> <span class="id">w</span> &lt;&gt; <span class="id">writeIx</span> <span class="id">w</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">emptyDependenceSetImpliesNoAliasing</span>' <span class="id">_</span> <span class="id">_</span> <span class="id">_</span> <span class="id">H</span> <span class="id">H2</span> <span class="id">H4</span> <span class="id">H5</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H9</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H6</span> <span class="kwd">in</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H7</span> <span class="kwd">in</span> <span class="id">H9</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H9</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H11</span> <span class="kwd">in</span> <span class="id">H10</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H12</span> <span class="kwd">in</span> <span class="id">H10</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H10</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">contradiction</span>.<br/>
Qed.</div>
<br/>
&nbsp;&nbsp;<br/>
<span class="kwd">Definition</span> <span class="id">applyScheduleToDependenceSet</span> (<span class="id">s</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>) : <span class="id">dependenceset</span> :=<br/>
&nbsp;&nbsp;<span class="id">List.map</span> (<span class="id">applyScheduleToDependence</span> <span class="id">s</span>) <span class="id">ds</span>.<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">dependenceAliasesTransportAcrossValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">d</span>: <span class="id">dependence</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceAliases</span>' <span class="id">d</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceAliases</span>' (<span class="id">applyScheduleToDependence</span> <span class="id">s</span> <span class="id">d</span>) <span class="id">c</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof33')">Proof.</div>
<div class="proofscript" id="proof33">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span> <span class="id">eqn</span>:<span class="id">dsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">n</span>) <span class="kwd">as</span> <span class="id">w_c_at_n</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">n0</span>) <span class="kwd">as</span> <span class="id">w_c_at_n0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">n</span>)) <span class="kwd">as</span> <span class="id">w_c</span>'<span class="id">_at_sn</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">n0</span>)) <span class="kwd">as</span> <span class="id">w_c</span>'<span class="id">_at_sn0</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">n</span>) = <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">n</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">n</span> &gt;= 1 /\ <span class="id">n</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">as</span> <span class="id">n_inbounds</span>. <span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">n_inbounds</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>. <span class="tactic">destruct</span> <span class="id">H4</span>. <span class="tactic">destruct</span> <span class="id">H5</span>. <span class="tactic">intuition</span>. <br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">n0</span>) = <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">n0</span>). <span class="id">specialize</span> (<span class="id">H3</span> <span class="id">n0</span>). <span class="tactic">assert</span> (<span class="id">n0</span> &gt;= 1 /\ <span class="id">n0</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>). <span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">H5</span>). <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">subst</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>. <span class="tactic">rewrite</span> <span class="id">H5</span>. <span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">dependenceInRangeTransportAcrossValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">d</span>: <span class="id">dependence</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> (<span class="id">applyScheduleToDependence</span> <span class="id">s</span> <span class="id">d</span>) <span class="id">c</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof34')">Proof.</div>
<div class="proofscript" id="proof34">
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">applyScheduleToDependence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span> <span class="id">eqn</span>:<span class="id">dsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="id">specialize</span> (<span class="id">H4</span> <span class="id">n</span>). <span class="tactic">cut</span> (<span class="id">n</span> &gt;=1 /\ <span class="id">n</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>). <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H4</span> <span class="id">H3</span>). <span class="tactic">omega</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H4</span> <span class="id">n</span>). <span class="tactic">omega</span>. <span class="id">specialize</span> (<span class="id">H4</span> <span class="id">n0</span>). <span class="tactic">omega</span>. <span class="id">specialize</span> (<span class="id">H4</span> <span class="id">n0</span>). <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">dependenceLexPositiveTransportAcrossValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">s</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">d</span>: <span class="id">dependence</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependenceSet</span> <span class="id">s</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceLexPositive</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceAliases</span>' <span class="id">d</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceLexPositive</span> (<span class="id">applyScheduleToDependence</span> <span class="id">s</span> <span class="id">d</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof35')">Proof.</div>
<div class="proofscript" id="proof35">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H0</span> (<span class="id">n</span>, <span class="id">n0</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span>(<span class="id">List.In</span> (<span class="id">n</span>, <span class="id">n0</span>) <span class="id">ds</span>).<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>; <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependence</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">assumption</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">dependenceLexPositiveTransportAcrossValidSchedule</span>'':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">d</span>: <span class="id">dependence</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">ds</span> -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependenceSet</span> <span class="id">s</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceAliases</span>' <span class="id">d</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceInRange</span> <span class="id">d</span> <span class="id">c</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceLexPositive</span> <span class="id">d</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">dependenceLexPositive</span> (<span class="id">applyScheduleToDependence</span> <span class="id">s</span> <span class="id">d</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof36')">Proof.</div>
<div class="proofscript" id="proof36">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span> <span class="id">c</span>' <span class="id">s</span> <span class="id">sinv</span> <span class="id">d</span> <span class="id">ds</span> <span class="id">dscomplete</span> <span class="id">mapwitness</span> <span class="id">respectdeps</span> <span class="id">aliases</span> <span class="id">inrange</span> <span class="id">lexpos</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span> <span class="kwd">as</span> [<span class="id">tbegin</span> <span class="id">tend</span>] <span class="id">eqn</span>:<span class="id">dsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="kwd">as</span> [<span class="id">wix</span> <span class="id">wval</span>] <span class="id">eqn</span>:<span class="id">wsavee</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">s</span> <span class="id">tbegin</span> &lt; <span class="id">s</span> <span class="id">tend</span> \/ <span class="id">s</span> <span class="id">tbegin</span> = <span class="id">s</span> <span class="id">tend</span> \/ <span class="id">s</span> <span class="id">tbegin</span> &gt; <span class="id">s</span> <span class="id">tend</span>) <span class="kwd">as</span> <span class="id">tbegin_tend_cases</span>. <span class="tactic">omega</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tbegin_tend_cases</span> <span class="kwd">as</span> [<span class="id">tbegin_tend_lt</span> | <span class="id">tbegin_tend_eq_or_gt</span>].<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;s&nbsp;tbegin&nbsp;&lt;&nbsp;s&nbsp;tend&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;s&nbsp;tbegin&nbsp;=&nbsp;s&nbsp;tend.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&gt;&nbsp;tbegin&nbsp;=&nbsp;tend.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Will&nbsp;be&nbsp;contradiction,&nbsp;because&nbsp;there&nbsp;is&nbsp;a&nbsp;dependence&nbsp;(tbegin,&nbsp;tend)<br/>
&nbsp;&nbsp;&nbsp;*)</span> <br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tbegin_tend_eq_or_gt</span> <span class="kwd">as</span> [<span class="id">tbegin_tend_eq</span> | <span class="id">tbegin_tend_gt</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> = <span class="id">tend</span>) <span class="kwd">as</span> <span class="id">tbegin_eq_tend_by_s_bij</span>.<br/>
&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">sinv</span> (<span class="id">s</span> <span class="id">tbegin</span>) = <span class="id">sinv</span> (<span class="id">s</span> <span class="id">tend</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">mapwitness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">mapwitness</span> <span class="kwd">as</span> [<span class="id">_</span> [<span class="id">isinv</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">isinv</span>. <span class="tactic">destruct</span> <span class="id">isinv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> (<span class="id">H</span> <span class="id">tbegin</span>), (<span class="id">H</span> <span class="id">tend</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">tbegin_tend_eq</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">lexpos</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">lexpos</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> = <span class="id">tend</span> /\ <span class="id">tbegin</span> &lt; <span class="id">tend</span>). <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
<br/>
&nbsp;tbegin&nbsp;&gt;&nbsp;tend.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;*)</span>&nbsp;Since&nbsp;we&nbsp;have&nbsp;(tbegin,&nbsp;tend)&nbsp;as&nbsp;a&nbsp;dependence,&nbsp;transport&nbsp;it&nbsp;*)</span>&nbsp;This&nbsp;will&nbsp;give&nbsp;us&nbsp;(s&nbsp;tbegin,&nbsp;s&nbsp;tend)&nbsp;as&nbsp;a&nbsp;dependence&nbsp;*)</span>&nbsp;this&nbsp;contradicts&nbsp;s&nbsp;tbegin&nbsp;&gt;&nbsp;s&nbsp;tend&nbsp;since&nbsp;all&nbsp;dependences&nbsp;transported&nbsp;by&nbsp;"s"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are&nbsp;lex-positive&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependenceSet</span> <span class="kwd">in</span> <span class="id">respectdeps</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">scheduleRespectsDependence</span> <span class="id">s</span> (<span class="id">tbegin</span>, <span class="id">tend</span>)) <span class="kwd">as</span> <span class="id">tbegin_tend_respected_by_s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">respectdeps</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">dscomplete</span> (<span class="id">tbegin</span>, <span class="id">tend</span>)) <span class="kwd">as</span> [<span class="id">intoList</span> <span class="id">_</span>].<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">intoList</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">intoList</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependence</span> <span class="kwd">in</span> <span class="id">tbegin_tend_respected_by_s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">tbegin_tend_respected_by_s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">applyScheduleToDependence</span> <span class="kwd">in</span> <span class="id">tbegin_tend_respected_by_s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">tbegin_tend_respected_by_s</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">s</span> <span class="id">tbegin</span> &gt; <span class="id">s</span> <span class="id">tend</span> /\ <span class="id">s</span> <span class="id">tbegin</span> &lt; <span class="id">s</span> <span class="id">tend</span>) <span class="kwd">as</span> <span class="id">contra</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;CBegin&nbsp;cannot&nbsp;have&nbsp;a&nbsp;dependence&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>  <span class="kwd">as</span> [<span class="id">tbegin</span> <span class="id">tend</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependenceSet</span> <span class="kwd">in</span> <span class="id">respectdeps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span> <span class="kwd">in</span> <span class="id">inrange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">inrange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">inrange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">is_inverse_injective</span>: <span class="kwd">forall</span> (<span class="id">A</span> <span class="id">B</span>:<span class="kwd">Set</span>) (<span class="id">f</span>: <span class="id">A</span> -&gt; <span class="id">B</span>) (<span class="id">g</span>: <span class="id">B</span> -&gt; <span class="id">A</span>) (<span class="id">a</span> <span class="id">b</span>: <span class="id">A</span>), <span class="id">is_inverse</span> <span class="id">f</span> <span class="id">g</span> -&gt; <span class="id">f</span> <span class="id">a</span> = <span class="id">f</span> <span class="id">b</span> -&gt; <span class="id">a</span> = <span class="id">b</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof37')">Proof.</div>
<div class="proofscript" id="proof37">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">g</span> (<span class="id">f</span> <span class="id">a</span>) = <span class="id">g</span> (<span class="id">f</span> <span class="id">b</span>)) <span class="kwd">as</span> <span class="id">gcall</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">a</span> = <span class="id">g</span> (<span class="id">f</span> <span class="id">a</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">b</span> = <span class="id">g</span> (<span class="id">f</span> <span class="id">b</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">rewrite</span> <span class="id">H3</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>. <span class="tactic">intuition</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">is_inverse_symmetric</span>: <span class="kwd">forall</span> (<span class="id">A</span> <span class="id">B</span>:<span class="kwd">Set</span>) (<span class="id">f</span>: <span class="id">A</span> -&gt; <span class="id">B</span>) (<span class="id">g</span>: <span class="id">B</span> -&gt; <span class="id">A</span>), <span class="id">is_inverse</span> <span class="id">f</span> <span class="id">g</span> -&gt; <span class="id">is_inverse</span> <span class="id">g</span> <span class="id">f</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof38')">Proof.</div>
<div class="proofscript" id="proof38">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
Qed.</div>
<span class="kwd">Theorem</span> <span class="id">dependenceSetTransportAcrossValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependenceSet</span> <span class="id">s</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span>' (<span class="id">applyScheduleToDependenceSet</span> <span class="id">s</span> <span class="id">ds</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof39')">Proof.</div>
<div class="proofscript" id="proof39">
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">scheduleMappingWitness</span> <span class="id">sinv</span> <span class="id">s</span> <span class="id">c</span>' <span class="id">c</span>) <span class="kwd">as</span> <span class="id">witness_inv</span>. <span class="tactic">apply</span> <span class="id">scheduleMappingWitnessSymmetric</span>. <span class="tactic">intuition</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">d</span>'.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">valid_dep_d</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span> <span class="kwd">in</span> <span class="id">valid_dep_d</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">valid_dep_d</span>' <span class="kwd">as</span> [<span class="id">aliases_d</span>' [<span class="id">inrange_d</span>' <span class="id">lexpos_d</span>']].<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">applyScheduleToDependenceSet</span>. <span class="tactic">unfold</span> <span class="id">applyScheduleToDependence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_map_iff</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">applyScheduleToDependence</span> <span class="id">sinv</span> <span class="id">d</span>').<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">applyScheduleToDependence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="kwd">forall</span> (<span class="id">n</span>: <span class="id">nat</span>), <span class="id">s</span> (<span class="id">sinv</span> <span class="id">n</span>) = <span class="id">n</span>). <span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">intuition</span>. <span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">H0</span>. <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceAliasesTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness_inv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceInRangeTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness_inv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">dependenceAliases</span>' (<span class="id">applyScheduleToDependence</span> <span class="id">sinv</span> <span class="id">d</span>') <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceAliasesTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness_inv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>' <span class="kwd">as</span> [<span class="id">tbegin</span> <span class="id">tend</span>] <span class="id">eqn</span>:<span class="id">dsave</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">sinv</span> <span class="id">tbegin</span> &lt; <span class="id">sinv</span> <span class="id">tend</span> \/ <span class="id">sinv</span> <span class="id">tbegin</span> = <span class="id">sinv</span> <span class="id">tend</span> \/ <span class="id">sinv</span> <span class="id">tbegin</span> &gt; <span class="id">sinv</span> <span class="id">tend</span>) <span class="kwd">as</span> <span class="id">cases</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">cases</span> <span class="kwd">as</span> [<span class="id">lt</span> | <span class="id">eq_or_gt</span>].<br/>
&nbsp;lt&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span>, <span class="id">applyScheduleToDependence</span>.<br/>
&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">eq_or_gt</span> <span class="kwd">as</span> [<span class="id">eq</span> | <span class="id">gt</span>].<br/>
&nbsp;eq&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> = <span class="id">tend</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_inverse_injective</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">witness_inv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">witness_inv</span> <span class="kwd">as</span> [<span class="id">_</span> [<span class="id">inv</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">inv</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">lexpos_d</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tbegin</span> &lt; <span class="id">tend</span> /\ <span class="id">tbegin</span> = <span class="id">tend</span>) <span class="kwd">as</span> <span class="id">contradict</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;gt&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">List.In</span> (<span class="id">applyScheduleToDependence</span> <span class="id">sinv</span> (<span class="id">tend</span>, <span class="id">tbegin</span>)) <span class="id">ds</span>) <span class="kwd">as</span> <span class="id">wrong_dep</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;show&nbsp;that&nbsp;we&nbsp;get&nbsp;aliases&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceAliasesTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness_inv</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">dependenceAliases</span>'<span class="id">Symmetric</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">dependenceInRangeSymmetric</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceInRangeTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness_inv</span>. <span class="tactic">rewrite</span> <span class="id">dependenceInRangeSymmetric</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span>. <span class="tactic">simpl</span>. <span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;Now&nbsp;that&nbsp;we&nbsp;have&nbsp;wrong_dep,&nbsp;show&nbsp;that&nbsp;it&nbsp;will&nbsp;be&nbsp;preserved&nbsp;lex.&nbsp;This&nbsp;will&nbsp;violate&nbsp;our&nbsp;assumption&nbsp;that&nbsp;sinv&nbsp;(tbegin,&nbsp;tend)&nbsp;is&nbsp;a&nbsp;dependence&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tend</span> &lt; <span class="id">tbegin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependenceSet</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">_</span> <span class="id">wrong_dep</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleRespectsDependence</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">witness_inv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">witness_inv</span> <span class="kwd">as</span> [<span class="id">_</span> [<span class="id">inv</span> <span class="id">_</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">inv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">inv</span> <span class="kwd">as</span> [<span class="id">inv_s</span> <span class="id">inv_sinv</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">s</span> (<span class="id">sinv</span> <span class="id">tend</span>) = <span class="id">tend</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">s</span> (<span class="id">sinv</span> <span class="id">tbegin</span>) = <span class="id">tbegin</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">tend_inv</span> <span class="id">tbegin_inv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">tend_inv</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">tbegin_inv</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tend</span> &lt; <span class="id">tbegin</span> /\ <span class="id">tbegin</span> &lt; <span class="id">tend</span>) <span class="kwd">as</span> <span class="id">contra</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">lexpos_d</span>'. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">lexpos_d</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;blow&nbsp;this&nbsp;up&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;+ <span class="tactic">intros</span> <span class="id">d</span>'<span class="id">_in_transport_ds</span>.<br/>
&nbsp;other&nbsp;direction:&nbsp;we&nbsp;know&nbsp;that&nbsp;we&nbsp;hve&nbsp;a&nbsp;dependence&nbsp;d',&nbsp;we&nbsp;need&nbsp;to&nbsp;show&nbsp;it's&nbsp;fine&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">applyScheduleToDependenceSet</span>  <span class="kwd">in</span> <span class="id">d</span>'<span class="id">_in_transport_ds</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_map_iff</span> <span class="kwd">in</span> <span class="id">d</span>'<span class="id">_in_transport_ds</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d</span>'<span class="id">_in_transport_ds</span> <span class="kwd">as</span> [<span class="id">d</span> [<span class="id">d</span>'<span class="id">_from_d</span> <span class="id">d_in_ds</span>]].<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">remember</span> <span class="id">H</span> <span class="kwd">as</span> <span class="id">completedepset</span>. <span class="tactic">clear</span> <span class="id">Heqcompletedepset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> <span class="id">d</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">_</span> <span class="id">memberProps</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">memberProps</span> <span class="id">d_in_ds</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span> <span class="kwd">in</span> <span class="id">memberProps</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">d</span>'<span class="id">_from_d</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceAliasesTransportAcrossValidSchedule</span>; <span class="tactic">try</span> <span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceInRangeTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>. <span class="tactic">intuition</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">dependenceLexPositiveTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">completedepset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Lemma</span> <span class="id">completeDependenceSetConsDestructOnCSeq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">wix</span>: <span class="id">memix</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tbegin</span> <span class="id">tend</span>: <span class="id">timepoint</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) ((<span class="id">tbegin</span>, <span class="id">tend</span>) :: <span class="id">ds</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tend</span> = <span class="id">comlen</span> <span class="id">c</span> + 1 /\<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">exists</span> (<span class="id">wval</span>': <span class="id">memvalue</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tbegin</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>'))) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">tend</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span> + 1).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof40')">Proof.</div>
<div class="proofscript" id="proof40">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span> <span class="id">wix</span> <span class="id">wval</span> <span class="id">tbegin</span> <span class="id">tend</span> <span class="id">ds</span> <span class="id">completedepset</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tend</span> = <span class="id">comlen</span> <span class="id">c</span> + 1 \/ <span class="id">tend</span> &lt;= <span class="id">comlen</span> <span class="id">c</span> \/ <span class="id">tend</span> &gt; <span class="id">comlen</span> <span class="id">c</span> + 1) <span class="kwd">as</span> <span class="id">tend_cases</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tend_cases</span> <span class="kwd">as</span> [<span class="id">tend_at_end</span>| <span class="id">tend_not_at_end</span>].<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;tend&nbsp;=&nbsp;comlen&nbsp;c&nbsp;+&nbsp;1&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">try</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">completedepset</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">completedepset</span> (<span class="id">tbegin</span>, <span class="id">tend</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">completedepset</span> <span class="kwd">as</span> [<span class="id">_</span> <span class="id">inListValid</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">validDependence</span> (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) (<span class="id">tbegin</span>, <span class="id">tend</span>)) <span class="kwd">as</span> <span class="id">d_is_valid</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inListValid</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">List.In</span>. <span class="id">left</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span> <span class="kwd">in</span> <span class="id">d_is_valid</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d_is_valid</span> <span class="kwd">as</span> [<span class="id">d_aliases</span> [<span class="id">d_in_range</span> <span class="id">d_lexpos</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">w</span>:<span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tbegin</span> = <span class="id">Some</span> <span class="id">w</span>) <span class="kwd">as</span> <span class="id">exists_w_tbegin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeComplete</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>,<span class="id">commandIxInRange</span>, <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">d_in_range</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">d_in_range</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">d_in_range</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">d_in_range</span> <span class="kwd">as</span> [<span class="id">tbegin_range</span> <span class="id">tend_range</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">d_lexpos</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">d_lexpos</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">exists_w_tbegin</span> <span class="kwd">as</span> [<span class="id">w_tbegin</span> <span class="id">w_tbegin_witness</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w_tbegin</span> <span class="kwd">as</span> [<span class="id">w_tbegin_ix</span> <span class="id">w_tbegin_val</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">w_tbegin_val</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>' <span class="kwd">in</span> <span class="id">d_aliases</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">d_aliases</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">tbegin</span> =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">tend</span> =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">if1</span> <span class="id">if2</span>. <span class="tactic">rewrite</span> <span class="id">if1</span>, <span class="id">if2</span> <span class="kwd">in</span> <span class="id">d_aliases</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">d_aliases</span> <span class="kwd">as</span> [<span class="id">wix_eq_witness</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">w_tbegin_witness</span> <span class="kwd">in</span> <span class="id">wix_eq_witness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">wix_eq_witness</span>. <span class="tactic">inversion</span> <span class="id">wix_eq_witness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">w_tbegin_witness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">unfold</span> <span class="id">dependenceInRange</span>, <span class="id">commandIxInRange</span>, <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">d_in_range</span>, <span class="id">d_lexpos</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">d_in_range</span>,<span class="id">d_lexpos</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">unfold</span> <span class="id">dependenceInRange</span>, <span class="id">commandIxInRange</span>, <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">d_in_range</span>, <span class="id">d_lexpos</span>. <span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">d_in_range</span>,<span class="id">d_lexpos</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;-  <span class="tactic">intros</span>. <span class="id">right</span>. <span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Lemma</span> <span class="id">latestAliasingWriteTimepointSpecDestructOnCSeq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">latestw</span>: <span class="id">write</span>) (<span class="id">readix</span>: <span class="id">memix</span>) (<span class="id">latest_aliasingt</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">latestw</span>) <span class="id">readix</span> (<span class="id">Some</span> <span class="id">latest_aliasingt</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latest_aliasingt</span> &lt;&gt; <span class="id">comlen</span> <span class="id">c</span> + 1 -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> (<span class="id">Some</span> <span class="id">latest_aliasingt</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof41')">Proof.</div>
<div class="proofscript" id="proof41">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">latest_aliasingt</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">split</span>; <span class="tactic">try</span> <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;commandIxInRange&nbsp;c&nbsp;x&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> *. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> *. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span> <span class="kwd">as</span> [<span class="id">wval</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">wval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">getWriteAt</span>' (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">latestw</span>) <span class="id">x</span> = <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">write_at_destruct</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">write_at_destruct</span>. <span class="tactic">rewrite</span> <span class="id">H2</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H5</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">t0</span> <span class="id">H4</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">latestw</span>) <span class="id">t0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t0_in_range_cseq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">t0_in_range_cseq</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span> <span class="kwd">as</span> [<span class="id">write_at_t0</span> <span class="id">write_at_t0_witness</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">write_at_t0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">write_at_t0_witness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">latestw</span>) <span class="id">t0</span> = <span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">t0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H6</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">exact</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">commandIxInRangeInclusive</span>. <span class="tactic">exact</span> <span class="id">H6</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">noLatestAliasingWriteDestructOnCSeq</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">w</span>: <span class="id">write</span>) (<span class="id">readix</span>: <span class="id">memix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">readix</span> <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> <span class="id">None</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof42')">Proof.</div>
<div class="proofscript" id="proof42">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span> <span class="id">w</span> <span class="id">readix</span> <span class="id">witness_on_cseq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span>.<br/>
&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t_check</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t_check_in_c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">t_check</span>) <span class="kwd">as</span> <span class="id">t_check_in_cseq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">commandIxInRangeInclusive</span>. <span class="tactic">exact</span> <span class="id">t_check_in_c</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">t_check</span> = <span class="id">getWriteAt</span>' (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">t_check</span>) <span class="kwd">as</span> <span class="id">write_inclusive</span>.<br/>
&nbsp;&nbsp;<span class="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">t_check_in_c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">w_t</span> : <span class="id">write</span>), <span class="id">getWriteAt</span>' (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">t_check</span> = <span class="id">Some</span> <span class="id">w_t</span>) <span class="kwd">as</span> <span class="id">w_at_tcheck_in_cseq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> (<span class="id">getWriteAt</span>'<span class="id">RangeComplete</span> (<span class="id">CSeq</span> <span class="id">c</span> <span class="id">w</span>) <span class="id">t_check</span>).<br/>
&nbsp;TODO:&nbsp;an&nbsp;"auto"&nbsp;should&nbsp;suffice&nbsp;after&nbsp;this&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">t_check_in_c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w_at_tcheck_in_cseq</span> <span class="kwd">as</span> [<span class="id">w_at_tcheck</span>  <span class="id">w_at_tcheck_witness</span>].<br/>
&nbsp;&nbsp;<span class="id">exists</span> <span class="id">w_at_tcheck</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">write_inclusive</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">w_at_tcheck_witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">witness_on_cseq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">witness_on_cseq</span> <span class="kwd">as</span> [<span class="id">contra</span> | <span class="id">usefulcase</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">contra</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">usefulcase</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">writeIx</span> <span class="id">w_at_tcheck</span> &lt;&gt; <span class="id">readix</span>) <span class="kwd">as</span> <span class="id">goal</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H0</span> <span class="id">t_check</span>).<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H0</span> <span class="id">t_check_in_cseq</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">w_at_tcheck</span> = <span class="id">x</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> <span class="id">w_at_tcheck_witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">w_at_tcheck_witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">goal</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">noLatestAliasingWriteAllowsPunchthrough</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">readix</span>: <span class="id">memix</span>)  (<span class="id">initmem</span>: <span class="id">memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> <span class="id">None</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">runProgram</span> <span class="id">c</span> <span class="id">initmem</span> <span class="id">readix</span> = (<span class="id">initmem</span> <span class="id">readix</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof43')">Proof.</div>
<div class="proofscript" id="proof43">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>. <span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">readix</span> <span class="id">initmem</span> <span class="id">no_aliasing_tp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> <span class="id">None</span>) <span class="kwd">as</span> <span class="id">destruct_H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">noLatestAliasingWriteDestructOnCSeq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">no_aliasing_tp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="kwd">as</span> [<span class="id">wix</span> <span class="id">wval</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> = <span class="id">readix</span> \/ <span class="id">wix</span> &lt;&gt; <span class="id">readix</span>) <span class="kwd">as</span> <span class="id">wix_cases</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">wix_cases</span> <span class="kwd">as</span> [<span class="id">wix_eq_readix</span> | <span class="id">wix_neq_readix</span>].<br/>
&nbsp;wix&nbsp;=&nbsp;readix&nbsp;*)</span>&nbsp;I&nbsp;can&nbsp;create&nbsp;a&nbsp;contradiction&nbsp;because&nbsp;now&nbsp;the&nbsp;write&nbsp;aliases&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> &lt;&gt; <span class="id">readix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">no_aliasing_tp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">no_aliasing_tp</span> <span class="kwd">as</span> [<span class="id">contra</span> | <span class="id">useful</span>].<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">contra</span>. <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">useful</span>. <span class="id">specialize</span> (<span class="id">H0</span> (<span class="id">comlen</span> <span class="id">c</span> + 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>)) (<span class="id">comlen</span> <span class="id">c</span> + 1)) <span class="kwd">as</span> <span class="id">inrange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>, <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H0</span> <span class="id">inrange</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>) <span class="kwd">as</span> <span class="id">eq_dumb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">eq_dumb</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">eq_dumb</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">x</span> <span class="kwd">as</span> [<span class="id">xix</span> <span class="id">xval</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">exact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;+  <span class="tactic">assert</span> (<span class="id">wix</span> = <span class="id">readix</span> /\ <span class="id">wix</span> &lt;&gt; <span class="id">readix</span>) <span class="kwd">as</span> <span class="id">absurd</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;wix&nbsp;=&nbsp;readix&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">readFromWriteDifferent</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">destruct_H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;+ <span class="comment">(*&nbsp;CBegin&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="tactic">auto</span>.<br/>
Qed.</div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">latestAliasingWriteWillBeValue</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">readix</span>: <span class="id">memix</span>) (<span class="id">aliasingt</span>: <span class="id">timepoint</span>) (<span class="id">wval</span>: <span class="id">memvalue</span>) (<span class="id">initmem</span>: <span class="id">memory</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> (<span class="id">Some</span> <span class="id">aliasingt</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getWriteAt</span>' <span class="id">c</span>  <span class="id">aliasingt</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">readix</span> <span class="id">wval</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">runProgram</span> <span class="id">c</span> <span class="id">initmem</span> <span class="id">readix</span> = <span class="id">wval</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof44')">Proof.</div>
<div class="proofscript" id="proof44">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span> <span class="id">readix</span> <span class="id">aliasingt</span> <span class="id">wval</span> <span class="id">initmem</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">tpspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;CSeq&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">aliasingt</span> = <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>) \/ <span class="id">aliasingt</span> &lt; <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">aliasingt_at_end</span> | <span class="id">aliasingt_before_end</span>].<br/>
&nbsp;aliasingt&nbsp;=&nbsp;S&nbsp;(comlen&nbsp;C)&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">rewrite</span> <span class="id">aliasingt_at_end</span> <span class="kwd">in</span> *. <span class="tactic">clear</span> <span class="id">aliasingt_at_end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">w</span> = <span class="id">Write</span> <span class="id">readix</span> <span class="id">wval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) =? 1 + <span class="id">comlen</span> <span class="id">c</span> = <span class="id">true</span>) <span class="kwd">as</span> <span class="id">comlen_c_p_1_equiv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">comlen_c_p_1_equiv</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">readFromWriteIdentical</span>.<br/>
<br/>
&nbsp;aliasingt&nbsp;&lt;&nbsp;S&nbsp;(comlen&nbsp;C)&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="kwd">as</span> [<span class="id">finalwix</span> <span class="id">finalwval</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">finalwix</span> &lt;&gt; <span class="id">readix</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">assert</span> (<span class="id">finalwix</span> &lt;&gt; <span class="id">readix</span> \/ <span class="id">finalwix</span> = <span class="id">readix</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;derive&nbsp;contradition&nbsp;from&nbsp;finalwix&nbsp;=&nbsp;readix&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">tpspec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tpspec</span>.<br/>
&nbsp;Some&nbsp;tp&nbsp;exists&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H0</span>. <span class="tactic">rewrite</span> &lt;- <span class="id">H3</span> <span class="kwd">in</span> *. <span class="tactic">clear</span> <span class="id">H3</span>. <span class="tactic">clear</span> <span class="id">H0</span>. <span class="tactic">clear</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H2</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) &gt; <span class="id">aliasingt</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H2</span> <span class="id">H3</span>). <span class="tactic">clear</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">finalwix</span> <span class="id">finalwval</span>)) (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H2</span> <span class="id">H3</span>). <span class="tactic">clear</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) =? <span class="id">comlen</span> (<span class="id">CSeq</span> <span class="id">c</span> (<span class="id">Write</span> <span class="id">finalwix</span> <span class="id">finalwval</span>)) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span> <span class="kwd">in</span> <span class="id">H2</span>. <span class="tactic">clear</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H5</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">H5</span>. <span class="tactic">clear</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;contradiction,&nbsp;baby&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">finalwix</span> &lt;&gt; <span class="id">readix</span> /\ <span class="id">finalwix</span> = <span class="id">readix</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;Some&nbsp;tp&nbsp;=&nbsp;None&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">inversion</span> <span class="id">H0</span>.<br/>
<br/>
&nbsp;aliasingt&nbsp;&lt;&nbsp;S&nbsp;(comlen&nbsp;C)&nbsp;\/&nbsp;finalwix&nbsp;&lt;&gt;&nbsp;read&nbsp;ix&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">intros</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">aliasingt</span> = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">readix</span> <span class="id">wval</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">DestructOnCSeq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span> <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">runProgram</span>. <span class="id">fold</span> <span class="id">runProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">writeToMemory</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">readFromWriteDifferent</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">IHc</span>.<br/>
<br/>
&nbsp;we&nbsp;need&nbsp;to&nbsp;show&nbsp;that&nbsp;latestAliasingWriteTimepointSpec<br/>
can&nbsp;be&nbsp;destructed&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">latestAliasingWriteTimepointSpecDestructOnCSeq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">tpspec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;CBegin&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getWriteAt</span>' <span class="kwd">in</span> <span class="id">aliasingtwrite</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">aliasingtwrite</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">noLatestAliasingWriteTimepointTransportAcrossValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">readix</span>: <span class="id">memix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> <span class="id">None</span> -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span>' <span class="id">readix</span> <span class="id">None</span>.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof45')">Proof.</div>
<div class="proofscript" id="proof45">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' <span class="id">readix</span> <span class="id">schedwitness</span> <span class="id">tpwitness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tpwitness</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;useless&nbsp;case,&nbsp;Some&nbsp;n&nbsp;=&nbsp;None&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;useful&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>. <span class="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t0_in_range</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H0</span> (<span class="id">sinv</span> <span class="id">t0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> <span class="id">c</span> (<span class="id">sinv</span> <span class="id">t0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">schedwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">schedwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">t0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span> <span class="kwd">in</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">t0</span> &gt;= 1 /\ <span class="id">t0</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>'). <span class="tactic">intros</span> <span class="id">t0_in_range_c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">t0_in_range_c</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H0</span> <span class="id">H1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">w_at_sinv_t0</span> <span class="id">witness_w_at_sinv_t0</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">w_at_sinv_t0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' <span class="id">t0</span> = <span class="id">getWriteAt</span>' <span class="id">c</span> (<span class="id">sinv</span> <span class="id">t0</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">schedwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">schedwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">t0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">t0</span> &gt;= 1 /\ <span class="id">t0</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">as</span> <span class="id">t0_range</span>. <span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">t0_in_range</span>. <span class="tactic">rewrite</span> <span class="id">H0</span> <span class="kwd">in</span> *. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">t0_range</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">commandIxInRangeTransportAlongValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">tp</span>: <span class="id">timepoint</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">tp</span> &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">commandIxInRange</span> <span class="id">c</span>' (<span class="id">s</span> <span class="id">tp</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof46')">Proof.</div>
<div class="proofscript" id="proof46">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' <span class="id">tp</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;-&gt;&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">tp_inrange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="id">specialize</span> (<span class="id">H1</span> <span class="id">tp</span>).<br/>
&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">tp</span> &gt;= 1 /\ <span class="id">tp</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">tp_inrange</span>'.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">tp_inrange</span>').<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>. <span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">stp_inrange</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> (<span class="id">s</span> <span class="id">tp</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">sinv</span> (<span class="id">s</span> <span class="id">tp</span>) = <span class="id">tp</span>).<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H2</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">getWriteAt</span>'<span class="id">TransportAlongValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">tp</span>: <span class="id">timepoint</span>) (<span class="id">w</span>: <span class="id">write</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tp</span> = <span class="id">Some</span> <span class="id">w</span> &lt;-&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">tp</span>) = <span class="id">Some</span> <span class="id">w</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof47')">Proof.</div>
<div class="proofscript" id="proof47">
<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>. <span class="id">specialize</span> (<span class="id">H1</span> <span class="id">tp</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tp</span> &gt;= 1 /\ <span class="id">tp</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">H2</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
&nbsp;&lt;-&nbsp;*)</span>&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H2</span> (<span class="id">s</span> <span class="id">tp</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">s</span> <span class="id">tp</span> &gt;= 1 /\ <span class="id">s</span> <span class="id">tp</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>').<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H2</span> <span class="id">H3</span>).<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H6</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tp</span> = <span class="id">getWriteAt</span>' <span class="id">c</span> (<span class="id">sinv</span> (<span class="id">s</span> <span class="id">tp</span>))).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H8</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">tp</span>).<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
Qed.</div>
<br/>
<span class="kwd">Theorem</span> <span class="id">is_inverse_cancellation</span>: <span class="kwd">forall</span> (<span class="id">A</span>: <span class="kwd">Set</span>) (<span class="id">s</span> <span class="id">s</span>': <span class="id">A</span> -&gt; <span class="id">A</span>) (<span class="id">a</span>: <span class="id">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">is_inverse</span> <span class="id">s</span> <span class="id">s</span>' -&gt; ((<span class="id">s</span> (<span class="id">s</span>' <span class="id">a</span>)) = <span class="id">a</span>).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof48')">Proof.</div>
<div class="proofscript" id="proof48">
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">is_inverse</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H0</span>.<br/>
Qed.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">latestAliasingWriteTimepointSpecTransportAcrossValidSchedule</span>:<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">ds</span>: <span class="id">dependenceset</span>)  (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">latest_tp</span>: <span class="id">timepoint</span>) (<span class="id">readix</span>: <span class="id">memix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">ds</span> -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependenceSet</span> <span class="id">s</span> <span class="id">ds</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> (<span class="id">Some</span> <span class="id">latest_tp</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span>' <span class="id">readix</span> (<span class="id">Some</span> (<span class="id">s</span> <span class="id">latest_tp</span>)).<br/>
<div class="toggleproof" onclick="toggleDisplay('proof49')">Proof.</div>
<div class="proofscript" id="proof49">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">ds</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' <span class="id">latest_tp</span> <span class="id">readix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> <span class="id">H2</span> <span class="kwd">as</span> <span class="id">H2</span>'. <span class="tactic">clear</span> <span class="id">HeqH2</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;Some&nbsp;case&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>. <span class="comment">(*&nbsp;Some&nbsp;timepoint&nbsp;exists&nbsp;in&nbsp;goal&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H5</span> <span class="kwd">in</span> *. <span class="tactic">clear</span> <span class="id">H5</span>. <span class="tactic">clear</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">scheduleMappingWitness</span> <span class="id">sinv</span> <span class="id">s</span> <span class="id">c</span>' <span class="id">c</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">scheduleMappingWitnessSymmetric</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">is_inverse</span> <span class="id">sinv</span> <span class="id">s</span>) <span class="kwd">as</span> <span class="id">inv_sinv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span>. <span class="tactic">destruct</span> <span class="id">H6</span>. <span class="tactic">apply</span> <span class="id">is_inverse_symmetric</span>. <span class="tactic">assumption</span>.<br/>
<br/>
&nbsp;--&nbsp;cleanup&nbsp;up&nbsp;hypotheis,&nbsp;proceed&nbsp;with&nbsp;goal&nbsp;--*)</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">s</span> <span class="id">latest_tp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">eapply</span> <span class="id">commandIxInRangeTransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">is_inverse_cancellation</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">inv_sinv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="tactic">destruct</span> <span class="id">H3</span> <span class="kwd">as</span> [<span class="id">wval</span> <span class="id">c_latest_tp</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">wval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">TransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">c_latest_tp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">inv_sinv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**  <span class="tactic">intros</span> <span class="id">t</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t</span>'<span class="id">_gt_s_latest_tp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">t</span>'<span class="id">_in_range</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">exists</span> (<span class="id">w</span>: <span class="id">write</span>), <span class="id">getWriteAt</span>' <span class="id">c</span>' <span class="id">t</span>' = <span class="id">Some</span> <span class="id">w</span>) <span class="kwd">as</span> <span class="id">existence_of_write_at_t</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeComplete</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">t</span>'<span class="id">_in_range</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">existence_of_write_at_t</span>' <span class="kwd">as</span> [<span class="id">w_at_t</span>' <span class="id">witness_w_at_t</span>'].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">w_at_t</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;***  <span class="tactic">rewrite</span> <span class="id">witness_w_at_t</span>'. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*** <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">writeIx</span> <span class="id">w_at_t</span>' = <span class="id">readix</span> \/ <span class="id">writeIx</span> <span class="id">w_at_t</span>' &lt;&gt; <span class="id">readix</span>) <span class="kwd">as</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">writeIx_w_at_t</span>'<span class="id">_cases</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">writeIx_w_at_t</span>'<span class="id">_cases</span> <span class="kwd">as</span> [<span class="id">writeIx_eq</span> | <span class="id">writeIx_neq</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**** <span class="comment">(*&nbsp;writeIX&nbsp;w_at_t'&nbsp;=&nbsp;readix.&nbsp;Derive&nbsp;contradiction&nbsp;since&nbsp;this&nbsp;will&nbsp;give&nbsp;us&nbsp;a&nbsp;dependence&nbsp;that&nbsp;is&nbsp;not&nbsp;supposed&nbsp;to&nbsp;exist&nbsp;*)</span><br/>
&nbsp;TODO,&nbsp;NOTE:&nbsp;Note&nbsp;that&nbsp;I&nbsp;don't&nbsp;actually&nbsp;derive&nbsp;a&nbsp;contradiction,&nbsp;sow&nbsp;what's&nbsp;going&nbsp;on?&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">dependenceLexPositive</span> (<span class="id">s</span> <span class="id">latest_tp</span>, <span class="id">t</span>')) <span class="kwd">as</span> <span class="id">lexpos</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span>. <span class="tactic">simpl</span>. <span class="tactic">omega</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">dependenceAliases</span>' (<span class="id">s</span> <span class="id">latest_tp</span>, <span class="id">t</span>') <span class="id">c</span>') <span class="kwd">as</span> <span class="id">aliases</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceAliases</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">witness_w_at_t</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">option_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">writeIx_eq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H3</span> <span class="kwd">as</span> [<span class="id">w_latest_tp</span> <span class="id">w_latest_tp_witness</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">latest_tp</span>) = <span class="id">Some</span> (<span class="id">Write</span> <span class="id">readix</span> <span class="id">w_latest_tp</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">TransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">w_latest_tp_witness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">inv_sinv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">reflexivity</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">dependenceInRange</span> (<span class="id">s</span> <span class="id">latest_tp</span>, <span class="id">t</span>') <span class="id">c</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceInRange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">commandIxInRangeTransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H5</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">inv_sinv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span> <span class="kwd">in</span> <span class="id">witness_w_at_t</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">omega</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">completeDependenceSet</span> <span class="id">c</span>' (<span class="id">applyScheduleToDependenceSet</span> <span class="id">s</span> <span class="id">ds</span>)) <span class="kwd">as</span> <span class="id">ds</span>'<span class="id">_complete</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span>  <span class="id">dependenceSetTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H1</span>.<br/>
<br/>
<br/>
&nbsp;use&nbsp;the&nbsp;fact&nbsp;that&nbsp;ds'&nbsp;is&nbsp;complete&nbsp;to&nbsp;show&nbsp;that&nbsp;this&nbsp;dependence&nbsp;is&nbsp;fucked&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">List.In</span> (<span class="id">s</span> <span class="id">latest_tp</span>, <span class="id">t</span>') (<span class="id">applyScheduleToDependenceSet</span> <span class="id">s</span> <span class="id">ds</span>)) <span class="kwd">as</span> <span class="id">legit_dep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">ds</span>'<span class="id">_complete</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> (<span class="id">ds</span>'<span class="id">_complete</span> (<span class="id">s</span> <span class="id">latest_tp</span>, <span class="id">t</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">validDependence</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">applyScheduleToDependenceSet</span> <span class="kwd">in</span> <span class="id">legit_dep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">List.in_map_iff</span> <span class="kwd">in</span> <span class="id">legit_dep</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">legit_dep</span> <span class="kwd">as</span> [<span class="id">legit_dep_in_c</span> <span class="id">legit_dep_in_c_witness</span>].<br/>
<br/>
&nbsp;cool,&nbsp;we&nbsp;have&nbsp;a&nbsp;dependence&nbsp;in&nbsp;c.&nbsp;exploit&nbsp;this&nbsp;to&nbsp;derive&nbsp;contradicction&nbsp;*)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">legit_dep_in_c_witness</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">legit_dep_in_c</span> <span class="kwd">as</span> [<span class="id">c_dep_begin</span> <span class="id">c_dep_end</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H7</span>. <span class="tactic">clear</span> <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H4</span> (<span class="id">sinv</span> <span class="id">t</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">sinv</span> <span class="id">t</span>' &gt; <span class="id">latest_tp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>. <span class="id">specialize</span> (<span class="id">H4</span> <span class="id">H7</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">cut</span> (<span class="id">commandIxInRange</span> <span class="id">c</span> (<span class="id">sinv</span> <span class="id">t</span>')).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H4</span> <span class="id">H9</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span> <span class="kwd">as</span> [<span class="id">write_at_sinv_t</span>' <span class="id">write_at_sinv_t</span>'<span class="id">_witness</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">write_at_sinv_t</span>'<span class="id">_witness</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">Some</span> <span class="id">write_at_sinv_t</span>' = <span class="id">Some</span> <span class="id">w_at_t</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">TransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_inverse_symmetric</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H13</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H15</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">commandIxInRangeTransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_inverse_symmetric</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">sinv</span> <span class="id">t</span>' &gt; <span class="id">latest_tp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">c_dep_begin</span> = <span class="id">latest_tp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">is_inverse_injective</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">is_inverse</span> <span class="id">s</span> <span class="id">sinv</span>) <span class="kwd">as</span> <span class="id">inv_s_sinv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_inverse_symmetric</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">inv_s_sinv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">H10</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">c_dep_end</span> = <span class="id">sinv</span> <span class="id">t</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H11</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">erewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">inv_sinv_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> &lt;- <span class="id">H9</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">dependenceLexPositive</span> (<span class="id">c_dep_begin</span>, <span class="id">c_dep_end</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">completeDependenceSet</span> <span class="kwd">in</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H</span> (<span class="id">c_dep_begin</span>, <span class="id">c_dep_end</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H12</span> <span class="id">H8</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intuition</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">dependenceLexPositive</span> <span class="kwd">in</span> <span class="id">H12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H12</span>. <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;****  <span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;-  <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">inversion</span> <span class="id">H2</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">getLatestAliasingWriteTimepointForProgramCorrect</span>: <span class="kwd">forall</span> (<span class="id">c</span>: <span class="id">com</span>) (<span class="id">aliasix</span>: <span class="id">memix</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">aliasix</span> (<span class="id">getLatestAliasingWriteTimepointForProgram</span> <span class="id">c</span> <span class="id">aliasix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">induction</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">IHc</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">IHc</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="kwd">as</span> [<span class="id">wix</span> <span class="id">wval</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> = <span class="id">aliasix</span> \/ <span class="id">wix</span> &lt;&gt; <span class="id">aliasix</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">wix_eq_aliasix</span> | <span class="id">wix_neq_aliasix</span>].<br/>
&nbsp;&nbsp;- <span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">comlen</span> <span class="id">c</span> + 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> =? <span class="id">aliasix</span> = <span class="id">true</span>) <span class="kwd">as</span> <span class="id">wix_eq_aliasix</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">wix_eq_aliasix</span>'. <span class="tactic">clear</span> <span class="id">wix_eq_aliasix</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">assert</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">comlen</span> <span class="id">c</span> + 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> + 1 =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">wval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">wix_eq_aliasix</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**  <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> =? <span class="id">aliasix</span> = <span class="id">false</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span> <span class="kwd">as</span> [<span class="id">aliasingtp</span> <span class="id">aliasingtpwitness</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">aliasingtp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">destruct</span> <span class="id">aliasingtpwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">aliasingtpwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">commandIxInRangeInclusive</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">destruct</span> <span class="id">aliasingtpwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">aliasingtp</span> = <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) \/ <span class="id">aliasingtp</span> &lt;&gt; <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span> <span class="kwd">as</span> [<span class="id">aliasingtp_eq_end</span> | <span class="id">aliasingtp_neq_end</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getWriteAt</span>'<span class="id">RangeConsistent</span> <span class="kwd">in</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">aliasingtp_eq_end</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">aliasingtp_eq_end</span>. <span class="tactic">clear</span> <span class="id">aliasingtp</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) &lt;= <span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">as</span> <span class="id">contra</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>. <br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">aliasingtp</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>) <span class="kwd">as</span> <span class="id">aliasingtp_neq_end</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">aliasingtp_neq_end</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> <span class="id">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*  <span class="tactic">intros</span> <span class="id">tp_gt_aliasingtp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">tp_gt_aliasingtp_witness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">tp_gt_aliasingtp_inrange</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">aliasingtpwitness</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">_</span> <span class="id">tp_gt_aliasingtp_witness</span>).<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tp_gt_aliasingtp</span> = <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) \/<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tp_gt_aliasingtp</span> &lt; <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> *. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H4</span> <span class="kwd">as</span> [<span class="id">tp_gt_aliasingtp_eq_end</span> |<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">tp_gt_aliasingtp_neq_end</span>].<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tp_gt_aliasingtp</span> =? <span class="id">S</span>(<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>. <span class="tactic">clear</span> <span class="id">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>. <span class="tactic">assumption</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">tp_gt_aliasingtp</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H4</span>.<br/>
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">tp_gt_aliasingtp</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="kwd">as</span> <span class="id">tp_gt_aliasingtp_inrange</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> *. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H3</span> <span class="id">tp_gt_aliasingtp_inrange</span>').<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assumption</span>.<br/>
<br/>
&nbsp;&nbsp;- <span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">w</span> <span class="kwd">as</span> [<span class="id">wix</span> <span class="id">wval</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> = <span class="id">aliasix</span> \/ <span class="id">wix</span> &lt;&gt; <span class="id">aliasix</span>). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H0</span> <span class="kwd">as</span> [<span class="id">wix_eq_aliasix</span> | <span class="id">wix_neq_aliasix</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> =? <span class="id">aliasix</span> = <span class="id">true</span>). <span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>. <span class="tactic">clear</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">unfold</span> <span class="id">commandIxInRange</span>. <span class="tactic">unfold</span> <span class="id">comlen</span>. <span class="id">fold</span> <span class="id">comlen</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">intros</span>. <span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="id">exists</span> <span class="id">wval</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">comlen</span> <span class="id">c</span> =? <span class="id">comlen</span> <span class="id">c</span> = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">wix_eq_aliasix</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>. <span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">t0</span> &lt;= 1 + <span class="id">comlen</span> <span class="id">c</span> /\ <span class="id">t0</span> &gt; <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)) <span class="kwd">as</span> <span class="id">contra</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">wix</span> =? <span class="id">aliasix</span> = <span class="id">false</span>) <span class="kwd">as</span> <span class="id">wix_neq_aliasix</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">wix_neq_aliasix</span>'.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*  <span class="tactic">destruct</span> <span class="id">H</span>. <span class="tactic">exact</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">t0</span> = <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) \/ <span class="id">t0</span> &lt;&gt; <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>)). <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H1</span> <span class="kwd">as</span> [<span class="id">t0_eq_end</span> | <span class="id">t0_neq_end</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="tactic">assert</span> (<span class="id">t0</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_eq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">clear</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exists</span> (<span class="id">Write</span> <span class="id">wix</span> <span class="id">wval</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;** <span class="tactic">assert</span> (<span class="id">t0</span> =? <span class="id">S</span> (<span class="id">comlen</span> <span class="id">c</span>) = <span class="id">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">Nat.eqb_neq</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H1</span>. <span class="tactic">clear</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">commandIxInRange</span> <span class="id">c</span> <span class="id">t0</span>) <span class="kwd">as</span> <span class="id">t0_in_c_range</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">commandIxInRange</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">comlen</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">fold</span> <span class="id">comlen</span> <span class="kwd">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">specialize</span> (<span class="id">H1</span> <span class="id">_</span> <span class="id">t0_in_c_range</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;- <span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">getLatestAliasingWriteTimepointForProgram</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="tactic">intros</span>. <span class="tactic">inversion</span> <span class="id">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">simpl</span> <span class="kwd">in</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tactic">omega</span>.<br/>
Qed.</div>
<br/>
<br/>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">getWriteAt</span>'<span class="id">TransportAlongValidSchedule</span>':<br/>
&nbsp;&nbsp;<span class="kwd">forall</span> (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>) (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">tp</span>: <span class="id">timepoint</span>) (<span class="id">w</span>: <span class="id">write</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">getWriteAt</span>' <span class="id">c</span> <span class="id">tp</span> = <span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">tp</span>).<br/>
&nbsp;&nbsp;<span class="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> ((<span class="id">tp</span> &gt;= 1 /\ <span class="id">tp</span> &lt;= <span class="id">comlen</span> <span class="id">c</span>) \/ <span class="id">tp</span> = 0 \/ <span class="id">tp</span> &gt; <span class="id">comlen</span> <span class="id">c</span>) <span class="kwd">as</span> <span class="id">tp_cases</span>. <span class="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tp_cases</span> <span class="kwd">as</span> [<span class="id">tp_in_range</span> | <span class="id">tp_out_of_range</span>].<br/>
Abort.</div>
<br/>
<br/>
<span class="kwd">Theorem</span> <span class="id">reschedulePreservesSemantics</span>: <span class="kwd">forall</span> (<span class="id">c</span> <span class="id">c</span>': <span class="id">com</span>) (<span class="id">ds</span>: <span class="id">dependenceset</span>) (<span class="id">s</span> <span class="id">sinv</span>: <span class="id">nat</span> -&gt; <span class="id">nat</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">completeDependenceSet</span> <span class="id">c</span> <span class="id">ds</span> -&gt; <span class="id">scheduleMappingWitness</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">c</span> <span class="id">c</span>' -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">scheduleRespectsDependenceSet</span> <span class="id">s</span> <span class="id">ds</span> -&gt; <span class="id">c</span> === <span class="id">c</span>'.<br/>
<div class="toggleproof" onclick="toggleDisplay('proof50')">Proof.</div>
<div class="proofscript" id="proof50">
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">c</span>' <span class="id">ds</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">s</span> <span class="id">sinv</span> <span class="id">dscomplete</span> <span class="id">witness</span> <span class="id">respectsdeps</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">ceq</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">initmemory</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">functional_extensionality</span>.<br/>
&nbsp;&nbsp;<span class="tactic">intros</span> <span class="id">readix</span>.<br/>
&nbsp;&nbsp;<span class="tactic">set</span> (<span class="id">lastaliasingtp</span> := <span class="id">getLatestAliasingWriteTimepointForProgram</span> <span class="id">c</span> <span class="id">readix</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span> <span class="id">readix</span> (<span class="id">getLatestAliasingWriteTimepointForProgram</span> <span class="id">c</span> <span class="id">readix</span>)) <span class="kwd">as</span> <span class="id">latesttpspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">getLatestAliasingWriteTimepointForProgramCorrect</span>.<br/>
&nbsp;&nbsp;<span class="id">remember</span> <span class="id">latesttpspec</span> <span class="kwd">as</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">clear</span> <span class="id">Heqlatesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">latestAliasingWriteTimepointSpec</span> <span class="kwd">in</span> <span class="id">latesttpspec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">latesttpspec</span> <span class="kwd">as</span> [ <span class="id">havelatesttp</span> | <span class="id">nolatesttp</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">havelatesttp</span> <span class="kwd">as</span> [<span class="id">tp_of_latest</span> <span class="id">spec_of_tp_latest</span>].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">spec_of_tp_latest</span> <span class="kwd">as</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">tp_latest_witness</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">tp_latest_in_range</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id">tp_latest_has_write</span> <span class="id">no_t_after_tp</span>]]].<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">tp_latest_has_write</span> <span class="kwd">as</span> [<span class="id">tp_latest_wval</span> <span class="id">tp_latest_wval_witness</span>].<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">runProgram</span> <span class="id">c</span> <span class="id">initmemory</span> <span class="id">readix</span> = <span class="id">tp_latest_wval</span>).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">latestAliasingWriteWillBeValue</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">tp_latest_witness</span> <span class="kwd">in</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">tp_latest_wval_witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">runProgram</span> <span class="id">c</span>' <span class="id">initmemory</span> <span class="id">readix</span> = <span class="id">tp_latest_wval</span>).<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span>' <span class="id">readix</span> (<span class="id">Some</span> (<span class="id">s</span> <span class="id">tp_of_latest</span>))) <span class="kwd">as</span> <span class="id">latestt</span>'<span class="id">_spec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">latestAliasingWriteTimepointSpecTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">dscomplete</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">respectsdeps</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">tp_latest_witness</span> <span class="kwd">in</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">latesttpspec</span>'.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">latestAliasingWriteWillBeValue</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">latestt</span>'<span class="id">_spec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">getWriteAt</span>' <span class="id">c</span>' (<span class="id">s</span> <span class="id">tp_of_latest</span>) = <span class="id">Some</span>(<span class="id">Write</span> <span class="id">readix</span> <span class="id">tp_latest_wval</span>)).<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">getWriteAt</span>'<span class="id">TransportAlongValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">scheduleMappingWitnessSymmetric</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">is_inverse_cancellation</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">tp_latest_wval_witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">unfold</span> <span class="id">scheduleMappingWitness</span> <span class="kwd">in</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">witness</span>. <span class="tactic">destruct</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">is_inverse_symmetric</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H1</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">H0</span>.<br/>
&nbsp;&nbsp;<span class="tactic">auto</span>.<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">runProgram</span> <span class="id">c</span> <span class="id">initmemory</span> <span class="id">readix</span> = (<span class="id">initmemory</span> <span class="id">readix</span>)) <span class="kwd">as</span> <span class="id">c_val</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">noLatestAliasingWriteAllowsPunchthrough</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">nolatesttp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">latesttpspec</span>'.<br/>
<br/>
<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">runProgram</span> <span class="id">c</span>' <span class="id">initmemory</span> <span class="id">readix</span> = (<span class="id">initmemory</span> <span class="id">readix</span>)) <span class="kwd">as</span> <span class="id">c</span>'<span class="id">_val</span>.<br/>
&nbsp;&nbsp;<span class="tactic">apply</span> <span class="id">noLatestAliasingWriteAllowsPunchthrough</span>.<br/>
&nbsp;&nbsp;<span class="tactic">destruct</span> <span class="id">nolatesttp</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">H</span> <span class="kwd">in</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">assert</span> (<span class="id">latestAliasingWriteTimepointSpec</span> <span class="id">c</span>' <span class="id">readix</span> <span class="id">None</span>) <span class="kwd">as</span> <span class="id">transport_latest_tp_spec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">eapply</span> <span class="id">noLatestAliasingWriteTimepointTransportAcrossValidSchedule</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">witness</span>.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">latesttpspec</span>'.<br/>
&nbsp;&nbsp;<span class="tactic">exact</span> <span class="id">transport_latest_tp_spec</span>.<br/>
&nbsp;&nbsp;<span class="tactic">rewrite</span> <span class="id">c_val</span>. <span class="tactic">rewrite</span> <span class="id">c</span>'<span class="id">_val</span>. <span class="tactic">reflexivity</span>.<br/>
Qed.</div>
</div>
<div class="footer"><hr/>Generated by coq2html</div>
</body>
</html>
